syntax = "proto3";

package lambdabuffers.compiler;

/* Frontend Source information

Frontends are advised to include *Source* information to denote how their
*Source* content maps to the *Compiler Input*. It's essential when reporting
*Compiler* errors back to the Frontend.
*/
message SourceInfo {
  // A filename denoting the Source file.
  string file = 1;
  // Starting position in Source.
  SourcePosition pos_from = 2;
  // End position in Source.
  SourcePosition pos_to = 3;
}

/* Position in Source */
message SourcePosition {
  // Column index in the Source.
  int32 column = 1;
  // Row index in the Source.
  int32 row = 2;
}

/* Type term

A type expression that ocurrs in bodies of type definitions (message TyDef):

```lbf
sum Maybe a = Just a | Nothing

sum Either a b = Left a | Right b

sum SomeType a = Foo a (Maybe a) | Bar (Either (Maybe a) (SomeType a))
```

or in instance declarations:

```lbf
instance Eq (Maybe a)

instance Eq (SomeType Int)

instance (Eq (Maybe a), Eq (SomeType a)) Eq (Either (Maybe a) (SomeType a))
```

Check out [examples](examples/tys.textproto).
*/
message Ty {
  // A type variable, a type reference or a type application.
  oneof ty {
    // A type variable.
    TyVar ty_var = 1;
    // A type application.
    TyApp ty_app = 2;
    // A type reference.
    TyRef ty_ref = 3;
  }
  // Source information.
  SourceInfo source_info = 5;
}

/* Type variable */
message TyVar {
  // Variable name.
  VarName var_name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Type abstraction

A type expression that introduces type abstractions (ie. type functions). This
type term can only be introduced in the context of a
[type definition](@ref TyDef).
*/
message TyAbs {
  // List of type variables.
  repeated TyArg ty_args = 1;
  // Type body.
  TyBody ty_body = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Type application

A type expression that applies a type abstraction to a list of arguments.
*/
message TyApp {
  // Type function. TODO(bladyjoker): Rename to ty_abs?
  Ty ty_func = 1;
  // Arguments to apply.
  repeated Ty ty_args = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Type reference

A type expression that denotes a reference to a type available that's declared
locally or in foreign modules.
*/
message TyRef {
  // Local type reference.
  message Local {
    // Local module type name.
    TyName ty_name = 1;
  }
  // Foreign type reference.
  message Foreign {
    // Foreign module type name.
    TyName ty_name = 1;
    // Foreign module name.
    ModuleName module_name = 2;
  }
  // Local or a foreign type reference.
  oneof ty_ref {
    Local local_ty_ref = 1;
    Foreign foreign_ty_ref = 2;
  }
  // Source information.
  SourceInfo source_info = 3;
}

// A list of type expressions useful for debugging
message Tys {
  repeated Ty ties = 1;
}

/* ## Names */

/* Type name */
message TyName {
  // Name ::= [A-Z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Module name */
message ModuleName {
  // Parts of the module name denoting a hierarchichal namespace.
  repeated ModuleNamePart parts = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Module name part */
message ModuleNamePart {
  // Name ::= [A-Z]+[A-Za-z0-9_]*
  string name = 1;
  // Sounrce information.
  SourceInfo source_info = 2;
}

/* Type variable name */
message VarName {
  // Name ::= [a-z]+
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Sum type constructor name */
message ConstrName {
  // Name ::= [A-Z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Record type field name */
message FieldName {
  // Name ::= [a-z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Type class name */
message ClassName {
  // Name ::= [A-Z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Type definition

A type definition consists of a type name and its associated type term.

One way to look at it is that a type definition introduces a named 'type
abstraction' in the module scope. Concretely, `Either` can be considered a type
lambda of kind `Type -> Type -> Type`.

In fact, type definitions are the only way to introduce such types.

Once introduced in the module scope, type definitions are referred to using
[TyRef](@ref TyRef) term.
*/
message TyDef {
  // Type name.
  TyName ty_name = 1;
  // Type term.
  TyAbs ty_abs = 2; // TODO(bladyjoker): Turn into a oneOf TyAbs | Ty
  // Source information.
  SourceInfo source_info = 3;
}

/* Type arguments

Arguments in type abstractions.

Type arguments and therefore type variables have kinds, the Compiler only
accepts `Type` kinded type arguments ans therefore type variables.

However, to allow for future evolution if ever necessary, we attach the Kind
term to type arguments, even though the Compiler will reject any TyArg that's
not of kind `Type`.

Note, this effectively means that lambda Buffers doesn't support higher-kinded
types (ie. HKT).
*/
message TyArg {
  // Argument name corresponds to variable names.
  VarName arg_name = 1;
  // Argument kind.
  Kind arg_kind = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Kinds

A type of a type is called a 'kind'.
In Lambda Buffers, all type terms, namely TyArg, TyVar, TyRef, TyApp and TyAbs,
are either of kind `Type` or `Type -> Type` and `Type -> Type -> Type`
etc.
*/
message Kind {
  // A built-in kind.
  enum KindRef {
    // Unspecified kind SHOULD be inferred by the Compiler.
    KIND_REF_UNSPECIFIED = 0;
    // A `Type` kind (also know as `*` in Haskell) built-in.
    KIND_REF_TYPE = 1;
  };
  // A kind arrow.
  message KindArrow {
    Kind left = 1;
    Kind right = 2;
  }
  // Kind built-in reference or a kind arrow.
  oneof kind {
    KindRef kind_ref = 1;
    KindArrow kind_arrow = 2;
  };
  // Source information.
  SourceInfo source_info = 3;
}


/* Type body

Lambda Buffers type bodies are enriched type terms that can only be specified in
[type abstraction terms](@ref TyAbs).

TODO: Add Tuple and Record type bodies.
*/
message TyBody {
  // Either a sum type or an opaque.
  oneof ty_body {
    Opaque opaque = 1;
    Sum sum = 2;
  };
  // Source information.
  SourceInfo source_info = 3;
}

/* Opaque type body

A type that has an `Opaque` body represents a 'built-in' or a 'primitive' type
that's handled by the semantics 'under the hood'. It's called 'opaque' to denote
the fact that the Compiler has no knowledge of its structure, and relies that
the necessary knowledge is implemented elsewhere. The Codegen modules for any
target language have to be able to handle such types specifically and map to
existing value level representations and corresponding types.

Codegen modules would have to implement support for such defined types, for
example:
- In Python `Set a` would map to `set()` from the standard library,
- In Haskell `Set a` would map to `containers`.Data.Set.Set type.

Every `Opaque` type has to be considered deliberately for each language
environment targeted by Codegen modules.

TODO(bladyjoker): Consider attaching explicit Kind terms to Opaques.
*/
message Opaque {
  // Source information.
  SourceInfo source_info = 1;
}

/* Sum

It's a built-in type term that exists enclosed within a [type abstraction](@ref
TyAbs) term which introduces [type variables](@ref TyVar) in the scope of the
expression.

A type defined as a Sum type is just like a Haskell algebraic data type and
represents a sum of products.

It can essentially be expressed as `Either` type enriched with [constructor
name](@ref ConstrName) information.

```haskell

data Foo a b = Bar | Baz a | Bax b

-- corresponds to

type ConstrName = String
type Foo_ a b = Either
  ((), ConstrName)
  (Either
    (a, ConstrName)
    (b, ConstrName)
  )
```

TODO(bladyjoker): Cleanup.
*/
message Sum {
  // Constructor of a Sum type is a Product type term.
  message Constructor {
    // Constructor name.
    ConstrName constr_name = 1;
    // TODO(bladyjoker): Replace with ConstructorBody that's either Tuple or
    // Record.
    // Product type term.
    Product product = 2;
  };
  // Sum type constructors.
  repeated Constructor constructors = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Product

It's a built-in type term that exists enclosed within a [type abstraction](@ref
TyAbs) term which introduces [type variables](@ref TyVar) in the scope of the
expression.

It exists in two flavors, either a Record or a NTuple.

TODO(bladyjoker): Separate into Tuple and Record.
*/
message Product {
  // A record type expression.
  message Record {
    // Field in a record type.
    message Field {
      // Record field name.
      FieldName field_name = 1;
      // Field type.
      Ty field_ty = 2;
    }
    // Record fields.
    repeated Field fields = 1;
    // Source information.
    SourceInfo source_info = 2;
  }
  // A tuple type expression.
  message NTuple {
    // Fields in a tuple are types.
    repeated Ty fields = 1;
    // Source information.
    SourceInfo source_info = 2;
  }
  // A product is a record or a tuple.
  oneof product {
    Record record = 1;
    NTuple ntuple = 2;
  }
  // Source information.
  SourceInfo source_info = 3;
}

/* Type class definition

LambdaBuffers use type classes to talk about the various 'meanings' or
'semantics' we want to associate with the types in LambdaBuffers schemata.

For instance, most types can have `Eq` semantics, meaning they can be compared
for equality. Other can have `Json` semantics, meaning they have some encoding
in the Json format.

Using type classes and instance declarations, much like in Haskell, users can
specify the 'meaning' of each type they declare.

Note that for each type class introduced, the entire Codegen machinery must be
updated to support said type class. In other words, it doesn't come for free and
for each new type class, a Codegen support must be implemented for [opaque](@ref
Opaque) types
used and for generic structural rules to enable generic support for user derived
types.

TODO(bladyjoker): Cleanup and reformulate with Sean.
*/
message ClassDef {
  // Type class name.
  ClassName class_name = 1;
  // Type class arguments. Currently the Compiler only accepts single parameter
  // type class declarations.
  repeated TyArg class_args = 2;
  // Superclass constraints.
  repeated Constraint supers = 3;
  // Documentation elaborating on the type class.
  string documentation = 4;
  // Source information.
  SourceInfo source_info = 5;
}

/* Type class instances

Instance clauses enable users to specify 'semantic' rules for their types.
*/
message InstanceClause {
  // Type class name.
  ClassName class_name = 1;
  // Head of the instance clause. Currently, the Compiler only accepts single
  // parameter type classes.
  repeated Ty heads = 2;
  // Body of the rule, conjunction of constraints.
  repeated Constraint constraints = 3;
  // Source information.
  SourceInfo source_info = 4;
}

/* Constraint expression */
message Constraint {
  // Name of the type class.
  ClassName class_name = 1;
  // Constraint arguments.
  repeated Ty arguments = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Module

A module encapsulates type, class and instance definitions.
*/
message Module {
  // Module name.
  ModuleName module_name = 1;
  // Type definitions.
  repeated TyDef type_defs = 2;
  // Type class definitions.
  repeated ClassDef class_defs = 3;
  // Type class instance clauses.
  repeated InstanceClause instances = 4;
  // Source information.
  SourceInfo source_info = 5;
}

/* Compiler Input

Compiler Input is a fully self contained list of modules, the entire
compilation closure needed by the Compiler to perform its task.
*/
message CompilerInput {
  // Modules to compile.
  repeated Module modules = 1;
}
