syntax = "proto3";

package lambdabuffers.compiler;

/* Frontend Source information

Frontends are advised to include *Source* information to denote how their
*Source* content maps to the *Compiler Input*. It's essential when reporting
*Compiler* errors back to the Frontend.
*/
message SourceInfo {
  // A filename denoting the Source file.
  string file = 1;
  // Starting position in Source.
  SourcePosition pos_from = 2;
  // End position in Source.
  SourcePosition pos_to = 3;
}

/* Position in Source */
message SourcePosition {
  // Column index in the Source.
  int32 column = 1;
  // Row index in the Source.
  int32 row = 2;
}

/* Type term

A type term that ocurrs in bodies of type definitions (message TyDef):

```lbf
sum Maybe a = Just a | Nothing

sum Either a b = Left a | Right b

sum SomeType a = Foo a (Maybe a) | Bar (Either (Maybe a) (SomeType a))
```

or in instance declarations:

```lbf
instance Eq (Maybe a)

instance Eq (SomeType Int)

instance (Eq (Maybe a), Eq (SomeType a)) Eq (Either (Maybe a) (SomeType a))
```

Check out [examples](examples/tys.textproto).
*/
message Ty {
  // A type variable, a type reference or a type application.
  oneof ty {
    // A type variable.
    TyVar ty_var = 1;
    // A type application.
    TyApp ty_app = 2;
    // A type reference.
    TyRef ty_ref = 3;
  }
}

/* Type variable */
message TyVar {
  // Variable name.
  VarName var_name = 1;
}

/* Type abstraction

A type term that introduces type abstractions (ie. type functions). This
type term can only be introduced in the context of a
[type definition](@ref TyDef).
*/
message TyAbs {
  // List of type variables.
  // No type arguments means `delay` or `const ty_body`,
  // meaning `TyAbs [] ty_body = ty_body`.
  // Duplicate type arguments MUST be reported with
  // `ProtoParseError.MultipleTyArgError`.
  repeated TyArg ty_args = 1;
  // Type body.
  TyBody ty_body = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Type application

A type term that applies a type abstraction to a list of arguments.
*/
message TyApp {
  // Type function. TODO(bladyjoker): Rename to ty_abs?
  Ty ty_func = 1;
  // Arguments to apply.
  // No arguments to apply means `force`, meaning `TyApp ty_func [] = ty_func``
  repeated Ty ty_args = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Type reference

A type term that denotes a reference to a type available that's declared
locally or in foreign modules.
*/
message TyRef {
  // Local type reference.
  message Local {
    // Local module type name.
    TyName ty_name = 1;
    // Source information.
    SourceInfo source_info = 2;
  }
  // Foreign type reference.
  message Foreign {
    // Foreign module type name.
    TyName ty_name = 1;
    // Foreign module name.
    ModuleName module_name = 2;
    // Source information.
    SourceInfo source_info = 3;
  }
  // Local or a foreign type reference.
  oneof ty_ref {
    Local local_ty_ref = 1;
    Foreign foreign_ty_ref = 2;
  }
}

// A list of type terms useful for debugging
message Tys {
  repeated Ty ties = 1;
}

/* ## Names */

/* Type name */
message TyName {
  // Name ::= [A-Z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Module name */
message ModuleName {
  // Parts of the module name denoting a hierarchichal namespace.
  repeated ModuleNamePart parts = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Module name part */
message ModuleNamePart {
  // Name ::= [A-Z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Type variable name */
message VarName {
  // Name ::= [a-z]+
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Sum type constructor name */
message ConstrName {
  // Name ::= [A-Z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Record type field name */
message FieldName {
  // Name ::= [a-z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Type class name */
message ClassName {
  // Name ::= [A-Z]+[A-Za-z0-9_]*
  string name = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Type definition

A type definition consists of a type name and its associated type term.

One way to look at it is that a type definition introduces a named 'type
abstraction' in the module scope. Concretely, `Either` can be considered a type
lambda of kind `Type -> Type -> Type`.

In fact, type definitions are the only way to introduce such types.

Once introduced in the module scope, type definitions are referred to using
[TyRef](@ref TyRef) term.
*/
message TyDef {
  // Type name.
  TyName ty_name = 1;
  // Type term.
  TyAbs ty_abs = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Type arguments

Arguments in type abstractions.

Type arguments and therefore type variables have kinds, the Compiler only
accepts `Type` kinded type arguments ans therefore type variables.

However, to allow for future evolution if ever necessary, we attach the Kind
term to type arguments, even though the Compiler will reject any TyArg that's
not of kind `Type`.

Note, this effectively means that lambda Buffers doesn't support higher-kinded
types (ie. HKT).
*/
message TyArg {
  // Argument name corresponds to variable names.
  VarName arg_name = 1;
  // Argument kind.
  Kind arg_kind = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Kinds

A type of a type is called a 'kind'.
In Lambda Buffers, all type terms, namely TyArg, TyVar, TyRef, TyApp and TyAbs,
are either of kind `Type` or `Type -> Type` and `Type -> Type -> Type`
etc.
*/
message Kind {
  // A built-in kind.
  enum KindRef {
    // Unspecified kind SHOULD be inferred by the Compiler.
    KIND_REF_UNSPECIFIED = 0;
    // A `Type` kind (also know as `*` in Haskell) built-in.
    KIND_REF_TYPE = 1;
  };
  // A kind arrow.
  message KindArrow {
    Kind left = 1;
    Kind right = 2;
  }
  // Kind built-in reference or a kind arrow.
  oneof kind {
    KindRef kind_ref = 1;
    KindArrow kind_arrow = 2;
  };
}


/* Type body.

Lambda Buffers type bodies type terms that can only be specified in the
`TyAbs` context. It's a built-in type term that can only occur enclosed
within a `TyAbs` term which introduces `TyVar`s in the scope of the term.
*/
message TyBody {
  // Either an opaque, a sum/product/record type term.
  oneof ty_body {
    Opaque opaque = 1;
    Sum sum = 2;
    Product product = 3;
    Record record = 4;
  };
}

/* Opaque type.

A type that has an `Opaque` body represents a 'built-in' or a 'primitive' type
that's handled by the semantics 'under the hood'. It's called 'opaque' to denote
the fact that the Compiler has no knowledge of its structure, and relies that
the necessary knowledge is implemented elsewhere. The Codegen modules for any
target language have to be able to handle such types specifically and map to
existing value level representations and corresponding types.

Codegen modules would have to implement support for such defined types, for
example:
- In Python `Set a` would map to `set()` from the standard library,
- In Haskell `Set a` would map to `containers`.Data.Set.Set type.

Every `Opaque` type has to be considered deliberately for each language
environment targeted by Codegen modules.

TODO(bladyjoker): Consider attaching explicit Kind terms to Opaques.
*/
message Opaque {
  // Source information.
  SourceInfo source_info = 1;
}

/* A sum type term.

A type defined as a Sum type is just like a Haskell algebraic data type and
represents a sum of products.
*/
message Sum {
  // Constructor of a Sum type is a Product type term.
  message Constructor {
    // Constructor name.
    ConstrName constr_name = 1;
    // Product type term.
    Product product = 2;
  };
  // Sum type constructors.
  // Empty `constructors` means `void` and means that the type can't be
  // constructed. Compiler MAY report an error.
  // Duplicate constructors MUST be reported with
  // `ProtoParseError.MultipleConstructorError`.
  repeated Constructor constructors = 1;
  // Source information.
  SourceInfo source_info = 2;
}

// A product type term.
message Product {
  // Fields in a products are types.
  repeated Ty fields = 1;
  // Source information.
  SourceInfo source_info = 2;
}

// A record type term.
message Record {
  // Field in a record type.
  message Field {
    // Record field name.
    FieldName field_name = 1;
    // Field type.
    Ty field_ty = 2;
  }
  // Record fields.
  repeated Field fields = 1;
  // Source information.
  SourceInfo source_info = 2;
}

/* Type class definition

   LambdaBuffers use type classes to talk about the various 'meanings' or
   'semantics' we want to associate with the types in LambdaBuffers schemata.

   For instance, most types can have `Eq` semantics, meaning they can be
   compared for equality. Other can have `Ord` semantics, meaning they can be
   ordered.

   Using type classes and instance declarations, much like in Haskell, users can
   specify the 'meaning' of each type they declare. For example, serialization
   in LambdaBuffers is just another type class, it's treated the same as any
   other type class. Concretely, if we wish to provide JSON serialization for
   LambdaBuffers types, we declare such a type class and provide desired
   semantic rules:

   ```lbf module Foo

   class JSON a

   sum Foo a b = Bar a | Baz b

   derive JSON (Foo a b) ```

   Note that for each type class introduced, the Codegen machinery must be
   updated to support said type class. In other words, it doesn't come for free
   and for each new type class, a Codegen support must be implemented for any
   `InstanceClause` declared by the user. Once all the `InstanceClause`s have an
   implementation provided, all the `Derive`d implementation come for free.
*/
message ClassDef {
  // Type class name.
  ClassName class_name = 1;
  // Type class arguments.
  // Class with no arguments is a trivial class. Compiler MAY report an error.
  // TODO(bladyjoker): MultipleClassArgError.
  repeated TyArg class_args = 2;
  // Superclass constraints.
  repeated ClassConstraint supers = 3;
  // Documentation elaborating on the type class.
  string documentation = 4;
  // Source information.
  SourceInfo source_info = 5;
}

/* Class constraints

  A special constraint type denoting the constraints that occur on the rhs of
  class definitions. Only used to specify super class constraints in a
  `ClassDef`.

  Not to be confused with `Constraint` which denote type class rules.
 */
message ClassConstraint {
  // Type class reference.
  TyClassRef class_ref = 1;
  // Type variables quantified over `ClassDef` arguments.
  repeated TyVar args = 2;
}

/* Type class references

   It is necessary to know whether a type class is defined locally or in a
   foreign module when referring to it in a constraint, this allows users (and
   requires the frontend) to explicitly communicate that information.
*/
message TyClassRef {
  // Local type reference.
  message Local {
    // Local module class name.
    ClassName class_name = 1;
    // Source information.
    SourceInfo source_info = 2;
  }
  // Foreign class reference.
  message Foreign {
    // Foreign module class name.
    ClassName class_name = 1;
    // Foreign module name.
    ModuleName module_name = 2;
    // Source information.
    SourceInfo source_info = 3;
  }
  // Local or a foreign type class reference.
  oneof class_ref {
    Local local_class_ref = 1;
    Foreign foreign_class_ref = 2;
  }
}

/* Type class rules */

/* Instance clause

   Instance clauses enable users to specify ad-hoc 'semantic' rules for their
   types. Each such instance must be supported explicitly in the Codegen by
   providing runtime implementations.

   This rule form is used when declaring 'opaque' implementations on `Opaque`
   types.

   ```lbf
   module Prelude

   class Eq a

   opaque Maybe a

   instance Eq a => Eq (Maybe a)
   ```

   The rule installed for the clause is:

   ```prolog
   eq(maybe(A)) :- eq(A).
   ```

   The instance clause is verbatim added to the rule set.
*/
message InstanceClause {
  // Head of the clause that holds only when the `body` holds.
  // Type variables introduced in the head of the rule become available in the
  // scope of the body of the rule.
  Constraint head = 1;
  // Instance (rule) body, conjunction of constraints.
  repeated Constraint constraints = 3;
  // Source information.
  SourceInfo source_info = 4;
}

/* Derive statement

  Derive statements enable user to specify 'semantic' rules for their types much
  like `InstanceClause`s do. However, the Codegen will be able to derive an
  implementation for any such constraint.

  ```lbf
  module Prelude

  class Eq a

  sum Maybe a = Just a | Nothing

  derive Eq (Maybe a)
  ```

  The rule installed for the derive statement is:

  ```prolog
  eq(maybe(A)) :- eq(just(A) | Nothing).
  ```

  The rule relates the desired `Ty` term to its (lambda calculus)
  'evaluated' form.

  > Currently, there's only support for deriving type class rules and
    implementations for `Ty` terms of `Kind.KIND_REF_TYPE`. That means,
    type classes like Ord and Eq...
*/
message Derive {
  // Constraint to derive.
  Constraint constraint = 1;
}

/* Constraint term */
message Constraint {
  // Name of the type class.
  TyClassRef class_ref = 1;
  // Constraint arguments.
  // Constraint with no arguments is a trivial constraint.
  // Compiler MAY report an error.
  repeated Ty args = 2;
  // Source information.
  SourceInfo source_info = 3;
}

/* Module

A module encapsulates type, class and instance definitions.
*/
message Module {
  // Module name.
  ModuleName module_name = 1;
  // Type definitions.
  // Duplicate type definitions MUST be reported with
  // `ProtoParseError.MultipleTyDefError`.
  repeated TyDef type_defs = 2;
  // Type class definitions.
  // Duplicate class definitions MUST be reported with
  // `ProtoParseError.MultipleClassDefError`.
  repeated ClassDef class_defs = 3;
  // Type class instance clauses.
  repeated InstanceClause instances = 4;
  // Type class derive statements.
  repeated Derive derives = 5;
  // Imported modules the Compiler consults when searching for
  // instance clauses.
  // Duplicate imports MUST be reported with
  // `ProtoParseError.MultipleImportError`.
  repeated ModuleName imports = 6;
  // Source information.
  SourceInfo source_info = 7;
}

/* Compiler Input

Compiler Input is a fully self contained list of modules, the entire
compilation closure needed by the Compiler to perform its task.
*/
message CompilerInput {
  // Modules to compile.
  // Duplicate modules MUST be reported with
  // `ProtoParseError.MultipleModuleError`.
  repeated Module modules = 1;
}

// Errors internal to the implementation.
message InternalError {
  // Error message.
  string msg = 1;
  // Source information if meaningful.
  SourceInfo source_info = 2;
}

// All errors that occur because of Google Protocol Buffer's inability to
// enforce certain invariants.
// Some of invariance:
// - using Proto `map` restricts users to `string` keys which impacts
//   API documentation, which is why `repeated` fields are used throughout,
// - using Proto 'oneof' means users have to check if such a field is
//   set or report an error otherwise.
message ProtoParseError {
  // Multiple Modules with the same ModuleName were found.
  message MultipleModuleError {
    // Conflicting type definitions.
    repeated Module modules = 2;
  }

  // Multiple TyDefs with the same TyName were found in ModuleName.
  message MultipleTyDefError {
    // Module in which the error was found.
    ModuleName module_name = 1;
    // Conflicting type definitions.
    repeated TyDef ty_defs = 2;
  }

  // Multiple ClassDefs with the same ClassName were found in ModuleName.
  message MultipleClassDefError {
    // Module in which the error was found.
    ModuleName module_name = 1;
    // Conflicting class definitions.
    repeated ClassDef class_defs = 2;
  }

  // Multiple TyArgs with the same ArgName were found in ModuleName.TyDef.
  message MultipleTyArgError {
    // Module in which the error was found.
    ModuleName module_name = 1;
    // Type definition in which the error was found.
    TyDef ty_def = 2;
    // Conflicting type abstraction arguments.
    repeated TyArg ty_args = 3;
  }

  // Multiple Sum Constructors with the same ConstrName were found in
  // ModuleName.TyDef.
  message MultipleConstructorError {
    // Module in which the error was found.
    ModuleName module_name = 1;
    // Type definition in which the error was found.
    TyDef ty_def = 2;
    // Conflicting constructors.
    repeated Sum.Constructor constructors = 3;
  }

  // Multiple Record Fields with the same FieldName were found in
  // ModuleName.TyDef.
  message MultipleFieldError {
    // Module in which the error was found.
    ModuleName module_name = 1;
    // Type definition in which the error was found.
    TyDef ty_def = 2;
    // Conflicting record fields.
    repeated Record.Field fields = 3;
  }

  message MultipleImportError {
    // Module in which the error was found.
    ModuleName module_name = 1;
    // Conflicting module imports.
    repeated ModuleName imports = 2;
  }

  // Proto `oneof` field is not set.
  message OneOfNotSetError {
    // Proto message name in which the `oneof` field is not set.
    string message_name = 1;
    // The `oneof` field that is not set.
    string field_name = 2;
  }

  // Proto `enum` field is unknown.
  message UnknownEnumError {
    // Proto `enum` name.
    string enum_name = 1;
    // The unknown tag for the `enum`.
    string got_tag = 2;
  }

  oneof proto_parse_error {
    MultipleModuleError multiple_module_error = 1;
    MultipleTyDefError multiple_tydef_error = 2;
    MultipleClassDefError multiple_classdef_error = 3;
    MultipleTyArgError multiple_tyarg_error = 4;
    MultipleConstructorError multiple_constructor_error = 5;
    MultipleFieldError multiple_field_error = 6;
    MultipleImportError multiple_import_error = 7;
    OneOfNotSetError one_of_not_set_error = 8;
    UnknownEnumError unknown_enum_error = 9;
  }
}

// Kind checking errors.
message KindCheckError {

  // Unbound variable ty_var detected in term ty_def.
  message UnboundTyVarError {
    ModuleName module_name = 1;
    TyDef ty_def = 2;
    TyVar ty_var = 3;
  }

  // Unbound type reference ty_ref detected in term ty_def.
  message UnboundTyRefError {
    ModuleName module_name = 1;
    TyDef ty_def = 2;
    TyRef ty_ref = 3;
  }

  // In ty_def an error has occurred when trying to unify kind ty_kind_lhs
  // with ty_kind_rhs.
  //
  // FIXME(cstml): Add source of constraint to the error such that user can see
  // where the constraint was generated - therefore where the error precisely
  // is.
  message UnificationError {
    ModuleName module_name = 1;
    TyDef ty_def = 2;
    Kind ty_kind_lhs = 3;
    Kind ty_kind_rhs = 4;
  }

  // A cyclic kind was encountered. Infinite kinds like this are not acceptable,
  // and we do not support them. We could not construct infinite kind in ty_def.
  //
  // As the implementation currently stands such an error is (most likely) not
  // representable - therefore not reachable. Such an error would usually occur
  // for a term like: λa. a a - in which case the inference would try to unify
  // two kinds of the form: m and m -> n - because m appears in both terms -
  // the cyclic unification error would be thrown.
  //
  // In the case of LambdaBuffers - such an error is not (currently) achievable
  // as the kind of the variable is given by the context - (i.e. λa : m . a a,
  // where m is a kind) therefore the unification would fail with Unification
  // Error. Nevertheless - future features might require it.
  message CyclicKindError {
    TyDef ty_def = 1;
    ModuleName module_name = 2;
  }

  // The actual_kind differs from the expected_kind.
  message InconsistentTypeError {
    ModuleName module_name = 1;
    TyDef ty_def = 2;
    Kind actual_kind = 3;
    Kind expected_kind = 4;
  }

  // One of the errors occurred during kind checking.
  oneof kind_check_error {
    UnboundTyRefError unbound_ty_ref_error = 1;
    UnboundTyVarError unbound_ty_var_error = 2;
    UnificationError unification_error = 3;
    CyclicKindError cyclic_kind_error = 4;
    InconsistentTypeError inconsistent_type_error = 5;
  }
}

/* Naming error message */
message NamingError {
  // One of naming errors.
  oneof naming_error {
    ModuleNamePart module_name_err = 1;
    TyName ty_name_err = 2;
    VarName var_name_err = 3;
    ConstrName constr_name_err = 4;
    FieldName field_name_err = 5;
    ClassName class_name_err = 6;
  }
}

// Type class checking errors.
message TyClassCheckError {

  // Unbound `class_ref` detected in `module_name`.
  message UnboundClassRefError {
    ModuleName module_name = 1;
    TyClassRef class_ref = 2;
  }

  // Superclass cycle `cycled_class_refs` was detected when checking a
  // class definition for `class_name` in module `module_name`.
  message SuperclassCycleError {
    ModuleName module_name = 1;
    ClassName class_name = 2;
    repeated TyClassRef cycled_class_refs = 3;
  }

  // Import `missing` wasn't found in `module_name`
  message ImportNotFoundError {
    ModuleName module_name = 1;
    ModuleName missing = 2;
  }

  // In `module_name` it wasn't possible to solve `constraint` because a
  // `sub_constraint` has been derived on an `Opaque` type. `Opaque` type can
  // only have an `InstanceClause` declared for them.
  message DeriveOpaqueError {
    ModuleName module_name = 1;
    Constraint constraint = 2;
    Constraint sub_constraint = 3;
  }

  // In `module_name` a cycle of `cycled_constraints` was detected while trying
  // to solve `constraint`.
  message ConstraintCycleError {
    ModuleName module_name = 1;
    Constraint constraint = 2;
    repeated Constraint cycled_constraints = 3;
  }

  // In `module_name` while trying to solve `constraint` it wasn't possible to
  // find a rule (`Derive` or `InstanceClause`) for `sub_constraint`.
  message MissingRuleError {
    ModuleName module_name = 1;
    Constraint constraint = 2;
    Constraint sub_constraint = 3;
  }

  // In `module_name` while trying to solve `constraint` `overlaps` (`Derive`
  // or `InstanceClause`) were found that could be used to solve the
  // `sub_constraint`.
  message OverlappingRulesError {
    ModuleName module_name = 1;
    Constraint constraint = 2;
    Constraint sub_constraint = 3;
    // NOTE(bladyjoker): This should rather be oneof `Derive` and
    // `InstanceClause`.
    message QHead {
      ModuleName module_name = 1;
      Constraint head = 2;
    }
    repeated QHead overlaps = 4;
  }

  // One of the errors occurred during type class checking.
  oneof tyclass_check_error {
    UnboundClassRefError unbound_class_ref_err = 1;
    SuperclassCycleError superclass_cycle_err = 2;
    ImportNotFoundError import_not_found_err = 3;
    DeriveOpaqueError derive_opaque_err = 4;
    ConstraintCycleError constraint_cycle_err = 5;
    MissingRuleError missing_rule_err = 6;
    OverlappingRulesError overlapping_rules_err = 7;
  }
}

// Compiler Error
message CompilerError {
  // Errors occurred during proto parsing.
  repeated ProtoParseError proto_parse_errors = 1;
  // Errors occurred during naming checking.
  repeated NamingError naming_errors = 2;
  // Errors occurred during kind checking.
  repeated KindCheckError kind_check_errors = 4;
  // Errors occurred during type class checking.
  repeated TyClassCheckError ty_class_check_errors = 5;
  // Errors internal to the compiler implementation.
  repeated InternalError internal_errors = 6;
}

// Compiler Result ~ a successful Compilation Output.
message CompilerResult {
}

// Output of the Compiler.
message CompilerOutput {
  oneof compiler_output {
    CompilerError compiler_error = 1;
    CompilerResult compiler_result = 2;
  }
}
