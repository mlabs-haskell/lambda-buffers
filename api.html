<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>API - Lambda Buffers documentation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="using-lambdabuffers.html"><strong aria-hidden="true">2.</strong> Using LambdaBuffers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell.html"><strong aria-hidden="true">2.1.</strong> LambdaBuffers to Haskell</a></li><li class="chapter-item expanded "><a href="plutustx.html"><strong aria-hidden="true">2.2.</strong> LambdaBuffers to PlutusTx</a></li><li class="chapter-item expanded "><a href="purescript.html"><strong aria-hidden="true">2.3.</strong> LambdaBuffers to Purescript</a></li><li class="chapter-item expanded "><a href="plutarch.html"><strong aria-hidden="true">2.4.</strong> LambdaBuffers to Plutarch</a></li><li class="chapter-item expanded "><a href="rust.html"><strong aria-hidden="true">2.5.</strong> LambdaBuffers to Rust</a></li><li class="chapter-item expanded "><a href="typescript.html"><strong aria-hidden="true">2.6.</strong> LambdaBuffers to Typescript</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">3.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="design.html"><strong aria-hidden="true">4.</strong> Design</a></li><li class="chapter-item expanded "><a href="api.html" class="active"><strong aria-hidden="true">5.</strong> API</a></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">6.</strong> LambdaBuffers Frontend (.lbf) syntax</a></li><li class="chapter-item expanded "><a href="compiler.html"><strong aria-hidden="true">7.</strong> Compiler</a></li><li class="chapter-item expanded "><a href="codegen.html"><strong aria-hidden="true">8.</strong> Codegen</a></li><li class="chapter-item expanded "><a href="command-line-interface.html"><strong aria-hidden="true">9.</strong> Command line interface</a></li><li class="chapter-item expanded "><a href="comparison-matrix.html"><strong aria-hidden="true">10.</strong> Comparison matrix</a></li><li class="chapter-item expanded "><a href="aiken-integration.html"><strong aria-hidden="true">11.</strong> Aiken Research Document</a></li><li class="chapter-item expanded "><a href="catalyst-reports.html"><strong aria-hidden="true">12.</strong> Catalyst reports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="catalyst09-reports/index.html"><strong aria-hidden="true">12.1.</strong> Catalyst 9 reports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="catalyst09-reports/milestone-1.html"><strong aria-hidden="true">12.1.1.</strong> Milestone 1: Research</a></li><li class="chapter-item expanded "><a href="catalyst09-reports/milestone-2.html"><strong aria-hidden="true">12.1.2.</strong> Milestone 2: End to end proof of concept</a></li><li class="chapter-item expanded "><a href="catalyst09-reports/milestone-3.html"><strong aria-hidden="true">12.1.3.</strong> Milestone 3: Testing and documentation</a></li><li class="chapter-item expanded "><a href="catalyst09-reports/milestone-3.html"><strong aria-hidden="true">12.1.4.</strong> Milestone 4: Project adoption</a></li></ol></li><li class="chapter-item expanded "><a href="catalyst10-reports/index.html"><strong aria-hidden="true">12.2.</strong> Catalyst 10 reports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="catalyst10-reports/milestone-1.html"><strong aria-hidden="true">12.2.1.</strong> Milestone 1: Rust support</a></li><li class="chapter-item expanded "><a href="catalyst10-reports/milestone-2.html"><strong aria-hidden="true">12.2.2.</strong> Milestone 2: Javascript/Typescript support</a></li><li class="chapter-item expanded "><a href="catalyst10-reports/milestone-3.html"><strong aria-hidden="true">12.2.3.</strong> Milestone 3: Aiken integration research and development</a></li><li class="chapter-item expanded "><a href="catalyst10-reports/milestone-4.html"><strong aria-hidden="true">12.2.4.</strong> Milestone 4: Separate PlutusTx backend and improvements to existing LambdaBuffers facilities</a></li><li class="chapter-item expanded "><a href="catalyst10-reports/milestone-5.html"><strong aria-hidden="true">12.2.5.</strong> Final Milestone: Project scaffold for Rust, JavaScript and Haskell</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lambda Buffers documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="protocol-documentation"><a class="header" href="#protocol-documentation">Protocol Documentation</a></h1>
<p><a name="top"></a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li>
<p><a href="#lang-proto">lang.proto</a></p>
<ul>
<li>
<p><a href="#lambdabuffers-ClassConstraint">ClassConstraint</a></p>
</li>
<li>
<p><a href="#lambdabuffers-ClassDef">ClassDef</a></p>
</li>
<li>
<p><a href="#lambdabuffers-ClassName">ClassName</a></p>
</li>
<li>
<p><a href="#lambdabuffers-ConstrName">ConstrName</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Constraint">Constraint</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Derive">Derive</a></p>
</li>
<li>
<p><a href="#lambdabuffers-FieldName">FieldName</a></p>
</li>
<li>
<p><a href="#lambdabuffers-InstanceClause">InstanceClause</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Kind">Kind</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Kind-KindArrow">Kind.KindArrow</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Module">Module</a></p>
</li>
<li>
<p><a href="#lambdabuffers-ModuleName">ModuleName</a></p>
</li>
<li>
<p><a href="#lambdabuffers-ModuleNamePart">ModuleNamePart</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Opaque">Opaque</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Product">Product</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Record">Record</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Record-Field">Record.Field</a></p>
</li>
<li>
<p><a href="#lambdabuffers-SourceInfo">SourceInfo</a></p>
</li>
<li>
<p><a href="#lambdabuffers-SourcePosition">SourcePosition</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Sum">Sum</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Sum-Constructor">Sum.Constructor</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Ty">Ty</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyAbs">TyAbs</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyApp">TyApp</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyArg">TyArg</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyBody">TyBody</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyClassRef">TyClassRef</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyClassRef-Foreign">TyClassRef.Foreign</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyClassRef-Local">TyClassRef.Local</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyDef">TyDef</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyName">TyName</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyRef">TyRef</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyRef-Foreign">TyRef.Foreign</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyRef-Local">TyRef.Local</a></p>
</li>
<li>
<p><a href="#lambdabuffers-TyVar">TyVar</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Tys">Tys</a></p>
</li>
<li>
<p><a href="#lambdabuffers-VarName">VarName</a></p>
</li>
<li>
<p><a href="#lambdabuffers-Kind-KindRef">Kind.KindRef</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#compiler-proto">compiler.proto</a></p>
<ul>
<li><a href="#lambdabuffers-compiler-Error">Error</a></li>
<li><a href="#lambdabuffers-compiler-Input">Input</a></li>
<li><a href="#lambdabuffers-compiler-InternalError">InternalError</a></li>
<li><a href="#lambdabuffers-compiler-KindCheckError">KindCheckError</a></li>
<li><a href="#lambdabuffers-compiler-KindCheckError-CyclicKindError">KindCheckError.CyclicKindError</a></li>
<li><a href="#lambdabuffers-compiler-KindCheckError-InconsistentTypeError">KindCheckError.InconsistentTypeError</a></li>
<li><a href="#lambdabuffers-compiler-KindCheckError-UnboundTyRefError">KindCheckError.UnboundTyRefError</a></li>
<li><a href="#lambdabuffers-compiler-KindCheckError-UnboundTyVarError">KindCheckError.UnboundTyVarError</a></li>
<li><a href="#lambdabuffers-compiler-KindCheckError-UnificationError">KindCheckError.UnificationError</a></li>
<li><a href="#lambdabuffers-compiler-NamingError">NamingError</a></li>
<li><a href="#lambdabuffers-compiler-Output">Output</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError">ProtoParseError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-MultipleClassDefError">ProtoParseError.MultipleClassDefError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-MultipleConstructorError">ProtoParseError.MultipleConstructorError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-MultipleFieldError">ProtoParseError.MultipleFieldError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-MultipleImportError">ProtoParseError.MultipleImportError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-MultipleModuleError">ProtoParseError.MultipleModuleError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-MultipleTyArgError">ProtoParseError.MultipleTyArgError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-MultipleTyDefError">ProtoParseError.MultipleTyDefError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-OneOfNotSetError">ProtoParseError.OneOfNotSetError</a></li>
<li><a href="#lambdabuffers-compiler-ProtoParseError-UnknownEnumError">ProtoParseError.UnknownEnumError</a></li>
<li><a href="#lambdabuffers-compiler-Result">Result</a></li>
<li><a href="#lambdabuffers-compiler-TyClassCheckError">TyClassCheckError</a></li>
<li><a href="#lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError">TyClassCheckError.DeriveOpaqueError</a></li>
<li><a href="#lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError">TyClassCheckError.ImportNotFoundError</a></li>
<li><a href="#lambdabuffers-compiler-TyClassCheckError-MissingRuleError">TyClassCheckError.MissingRuleError</a></li>
<li><a href="#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError">TyClassCheckError.OverlappingRulesError</a></li>
<li><a href="#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead">TyClassCheckError.OverlappingRulesError.QHead</a></li>
<li><a href="#lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError">TyClassCheckError.SuperclassCycleError</a></li>
<li><a href="#lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError">TyClassCheckError.UnboundClassRefError</a></li>
</ul>
</li>
<li>
<p><a href="#codegen-proto">codegen.proto</a></p>
<ul>
<li><a href="#lambdabuffers-codegen-Error">Error</a></li>
<li><a href="#lambdabuffers-codegen-Input">Input</a></li>
<li><a href="#lambdabuffers-codegen-InternalError">InternalError</a></li>
<li><a href="#lambdabuffers-codegen-Output">Output</a></li>
<li><a href="#lambdabuffers-codegen-Result">Result</a></li>
<li><a href="#lambdabuffers-codegen-UnsupportedClassError">UnsupportedClassError</a></li>
<li><a href="#lambdabuffers-codegen-UnsupportedOpaqueError">UnsupportedOpaqueError</a></li>
</ul>
</li>
<li>
<p><a href="#scalar-value-types">Scalar Value Types</a></p>
</li>
</ul>
<p><a name="lang-proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2 id="langproto"><a class="header" href="#langproto">lang.proto</a></h2>
<p><a name="lambdabuffers-ClassConstraint"></a></p>
<h3 id="classconstraint"><a class="header" href="#classconstraint">ClassConstraint</a></h3>
<p>Class constraints</p>
<p>A special constraint type denoting the constraints that occur on the rhs of
class definitions. Only used to specify super class constraints in a
<code>ClassDef</code>.</p>
<p>Not to be confused with <code>Constraint</code> which denote type class rules.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_ref</td><td><a href="#lambdabuffers-TyClassRef">TyClassRef</a></td><td></td><td>Type class reference.</td></tr>
<tr><td>args</td><td><a href="#lambdabuffers-TyVar">TyVar</a></td><td>repeated</td><td>Type variables quantified over <code>ClassDef</code> arguments.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ClassDef"></a></p>
<h3 id="classdef"><a class="header" href="#classdef">ClassDef</a></h3>
<p>Type class definition</p>
<p>LambdaBuffers use type classes to talk about the various 'meanings' or
'semantics' we want to associate with the types in LambdaBuffers schemata.</p>
<p>For instance, most types can have <code>Eq</code> semantics, meaning they can be
compared for equality. Other can have <code>Ord</code> semantics, meaning they can be
ordered.</p>
<p>Using type classes and instance declarations, much like in Haskell, users can
specify the 'meaning' of each type they declare. For example, serialization
in LambdaBuffers is just another type class, it's treated the same as any
other type class. Concretely, if we wish to provide JSON serialization for
LambdaBuffers types, we declare such a type class and provide desired
semantic rules:</p>
<pre><code class="language-lbf">module Foo

class JSON a

sum Foo a b = Bar a | Baz b

derive JSON (Foo a b)
</code></pre>
<p>Note that for each type class introduced, the Codegen machinery must be
updated to support said type class. In other words, it doesn't come for free
and for each new type class, a Codegen support must be implemented for any
<code>InstanceClause</code> declared by the user. Once all the <code>InstanceClause</code>s have an
implementation provided, all the <code>Derive</code>d implementation come for free.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Type class name.</td></tr>
<tr><td>class_args</td><td><a href="#lambdabuffers-TyArg">TyArg</a></td><td>repeated</td><td>Type class arguments. Class with no arguments is a trivial class. Compiler MAY report an error. TODO(bladyjoker): MultipleClassArgError.</td></tr>
<tr><td>supers</td><td><a href="#lambdabuffers-ClassConstraint">ClassConstraint</a></td><td>repeated</td><td>Superclass constraints.</td></tr>
<tr><td>documentation</td><td><a href="#string">string</a></td><td></td><td>Documentation elaborating on the type class.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ClassName"></a></p>
<h3 id="classname"><a class="header" href="#classname">ClassName</a></h3>
<p>Type class name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ConstrName"></a></p>
<h3 id="constrname"><a class="header" href="#constrname">ConstrName</a></h3>
<p>Sum type constructor name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Constraint"></a></p>
<h3 id="constraint"><a class="header" href="#constraint">Constraint</a></h3>
<p>Constraint term</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_ref</td><td><a href="#lambdabuffers-TyClassRef">TyClassRef</a></td><td></td><td>Name of the type class.</td></tr>
<tr><td>args</td><td><a href="#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Constraint arguments. Constraint with no arguments is a trivial constraint. Compiler MAY report an error.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Derive"></a></p>
<h3 id="derive"><a class="header" href="#derive">Derive</a></h3>
<p>Derive statement</p>
<p>Derive statements enable user to specify 'semantic' rules for their types much
like <code>InstanceClause</code>s do. However, the Codegen will be able to derive an
implementation for any such constraint.</p>
<pre><code class="language-lbf">module Prelude

class Eq a

sum Maybe a = Just a | Nothing

derive Eq (Maybe a)
</code></pre>
<p>The rule installed for the derive statement is:</p>
<pre><code class="language-prolog">eq(maybe(A)) :- eq(just(A) | Nothing).
</code></pre>
<p>The rule relates the desired <code>Ty</code> term to its (lambda calculus)
'evaluated' form.</p>
<p>&gt; Currently, there's only support for deriving type class rules and
implementations for <code>Ty</code> terms of <code>Kind.KIND_REF_TYPE</code>. That means,
type classes like Ord and Eq...</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constraint</td><td><a href="#lambdabuffers-Constraint">Constraint</a></td><td></td><td>Constraint to derive.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-FieldName"></a></p>
<h3 id="fieldname"><a class="header" href="#fieldname">FieldName</a></h3>
<p>Record type field name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name ::= [a-z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-InstanceClause"></a></p>
<h3 id="instanceclause"><a class="header" href="#instanceclause">InstanceClause</a></h3>
<p>Instance clause</p>
<p>Instance clauses enable users to specify ad-hoc 'semantic' rules for their
types. Each such instance must be supported explicitly in the Codegen by
providing runtime implementations.</p>
<p>This rule form is used when declaring 'opaque' implementations on <code>Opaque</code>
types.</p>
<pre><code class="language-lbf">module Prelude

class Eq a

opaque Maybe a

instance Eq a =&amp;gt; Eq (Maybe a)
</code></pre>
<p>The rule installed for the clause is:</p>
<pre><code class="language-prolog">eq(maybe(A)) :- eq(A).
</code></pre>
<p>The instance clause is verbatim added to the rule set.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>head</td><td><a href="#lambdabuffers-Constraint">Constraint</a></td><td></td><td>Head of the clause that holds only when the <code>body</code> holds. Type variables introduced in the head of the rule become available in the scope of the body of the rule.</td></tr>
<tr><td>constraints</td><td><a href="#lambdabuffers-Constraint">Constraint</a></td><td>repeated</td><td>Instance (rule) body, conjunction of constraints.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind"></a></p>
<h3 id="kind"><a class="header" href="#kind">Kind</a></h3>
<p>Kinds</p>
<p>A type of a type is called a 'kind'.
In Lambda Buffers, all type terms, namely TyArg, TyVar, TyRef, TyApp and TyAbs,
are either of kind <code>Type</code> or <code>Type -&amp;gt; Type</code> and <code>Type -&amp;gt; Type -&amp;gt; Type</code>
etc.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>kind_ref</td><td><a href="#lambdabuffers-Kind-KindRef">Kind.KindRef</a></td><td></td><td></td></tr>
<tr><td>kind_arrow</td><td><a href="#lambdabuffers-Kind-KindArrow">Kind.KindArrow</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind-KindArrow"></a></p>
<h3 id="kindkindarrow"><a class="header" href="#kindkindarrow">Kind.KindArrow</a></h3>
<p>A kind arrow.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>left</td><td><a href="#lambdabuffers-Kind">Kind</a></td><td></td><td></td></tr>
<tr><td>right</td><td><a href="#lambdabuffers-Kind">Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Module"></a></p>
<h3 id="module"><a class="header" href="#module">Module</a></h3>
<p>Module</p>
<p>A module encapsulates type, class and instance definitions.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Module name.</td></tr>
<tr><td>type_defs</td><td><a href="#lambdabuffers-TyDef">TyDef</a></td><td>repeated</td><td>Type definitions. Duplicate type definitions MUST be reported with <code>ProtoParseError.MultipleTyDefError</code>.</td></tr>
<tr><td>class_defs</td><td><a href="#lambdabuffers-ClassDef">ClassDef</a></td><td>repeated</td><td>Type class definitions. Duplicate class definitions MUST be reported with <code>ProtoParseError.MultipleClassDefError</code>.</td></tr>
<tr><td>instances</td><td><a href="#lambdabuffers-InstanceClause">InstanceClause</a></td><td>repeated</td><td>Type class instance clauses.</td></tr>
<tr><td>derives</td><td><a href="#lambdabuffers-Derive">Derive</a></td><td>repeated</td><td>Type class derive statements.</td></tr>
<tr><td>imports</td><td><a href="#lambdabuffers-ModuleName">ModuleName</a></td><td>repeated</td><td>Imported modules the Compiler consults when searching for type class rules. TODO(bladyjoker): Rename to ruleImports. Duplicate imports MUST be reported with <code>ProtoParseError.MultipleImportError</code>.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ModuleName"></a></p>
<h3 id="modulename"><a class="header" href="#modulename">ModuleName</a></h3>
<p>Module name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>parts</td><td><a href="#lambdabuffers-ModuleNamePart">ModuleNamePart</a></td><td>repeated</td><td>Parts of the module name denoting a hierarchical namespace.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ModuleNamePart"></a></p>
<h3 id="modulenamepart"><a class="header" href="#modulenamepart">ModuleNamePart</a></h3>
<p>Module name part</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Opaque"></a></p>
<h3 id="opaque"><a class="header" href="#opaque">Opaque</a></h3>
<p>Opaque type.</p>
<p>A type that has an <code>Opaque</code> body represents a 'built-in' or a 'primitive' type
that's handled by the semantics 'under the hood'. It's called 'opaque' to denote
the fact that the Compiler has no knowledge of its structure, and relies that
the necessary knowledge is implemented elsewhere. The Codegen modules for any
target language have to be able to handle such types specifically and map to
existing value level representations and corresponding types.</p>
<p>Codegen modules would have to implement support for such defined types, for
example:</p>
<ul>
<li>In Python <code>Set a</code> would map to <code>set()</code> from the standard library,</li>
<li>In Haskell <code>Set a</code> would map to <code>containers</code>.Data.Set.Set type.</li>
</ul>
<p>Every <code>Opaque</code> type has to be considered deliberately for each language
environment targeted by Codegen modules.</p>
<p>TODO(bladyjoker): Consider attaching explicit Kind terms to Opaques.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Product"></a></p>
<h3 id="product"><a class="header" href="#product">Product</a></h3>
<p>A product type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>fields</td><td><a href="#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Fields in a products are types.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Record"></a></p>
<h3 id="record"><a class="header" href="#record">Record</a></h3>
<p>A record type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>fields</td><td><a href="#lambdabuffers-Record-Field">Record.Field</a></td><td>repeated</td><td>Record fields.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Record-Field"></a></p>
<h3 id="recordfield"><a class="header" href="#recordfield">Record.Field</a></h3>
<p>Field in a record type.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>field_name</td><td><a href="#lambdabuffers-FieldName">FieldName</a></td><td></td><td>Record field name.</td></tr>
<tr><td>field_ty</td><td><a href="#lambdabuffers-Ty">Ty</a></td><td></td><td>Field type.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-SourceInfo"></a></p>
<h3 id="sourceinfo"><a class="header" href="#sourceinfo">SourceInfo</a></h3>
<p>Frontend Source information</p>
<p>Frontends are advised to include <em>Source</em> information to denote how their
Source* content maps to the <em>Compiler Input</em>. It's essential when reporting
Compiler* errors back to the Frontend.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>file</td><td><a href="#string">string</a></td><td></td><td>A filename denoting the Source file.</td></tr>
<tr><td>pos_from</td><td><a href="#lambdabuffers-SourcePosition">SourcePosition</a></td><td></td><td>Starting position in Source.</td></tr>
<tr><td>pos_to</td><td><a href="#lambdabuffers-SourcePosition">SourcePosition</a></td><td></td><td>End position in Source.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-SourcePosition"></a></p>
<h3 id="sourceposition"><a class="header" href="#sourceposition">SourcePosition</a></h3>
<p>Position in Source</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>column</td><td><a href="#int32">int32</a></td><td></td><td>Column index in the Source.</td></tr>
<tr><td>row</td><td><a href="#int32">int32</a></td><td></td><td>Row index in the Source.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Sum"></a></p>
<h3 id="sum"><a class="header" href="#sum">Sum</a></h3>
<p>A sum type term.</p>
<p>A type defined as a Sum type is just like a Haskell algebraic data type and
represents a sum of products.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constructors</td><td><a href="#lambdabuffers-Sum-Constructor">Sum.Constructor</a></td><td>repeated</td><td>Sum type constructors. Empty <code>constructors</code> means <code>void</code> and means that the type can't be constructed. Compiler MAY report an error. Duplicate constructors MUST be reported with <code>ProtoParseError.MultipleConstructorError</code>.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Sum-Constructor"></a></p>
<h3 id="sumconstructor"><a class="header" href="#sumconstructor">Sum.Constructor</a></h3>
<p>Constructor of a Sum type is a Product type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constr_name</td><td><a href="#lambdabuffers-ConstrName">ConstrName</a></td><td></td><td>Constructor name.</td></tr>
<tr><td>product</td><td><a href="#lambdabuffers-Product">Product</a></td><td></td><td>Product type term.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Ty"></a></p>
<h3 id="ty"><a class="header" href="#ty">Ty</a></h3>
<p>Type term</p>
<p>A type term that occurs in bodies of type definitions (message TyDef):</p>
<pre><code class="language-lbf">sum Maybe a = Just a | Nothing

sum Either a b = Left a | Right b

sum SomeType a = Foo a (Maybe a) | Bar (Either (Maybe a) (SomeType a))
</code></pre>
<p>or in instance declarations:</p>
<pre><code class="language-lbf">instance Eq (Maybe a)

instance Eq (SomeType Int)

instance (Eq (Maybe a), Eq (SomeType a)) Eq (Either (Maybe a) (SomeType a))
</code></pre>
<p>Check out <a href="examples/tys.textproto">examples</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_var</td><td><a href="#lambdabuffers-TyVar">TyVar</a></td><td></td><td>A type variable.</td></tr>
<tr><td>ty_app</td><td><a href="#lambdabuffers-TyApp">TyApp</a></td><td></td><td>A type application.</td></tr>
<tr><td>ty_ref</td><td><a href="#lambdabuffers-TyRef">TyRef</a></td><td></td><td>A type reference.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyAbs"></a></p>
<h3 id="tyabs"><a class="header" href="#tyabs">TyAbs</a></h3>
<p>Type abstraction</p>
<p>A type term that introduces type abstractions (ie. type functions). This
type term can only be introduced in the context of a
[type definition](@ref TyDef).</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_args</td><td><a href="#lambdabuffers-TyArg">TyArg</a></td><td>repeated</td><td>List of type variables. No type arguments means <code>delay</code> or <code>const ty_body</code>, meaning <code>TyAbs [] ty_body = ty_body</code>. Duplicate type arguments MUST be reported with <code>ProtoParseError.MultipleTyArgError</code>.</td></tr>
<tr><td>ty_body</td><td><a href="#lambdabuffers-TyBody">TyBody</a></td><td></td><td>Type body.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyApp"></a></p>
<h3 id="tyapp"><a class="header" href="#tyapp">TyApp</a></h3>
<p>Type application</p>
<p>A type term that applies a type abstraction to a list of arguments.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_func</td><td><a href="#lambdabuffers-Ty">Ty</a></td><td></td><td>Type function. TODO(bladyjoker): Rename to ty_abs?</td></tr>
<tr><td>ty_args</td><td><a href="#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Arguments to apply. No arguments to apply means <code>force</code>, meaning `TyApp ty_func [] = ty_func``</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyArg"></a></p>
<h3 id="tyarg"><a class="header" href="#tyarg">TyArg</a></h3>
<p>Type arguments</p>
<p>Arguments in type abstractions.</p>
<p>Type arguments and therefore type variables have kinds, the Compiler only
accepts <code>Type</code> kinded type arguments ans therefore type variables.</p>
<p>However, to allow for future evolution if ever necessary, we attach the Kind
term to type arguments, even though the Compiler will reject any TyArg that's
not of kind <code>Type</code>.</p>
<p>Note, this effectively means that lambda Buffers doesn't support higher-kinded
types (ie. HKT).</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>arg_name</td><td><a href="#lambdabuffers-VarName">VarName</a></td><td></td><td>Argument name corresponds to variable names.</td></tr>
<tr><td>arg_kind</td><td><a href="#lambdabuffers-Kind">Kind</a></td><td></td><td>Argument kind.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyBody"></a></p>
<h3 id="tybody"><a class="header" href="#tybody">TyBody</a></h3>
<p>Type body.</p>
<p>Lambda Buffers type bodies type terms that can only be specified in the
<code>TyAbs</code> context. It's a built-in type term that can only occur enclosed
within a <code>TyAbs</code> term which introduces <code>TyVar</code>s in the scope of the term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>opaque</td><td><a href="#lambdabuffers-Opaque">Opaque</a></td><td></td><td></td></tr>
<tr><td>sum</td><td><a href="#lambdabuffers-Sum">Sum</a></td><td></td><td></td></tr>
<tr><td>product</td><td><a href="#lambdabuffers-Product">Product</a></td><td></td><td></td></tr>
<tr><td>record</td><td><a href="#lambdabuffers-Record">Record</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef"></a></p>
<h3 id="tyclassref"><a class="header" href="#tyclassref">TyClassRef</a></h3>
<p>Type class references</p>
<p>It is necessary to know whether a type class is defined locally or in a
foreign module when referring to it in a constraint, this allows users (and
requires the frontend) to explicitly communicate that information.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>local_class_ref</td><td><a href="#lambdabuffers-TyClassRef-Local">TyClassRef.Local</a></td><td></td><td></td></tr>
<tr><td>foreign_class_ref</td><td><a href="#lambdabuffers-TyClassRef-Foreign">TyClassRef.Foreign</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef-Foreign"></a></p>
<h3 id="tyclassrefforeign"><a class="header" href="#tyclassrefforeign">TyClassRef.Foreign</a></h3>
<p>Foreign class reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Foreign module class name.</td></tr>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Foreign module name.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef-Local"></a></p>
<h3 id="tyclassreflocal"><a class="header" href="#tyclassreflocal">TyClassRef.Local</a></h3>
<p>Local type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Local module class name.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyDef"></a></p>
<h3 id="tydef"><a class="header" href="#tydef">TyDef</a></h3>
<p>Type definition</p>
<p>A type definition consists of a type name and its associated type term.</p>
<p>One way to look at it is that a type definition introduces a named 'type
abstraction' in the module scope. Concretely, <code>Either</code> can be considered a type
lambda of kind <code>Type -&amp;gt; Type -&amp;gt; Type</code>.</p>
<p>In fact, type definitions are the only way to introduce such types.</p>
<p>Once introduced in the module scope, type definitions are referred to using
[TyRef](@ref TyRef) term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="#lambdabuffers-TyName">TyName</a></td><td></td><td>Type name.</td></tr>
<tr><td>ty_abs</td><td><a href="#lambdabuffers-TyAbs">TyAbs</a></td><td></td><td>Type term.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyName"></a></p>
<h3 id="tyname"><a class="header" href="#tyname">TyName</a></h3>
<p>Type name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef"></a></p>
<h3 id="tyref"><a class="header" href="#tyref">TyRef</a></h3>
<p>Type reference</p>
<p>A type term that denotes a reference to a type available that's declared
locally or in foreign modules.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>local_ty_ref</td><td><a href="#lambdabuffers-TyRef-Local">TyRef.Local</a></td><td></td><td></td></tr>
<tr><td>foreign_ty_ref</td><td><a href="#lambdabuffers-TyRef-Foreign">TyRef.Foreign</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef-Foreign"></a></p>
<h3 id="tyrefforeign"><a class="header" href="#tyrefforeign">TyRef.Foreign</a></h3>
<p>Foreign type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="#lambdabuffers-TyName">TyName</a></td><td></td><td>Foreign module type name.</td></tr>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Foreign module name.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef-Local"></a></p>
<h3 id="tyreflocal"><a class="header" href="#tyreflocal">TyRef.Local</a></h3>
<p>Local type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="#lambdabuffers-TyName">TyName</a></td><td></td><td>Local module type name.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyVar"></a></p>
<h3 id="tyvar"><a class="header" href="#tyvar">TyVar</a></h3>
<p>Type variable</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>var_name</td><td><a href="#lambdabuffers-VarName">VarName</a></td><td></td><td>Variable name.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Tys"></a></p>
<h3 id="tys"><a class="header" href="#tys">Tys</a></h3>
<p>A list of type terms useful for debugging</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ties</td><td><a href="#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-VarName"></a></p>
<h3 id="varname"><a class="header" href="#varname">VarName</a></h3>
<p>Type variable name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name ::= [a-z]+</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind-KindRef"></a></p>
<h3 id="kindkindref"><a class="header" href="#kindkindref">Kind.KindRef</a></h3>
<p>A built-in kind.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>KIND_REF_UNSPECIFIED</td><td>0</td><td>Unspecified kind SHOULD be inferred by the Compiler.</td></tr>
<tr><td>KIND_REF_TYPE</td><td>1</td><td>A <code>Type</code> kind (also know as <code>*</code> in Haskell) built-in.</td></tr>
</tbody></table>
</div>
<p><a name="compiler-proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2 id="compilerproto"><a class="header" href="#compilerproto">compiler.proto</a></h2>
<p><a name="lambdabuffers-compiler-Error"></a></p>
<h3 id="error"><a class="header" href="#error">Error</a></h3>
<p>Compiler Error</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>proto_parse_errors</td><td><a href="#lambdabuffers-compiler-ProtoParseError">ProtoParseError</a></td><td>repeated</td><td>Errors occurred during proto parsing.</td></tr>
<tr><td>naming_errors</td><td><a href="#lambdabuffers-compiler-NamingError">NamingError</a></td><td>repeated</td><td>Errors occurred during naming checking.</td></tr>
<tr><td>kind_check_errors</td><td><a href="#lambdabuffers-compiler-KindCheckError">KindCheckError</a></td><td>repeated</td><td>Errors occurred during kind checking.</td></tr>
<tr><td>ty_class_check_errors</td><td><a href="#lambdabuffers-compiler-TyClassCheckError">TyClassCheckError</a></td><td>repeated</td><td>Errors occurred during type class checking.</td></tr>
<tr><td>internal_errors</td><td><a href="#lambdabuffers-compiler-InternalError">InternalError</a></td><td>repeated</td><td>Errors internal to the compiler implementation.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Input"></a></p>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<p>Compiler Input</p>
<p>Compiler Input is a fully self contained list of modules, the entire
compilation closure needed by the Compiler to perform its task.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Modules to compile. Duplicate modules MUST be reported with <code>ProtoParseError.MultipleModuleError</code>.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-InternalError"></a></p>
<h3 id="internalerror"><a class="header" href="#internalerror">InternalError</a></h3>
<p>Errors internal to the implementation.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msg</td><td><a href="#string">string</a></td><td></td><td>Error message.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">lambdabuffers.SourceInfo</a></td><td></td><td>Source information if meaningful.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError"></a></p>
<h3 id="kindcheckerror"><a class="header" href="#kindcheckerror">KindCheckError</a></h3>
<p>Kind checking errors.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>unbound_ty_ref_error</td><td><a href="#lambdabuffers-compiler-KindCheckError-UnboundTyRefError">KindCheckError.UnboundTyRefError</a></td><td></td><td></td></tr>
<tr><td>unbound_ty_var_error</td><td><a href="#lambdabuffers-compiler-KindCheckError-UnboundTyVarError">KindCheckError.UnboundTyVarError</a></td><td></td><td></td></tr>
<tr><td>unification_error</td><td><a href="#lambdabuffers-compiler-KindCheckError-UnificationError">KindCheckError.UnificationError</a></td><td></td><td></td></tr>
<tr><td>cyclic_kind_error</td><td><a href="#lambdabuffers-compiler-KindCheckError-CyclicKindError">KindCheckError.CyclicKindError</a></td><td></td><td></td></tr>
<tr><td>inconsistent_type_error</td><td><a href="#lambdabuffers-compiler-KindCheckError-InconsistentTypeError">KindCheckError.InconsistentTypeError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-CyclicKindError"></a></p>
<h3 id="kindcheckerrorcyclickinderror"><a class="header" href="#kindcheckerrorcyclickinderror">KindCheckError.CyclicKindError</a></h3>
<p>A cyclic kind was encountered. Infinite kinds like this are not acceptable,
and we do not support them. We could not construct infinite kind in ty_def.</p>
<p>As the implementation currently stands such an error is (most likely) not
representable - therefore not reachable. Such an error would usually occur
for a term like: a. a a - in which case the inference would try to unify
two kinds of the form: m and m -&gt; n - because m appears in both terms -
the cyclic unification error would be thrown.</p>
<p>In the case of LambdaBuffers - such an error is not (currently) achievable
as the kind of the variable is given by the context - (i.e. a : m . a a,
where m is a kind) therefore the unification would fail with Unification
Error. Nevertheless - future features might require it.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_def</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-InconsistentTypeError"></a></p>
<h3 id="kindcheckerrorinconsistenttypeerror"><a class="header" href="#kindcheckerrorinconsistenttypeerror">KindCheckError.InconsistentTypeError</a></h3>
<p>The actual_kind differs from the expected_kind.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>actual_kind</td><td><a href="#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
<tr><td>expected_kind</td><td><a href="#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnboundTyRefError"></a></p>
<h3 id="kindcheckerrorunboundtyreferror"><a class="header" href="#kindcheckerrorunboundtyreferror">KindCheckError.UnboundTyRefError</a></h3>
<p>Unbound type reference ty_ref detected in term ty_def.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_ref</td><td><a href="#lambdabuffers-TyRef">lambdabuffers.TyRef</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnboundTyVarError"></a></p>
<h3 id="kindcheckerrorunboundtyvarerror"><a class="header" href="#kindcheckerrorunboundtyvarerror">KindCheckError.UnboundTyVarError</a></h3>
<p>Unbound variable ty_var detected in term ty_def.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_var</td><td><a href="#lambdabuffers-TyVar">lambdabuffers.TyVar</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnificationError"></a></p>
<h3 id="kindcheckerrorunificationerror"><a class="header" href="#kindcheckerrorunificationerror">KindCheckError.UnificationError</a></h3>
<p>In ty_def an error has occurred when trying to unify kind ty_kind_lhs
with ty_kind_rhs.</p>
<p>FIXME(cstml): Add source of constraint to the error such that user can see
where the constraint was generated - therefore where the error precisely
is.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_kind_lhs</td><td><a href="#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
<tr><td>ty_kind_rhs</td><td><a href="#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-NamingError"></a></p>
<h3 id="namingerror"><a class="header" href="#namingerror">NamingError</a></h3>
<p>Naming error message</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name_err</td><td><a href="#lambdabuffers-ModuleNamePart">lambdabuffers.ModuleNamePart</a></td><td></td><td></td></tr>
<tr><td>ty_name_err</td><td><a href="#lambdabuffers-TyName">lambdabuffers.TyName</a></td><td></td><td></td></tr>
<tr><td>var_name_err</td><td><a href="#lambdabuffers-VarName">lambdabuffers.VarName</a></td><td></td><td></td></tr>
<tr><td>constr_name_err</td><td><a href="#lambdabuffers-ConstrName">lambdabuffers.ConstrName</a></td><td></td><td></td></tr>
<tr><td>field_name_err</td><td><a href="#lambdabuffers-FieldName">lambdabuffers.FieldName</a></td><td></td><td></td></tr>
<tr><td>class_name_err</td><td><a href="#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Output"></a></p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>Output of the Compiler.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>error</td><td><a href="#lambdabuffers-compiler-Error">Error</a></td><td></td><td></td></tr>
<tr><td>result</td><td><a href="#lambdabuffers-compiler-Result">Result</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError"></a></p>
<h3 id="protoparseerror"><a class="header" href="#protoparseerror">ProtoParseError</a></h3>
<p>All errors that occur because of Google Protocol Buffer's inability to
enforce certain invariants.
Some of invariance:</p>
<ul>
<li>using Proto <code>map</code> restricts users to <code>string</code> keys which impacts
API documentation, which is why <code>repeated</code> fields are used throughout,</li>
<li>using Proto 'oneof' means users have to check if such a field is
set or report an error otherwise.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>multiple_module_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-MultipleModuleError">ProtoParseError.MultipleModuleError</a></td><td></td><td></td></tr>
<tr><td>multiple_tydef_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-MultipleTyDefError">ProtoParseError.MultipleTyDefError</a></td><td></td><td></td></tr>
<tr><td>multiple_classdef_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-MultipleClassDefError">ProtoParseError.MultipleClassDefError</a></td><td></td><td></td></tr>
<tr><td>multiple_tyarg_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-MultipleTyArgError">ProtoParseError.MultipleTyArgError</a></td><td></td><td></td></tr>
<tr><td>multiple_constructor_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-MultipleConstructorError">ProtoParseError.MultipleConstructorError</a></td><td></td><td></td></tr>
<tr><td>multiple_field_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-MultipleFieldError">ProtoParseError.MultipleFieldError</a></td><td></td><td></td></tr>
<tr><td>multiple_import_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-MultipleImportError">ProtoParseError.MultipleImportError</a></td><td></td><td></td></tr>
<tr><td>one_of_not_set_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-OneOfNotSetError">ProtoParseError.OneOfNotSetError</a></td><td></td><td></td></tr>
<tr><td>unknown_enum_error</td><td><a href="#lambdabuffers-compiler-ProtoParseError-UnknownEnumError">ProtoParseError.UnknownEnumError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleClassDefError"></a></p>
<h3 id="protoparseerrormultipleclassdeferror"><a class="header" href="#protoparseerrormultipleclassdeferror">ProtoParseError.MultipleClassDefError</a></h3>
<p>Multiple ClassDefs with the same ClassName were found in ModuleName.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>class_defs</td><td><a href="#lambdabuffers-ClassDef">lambdabuffers.ClassDef</a></td><td>repeated</td><td>Conflicting class definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleConstructorError"></a></p>
<h3 id="protoparseerrormultipleconstructorerror"><a class="header" href="#protoparseerrormultipleconstructorerror">ProtoParseError.MultipleConstructorError</a></h3>
<p>Multiple Sum Constructors with the same ConstrName were found in
ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>constructors</td><td><a href="#lambdabuffers-Sum-Constructor">lambdabuffers.Sum.Constructor</a></td><td>repeated</td><td>Conflicting constructors.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleFieldError"></a></p>
<h3 id="protoparseerrormultiplefielderror"><a class="header" href="#protoparseerrormultiplefielderror">ProtoParseError.MultipleFieldError</a></h3>
<p>Multiple Record Fields with the same FieldName were found in
ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>fields</td><td><a href="#lambdabuffers-Record-Field">lambdabuffers.Record.Field</a></td><td>repeated</td><td>Conflicting record fields.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleImportError"></a></p>
<h3 id="protoparseerrormultipleimporterror"><a class="header" href="#protoparseerrormultipleimporterror">ProtoParseError.MultipleImportError</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>imports</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td>repeated</td><td>Conflicting module imports.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleModuleError"></a></p>
<h3 id="protoparseerrormultiplemoduleerror"><a class="header" href="#protoparseerrormultiplemoduleerror">ProtoParseError.MultipleModuleError</a></h3>
<p>Multiple Modules with the same ModuleName were found.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Conflicting type definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleTyArgError"></a></p>
<h3 id="protoparseerrormultipletyargerror"><a class="header" href="#protoparseerrormultipletyargerror">ProtoParseError.MultipleTyArgError</a></h3>
<p>Multiple TyArgs with the same ArgName were found in ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>ty_args</td><td><a href="#lambdabuffers-TyArg">lambdabuffers.TyArg</a></td><td>repeated</td><td>Conflicting type abstraction arguments.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleTyDefError"></a></p>
<h3 id="protoparseerrormultipletydeferror"><a class="header" href="#protoparseerrormultipletydeferror">ProtoParseError.MultipleTyDefError</a></h3>
<p>Multiple TyDefs with the same TyName were found in ModuleName.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_defs</td><td><a href="#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td>repeated</td><td>Conflicting type definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-OneOfNotSetError"></a></p>
<h3 id="protoparseerroroneofnotseterror"><a class="header" href="#protoparseerroroneofnotseterror">ProtoParseError.OneOfNotSetError</a></h3>
<p>Proto <code>oneof</code> field is not set.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>message_name</td><td><a href="#string">string</a></td><td></td><td>Proto message name in which the <code>oneof</code> field is not set.</td></tr>
<tr><td>field_name</td><td><a href="#string">string</a></td><td></td><td>The <code>oneof</code> field that is not set.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-UnknownEnumError"></a></p>
<h3 id="protoparseerrorunknownenumerror"><a class="header" href="#protoparseerrorunknownenumerror">ProtoParseError.UnknownEnumError</a></h3>
<p>Proto <code>enum</code> field is unknown.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>enum_name</td><td><a href="#string">string</a></td><td></td><td>Proto <code>enum</code> name.</td></tr>
<tr><td>got_tag</td><td><a href="#string">string</a></td><td></td><td>The unknown tag for the <code>enum</code>.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Result"></a></p>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<p>Compiler Result ~ a successful Compilation Output.</p>
<p><a name="lambdabuffers-compiler-TyClassCheckError"></a></p>
<h3 id="tyclasscheckerror"><a class="header" href="#tyclasscheckerror">TyClassCheckError</a></h3>
<p>Type class checking errors.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>unbound_class_ref_err</td><td><a href="#lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError">TyClassCheckError.UnboundClassRefError</a></td><td></td><td></td></tr>
<tr><td>superclass_cycle_err</td><td><a href="#lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError">TyClassCheckError.SuperclassCycleError</a></td><td></td><td></td></tr>
<tr><td>import_not_found_err</td><td><a href="#lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError">TyClassCheckError.ImportNotFoundError</a></td><td></td><td></td></tr>
<tr><td>derive_opaque_err</td><td><a href="#lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError">TyClassCheckError.DeriveOpaqueError</a></td><td></td><td></td></tr>
<tr><td>missing_rule_err</td><td><a href="#lambdabuffers-compiler-TyClassCheckError-MissingRuleError">TyClassCheckError.MissingRuleError</a></td><td></td><td></td></tr>
<tr><td>overlapping_rules_err</td><td><a href="#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError">TyClassCheckError.OverlappingRulesError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError"></a></p>
<h3 id="tyclasscheckerrorderiveopaqueerror"><a class="header" href="#tyclasscheckerrorderiveopaqueerror">TyClassCheckError.DeriveOpaqueError</a></h3>
<p>In <code>module_name</code> it wasn't possible to solve <code>constraint</code> because a
<code>sub_constraint</code> has been derived on an <code>Opaque</code> type. <code>Opaque</code> type can
only have an <code>InstanceClause</code> declared for them.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError"></a></p>
<h3 id="tyclasscheckerrorimportnotfounderror"><a class="header" href="#tyclasscheckerrorimportnotfounderror">TyClassCheckError.ImportNotFoundError</a></h3>
<p>Import <code>missing</code> wasn't found in <code>module_name</code></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>missing</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-MissingRuleError"></a></p>
<h3 id="tyclasscheckerrormissingruleerror"><a class="header" href="#tyclasscheckerrormissingruleerror">TyClassCheckError.MissingRuleError</a></h3>
<p>In <code>module_name</code> while trying to solve <code>constraint</code> it wasn't possible to
find a rule (<code>Derive</code> or <code>InstanceClause</code>) for <code>sub_constraint</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError"></a></p>
<h3 id="tyclasscheckerroroverlappingruleserror"><a class="header" href="#tyclasscheckerroroverlappingruleserror">TyClassCheckError.OverlappingRulesError</a></h3>
<p>In <code>module_name</code> while trying to solve <code>constraint</code> <code>overlaps</code> (<code>Derive</code>
or <code>InstanceClause</code>) were found that could be used to solve the
<code>sub_constraint</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>overlaps</td><td><a href="#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead">TyClassCheckError.OverlappingRulesError.QHead</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead"></a></p>
<h3 id="tyclasscheckerroroverlappingruleserrorqhead"><a class="header" href="#tyclasscheckerroroverlappingruleserrorqhead">TyClassCheckError.OverlappingRulesError.QHead</a></h3>
<p>NOTE(bladyjoker): This should rather be oneof <code>Derive</code> and
<code>InstanceClause</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>head</td><td><a href="#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError"></a></p>
<h3 id="tyclasscheckerrorsuperclasscycleerror"><a class="header" href="#tyclasscheckerrorsuperclasscycleerror">TyClassCheckError.SuperclassCycleError</a></h3>
<p>Superclass cycle <code>cycled_class_refs</code> was detected when checking a
class definition for <code>class_name</code> in module <code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_name</td><td><a href="#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
<tr><td>cycled_class_refs</td><td><a href="#lambdabuffers-TyClassRef">lambdabuffers.TyClassRef</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError"></a></p>
<h3 id="tyclasscheckerrorunboundclassreferror"><a class="header" href="#tyclasscheckerrorunboundclassreferror">TyClassCheckError.UnboundClassRefError</a></h3>
<p>Unbound <code>class_ref</code> detected in <code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_ref</td><td><a href="#lambdabuffers-TyClassRef">lambdabuffers.TyClassRef</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="codegen-proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2 id="codegenproto"><a class="header" href="#codegenproto">codegen.proto</a></h2>
<p><a name="lambdabuffers-codegen-Error"></a></p>
<h3 id="error-1"><a class="header" href="#error-1">Error</a></h3>
<p>Codegen Error</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>internal_errors</td><td><a href="#lambdabuffers-codegen-InternalError">InternalError</a></td><td>repeated</td><td></td></tr>
<tr><td>unsupported_opaque_errors</td><td><a href="#lambdabuffers-codegen-UnsupportedOpaqueError">UnsupportedOpaqueError</a></td><td>repeated</td><td></td></tr>
<tr><td>unsupported_class_errors</td><td><a href="#lambdabuffers-codegen-UnsupportedClassError">UnsupportedClassError</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Input"></a></p>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<p>Codegen Input</p>
<p>Codegen Input is a fully self contained list of modules,
that have been checked by the Compiler.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Modules to codegen.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-InternalError"></a></p>
<h3 id="internalerror-1"><a class="header" href="#internalerror-1">InternalError</a></h3>
<p>Errors internal to the implementation.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msg</td><td><a href="#string">string</a></td><td></td><td>Error message.</td></tr>
<tr><td>source_info</td><td><a href="#lambdabuffers-SourceInfo">lambdabuffers.SourceInfo</a></td><td></td><td>Source information if meaningful.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Output"></a></p>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<p>Codegen output.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>error</td><td><a href="#lambdabuffers-codegen-Error">Error</a></td><td></td><td></td></tr>
<tr><td>result</td><td><a href="#lambdabuffers-codegen-Result">Result</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Result"></a></p>
<h3 id="result-1"><a class="header" href="#result-1">Result</a></h3>
<p>Codegen Result ~ a successful Codegen Output.</p>
<p><a name="lambdabuffers-codegen-UnsupportedClassError"></a></p>
<h3 id="unsupportedclasserror"><a class="header" href="#unsupportedclasserror">UnsupportedClassError</a></h3>
<p>Unsupported <code>Class</code> error for a class <code>class_name</code> defined in module
<code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_name</td><td><a href="#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-UnsupportedOpaqueError"></a></p>
<h3 id="unsupportedopaqueerror"><a class="header" href="#unsupportedopaqueerror">UnsupportedOpaqueError</a></h3>
<p>Unsupported <code>Opaque</code> error for a type <code>ty_name</code> defined in module
<code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_name</td><td><a href="#lambdabuffers-TyName">lambdabuffers.TyName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="scalar-value-types"><a class="header" href="#scalar-value-types">Scalar Value Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>.proto Type</th><th>Notes</th><th>C++</th><th>Java</th><th>Python</th><th>Go</th><th>C#</th><th>PHP</th><th>Ruby</th></tr></thead><tbody>
<tr><td><a name="double" /> double</td><td></td><td>double</td><td>double</td><td>float</td><td>float64</td><td>double</td><td>float</td><td>Float</td></tr>
<tr><td><a name="float" /> float</td><td></td><td>float</td><td>float</td><td>float</td><td>float32</td><td>float</td><td>float</td><td>Float</td></tr>
<tr><td><a name="int32" /> int32</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers  if your field is likely to have negative values, use sint32 instead.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="int64" /> int64</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers  if your field is likely to have negative values, use sint64 instead.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="uint32" /> uint32</td><td>Uses variable-length encoding.</td><td>uint32</td><td>int</td><td>int/long</td><td>uint32</td><td>uint</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="uint64" /> uint64</td><td>Uses variable-length encoding.</td><td>uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>ulong</td><td>integer/string</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sint32" /> sint32</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sint64" /> sint64</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="fixed32" /> fixed32</td><td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td><td>uint32</td><td>int</td><td>int</td><td>uint32</td><td>uint</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="fixed64" /> fixed64</td><td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td><td>uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>ulong</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="sfixed32" /> sfixed32</td><td>Always four bytes.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sfixed64" /> sfixed64</td><td>Always eight bytes.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="bool" /> bool</td><td></td><td>bool</td><td>boolean</td><td>boolean</td><td>bool</td><td>bool</td><td>boolean</td><td>TrueClass/FalseClass</td></tr>
<tr><td><a name="string" /> string</td><td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td><td>string</td><td>String</td><td>str/unicode</td><td>string</td><td>string</td><td>string</td><td>String (UTF-8)</td></tr>
<tr><td><a name="bytes" /> bytes</td><td>May contain any arbitrary sequence of bytes.</td><td>string</td><td>ByteString</td><td>str</td><td>[]byte</td><td>ByteString</td><td>string</td><td>String (ASCII-8BIT)</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="design.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="design.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
