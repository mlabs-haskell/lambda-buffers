# _Compiler_ Spec & Design

The _Compiler_ component sits between the _Frontend_ component and the code
generation component named _Codegen_. The purpose of the _Compiler_ is to
typecheck terms generated by the Frontend (terms referred to as _Compiler Input_)
and perform other additional validation checks. The end goal of the _Compiler_
is to ensure that the _Codegen_ component is capable of processing the _Compiler
Output_.

## _Compiler_ interface

The _Compiler_ operates on the _Compiler Input proto_ - enabling, any _Frontend_
to interface with the _Compiler_ in a language agnostic manner.

Similarly, the _Compiler Output_ is also a _proto_ that is then consumed by
_Codegen_ modules, able to be written in any programming environment capable of
communicating via Google Protocol Buffers.

## Checking Type Definitions

The primary purpose of the compiler is to typecheck the schemata that users
define via the _Frontend_. The schemata terms are ADT declarations and their
types are kinds.

Currently the schema language _Compiler_ supports:

 1. type terms of kind `Type` (such as `Int` or `Bool`),

 2. and type function terms of kind `Type → Type` (such as `Maybe` or `Either`).

There are future plans to expand this to Higher Kinded Types (such as `MaybeT`,
`StateT` etc.) - subject to research into _Codegen_ of such types in the target
languages. The schema language and the _Compiler_ do support recursive
types.

Schemata terms must be monomorphically kinded, with polymorphic kinds defaulting
to monomorphic ones. For example `Phantom a = Phantom` would resolve to the
monomorphic kind `Type → Type` rather than the polymorphic kind `∀a. a → Type`.

## Checking Type Cardinality

In addition to typechecking, the compiler could perform a special check for
recursive types, namely: a check to see if a recursive type is inhabited. The
purpose of this check is to ensure that any schema which passes validation is
(in principle) a schema for which type definitions and typeclass "instances"
(which may be simple functions in languages without typeclass support) can be
generated. As an example, the compiler should be able to reject types such as
`data F a = F (F a)`, which is uninhabited. This is an additional feature that
we're currently reviewing.

## Normalising Type Definitions

Finally, the compiler should be able to _normalise_ expressions. For example, it
may be possible to define a data type in the schema language in a form similar
to: `data G a = G ((Either) ((Maybe) a) Int)`, where the bracketing indicates
the order of application within the term. The example term would normalise to
`data G a = G (Either (Maybe a) Int)` - resulting in a cleaner (and more
performant) code generation.

## Checking Typeclass Definitions and Instance Clauses

The _Compiler_ should, if possible, ensure that all instance declarations for
schemata are derivable using hard-coded derivation axioms. Because the checks
relevant to validating type class instances ough to be entirely separate from
the checks enumerated above, they can be worked on separately at a later date
when the design of the typeclass system has been fleshed out more.

## Unsolved Problems

- [ ] How do we represent recursive types in our lambda calculus AST?

- [ ] How would cardinality checking be integrated within our current checking
      strategy?
