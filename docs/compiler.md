# _Compiler_ Spec & Design

The _Compiler_ component sits between the _Frontend_ component and the code
generation component named _Codegen_. The purpose of the _Compiler_ is to
typecheck terms generated by the Frontend (terms referred to as _Compiler Input_)
and perform other additional validation checks. The end goal of the _Compiler_
is to ensure that the _Codegen_ component is capable of processing the _Compiler
Output_.

## _Compiler_ interface

The _Compiler_ operates on the _Compiler Input proto_ - enabling, any _Frontend_
to interface with the _Compiler_ in a language agnostic manner.

Similarly, the _Compiler Output_ is also a _proto_ that is then consumed by
_Codegen_ modules, able to be written in any programming environment capable of
communicating via Google Protocol Buffers.

## Checking type definitions

The primary purpose of the compiler is to typecheck the schemata that users
define via the _Frontend_. The schemata terms are ADT declarations and their
types are kinds.

Currently the schema language supports:

 1. types (such as `Int` or `Bool`),

 2. and type functions (such as `Maybe` or `Either`).

There are future plans to expand this to Higher Kinded Types (such as `MaybeT`,
`StateT` etc.) - subject to research into _Codegen_ of such types in the target
languages. The schema language and the _Compiler_ do support recursive
types.

Schemata terms must be monomorphically kinded, with polymorphic kinds defaulting
to monomorphic ones. For example `Phantom a = Phantom` would resolve to the
monomorphic kind `Type → Type` rather than the polymorphic kind `∀a. a → Type`.

<!-- cstml comments: Is this true? I think it's an Aim not a requirement?
:todo: -->

In addition to typechecking, the compiler must  perform a special check for
recursive types: It must validate that a recursive type is inhabited (or
inhabitable). The purpose of this check is to ensure that any schema which
passes validation is (in principle) a schema for which type definitions and
typeclass "instances" (which may be simple functions in languages without
typeclass support) can be generated. As an example, the compiler should reject
types such as `data F a = F (F a)`, which is uninhabited.

<!-- cstml comments: Is this true? Seems as though this should fail
parsing. :todo: -->

(Provisional:) Finally, the compiler should _normalize_ expressions as far as it
is able to. For example, it may be possible to define a data type in the schema
language in a form similar to: `data G a = G ((Either) ((Maybe) a) Int)`, where
the parentheses indicate application. Ideally, this would be normalized to `data
G a = G (Either (Maybe a) Int)` to result in cleaner (and more performant) code
generation.

## Checking type class definitions and instance clauses

The _Compiler_ should, if possible, ensure that all instance declarations for
schemata are derivable using hard-coded derivation axioms. Because the checks
relevant to validating type class instances ough to be entirely separate from
the checks enumerated above, they can be worked on separately at a later date
when the design of the typeclass system has been fleshed out more.

## Unsolved Problems

- [ ] How do we represent recursive types in our lambda calculus AST?
