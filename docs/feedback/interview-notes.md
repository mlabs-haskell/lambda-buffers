# Interview Notes

## Attendees

- Andrea Vezzosi
- Chase Maity
- Drazen Popovic (LB)
- George Flerovsky (LB)
- Ramiro Garay
- Vlad P. Luchian (LB)

## Agenda

1. Introduction - what is Lambda Buffers and what is Lambda Buffers' aim.
2. Interviews

## Meeting minutes

1. Drazen introduces what Lambda Buffers is, and how it relates to the target languages. Points touched on:
    1. Tooling
    2. Target languages
    3. Opaque types
    4. Type classes
2. Drazen opens the conversation up for the attendees and asks how LB can be used in their projects.
3. Ramiro is first to present - Singularity Net, Thrift Finance
    1. Ramiro mentions issues in project in which they work - mentions that even between Pursecript and Haskell there is an issue, even if they are very close.
    2. Ramiro mentions that Datum serialisation is an issue, and existing solutions are finicky.
    3. Drazen asks which part builts transactions - CTL Ramiro answers.
    4. Question arises about test written regarding serialisation - not implemented ATM.
    5. Question about parametrised validators - mostly dealt with by CTL.
        1. Configuration files are mentioned - get generated by Haskell and read by CTL? - incorrect - they are just serialised scripts that get applied
    6. Question about availability of generic front-end that presents the schema
        1. There is interest in this - and Ramiro considers it to be useful.
        2. Ideas mentioned:
            1. Observe link datum with a particular utxo
            2. Know that two utxos are linked by ref
    7. Question about any advice for the project.
        1. R. would like it to be seamless. R. mentions:
            1. Auto generate modules
            2. pre-commit hooks
            3. itterate quickly
            4. Nix integration is very important
            5. Not running commands.
            6. Watch function for the compiler.
        2. R. mentions that he would like to be able to build and run LB. without the use of NIX.
    8. Question about seeing the generated code or not?
        1. R. thinks yes - important. He would like to see the generated code and documentation.
    9. Question about what type of integration would there be with PlutArch - especially since Plutarch has exotic types.
        1. D. mentions that the some consessions will probably be made.
        2. D. mentions that these mappings can be done via Opaque Types.
4. Andrea is next interviewed next
    1. First question is: What is the technology that you've used in the past.
        1. A. hasn't used any language to work with type schemas - but has generated JSON Schemas
        2. A. explains the architecture of his current project:
            1. Servant + Swagger + JSON Schema Api
        3. At the moment some of the serialisation si done manually - which leads to errors because Rust and Haskell have different ways of serialising their JSON Schemas.
5. A. mentions that all the Plutus Data Encoding is done manually in rust in his project's case.
6. A. mentions that the Source of Truth is the Plutarch definition of these types. A. looks at how the encodings are done via examples.
    1. A. mentions that he would be happy to get rid of these constraints.
7. A. mentions that testing is lagging (potentially) because of the workflow ~ (inferred - not stated directly). A mention that debugging is - as it stands very difficult.
8. D. asks - what is the workflow A. would imagine having with LB.
    1. A. says the following in order of importance:
        1. Easily integrate into the existing build systems in target languages (Cabal, Cardo, etc.) - without using NIX would be ideal.
    2. A. agrees that an initially using Nix is acceptable
9. D. asks - what features A. would like to see:
    1. D. asks - must the JSON be observable
        1. A. mentions using Postman and the fact that transparency is important
    2. A. mentions - naming conventions are different between languages - how will LB deal with it?
        1. LB will generate idiomatic code for each target language.
10. Chase is interviewed next - he doesn't drink coffee.
11. Mention Chase has been implementing many PABs etc
12. C. mentions that most architectures he's worked with are similar to what Andrea has described above.
13. C. mentions that it is not possible to identify types across GHC versions - which is why Ply for example is flawed.
14. C. is questioning if LB is too high level or too low level - and what the intention of LB is.
    1. Mention about Kind indexing - i.e.Â the 'Sorted, 'Unsorted in P'arch land.
    2. D. mentions the use of different types. Questions how much of the logic happens in the
    3. A. mentions that some of the types he is using are maps, declared as sorted maps - he has the same expectation to happen from LB generated Plutarch code.
15. Numbers issue in JSON is mentioned.
16. Final question:
    1. What do you think about the project - what would make it succeed?
        1. Why not ProtoBufs?
            1. Impossible to add new opaques.
            2. Every defined type cannot be serialised in a managed way.
    2. Funding:
        1. Tied to adoption.
17. C. mentions that Lucid should be supported.
18. R. mentioned that potentially generating TypeScript might be more principled than JS.
