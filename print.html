<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lambda Buffers documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lambda Buffers documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lambda-buffers-introduction"><a class="header" href="#lambda-buffers-introduction">Lambda Buffers introduction</a></h1>
<p><img src="./images/lambda-buffers-banner.png" alt="LambdaBuffers banner" /></p>
<p><em>LambdaBuffers</em> is a schema language (similar to ProtoBuffers, ADL, ASN.1, JSON
Schema, etc.) and associated code generation toolkit. The goal of this project
is to provide developers tools to define algebraic data types in a
language-agnostic format such that shared data types can be declared in one
place while maintaining compatibility across a plethora of supported languages.</p>
<p>Users may refer to the <a href="./comparison-matrix.html">comparison matrix</a> for an
in-depth comparison of LambdaBuffers' features against the feature-set of other
popular schema-languages.</p>
<p>At a glance, you may wish to choose LambdaBuffers instead of one of its
competitors if your project requires:</p>
<ol>
<li>
<p><em>Parameterized Data Types</em> (aka. type functions): Unlike ProtoBuffers or
JSON Schema, LambdaBuffers allows users to define algebraic data types which
take type variable arguments. If your project's domain is most accurately
represented by parameterized data types, LambdaBuffers may be a good choice
for your needs.</p>
</li>
<li>
<p><em>Opaque Types</em>: Almost every competing schema language provides users a
fixed set of builtin or primitive types, which are handled in a special
manner by the code generation and cannot be extended. LambdaBuffers, by
contrast, allows users to add their own builtin types and extend the
existing code generation framework to handle those builtins in a manner
intended by the users. There are no <em>special</em> primitive types in
LambdaBuffers; a user-defined primitive type is defined in exactly the same
way (i.e. as an <code>opaque</code> type) as a LambdaBuffers "builtin".</p>
</li>
<li>
<p><em>Typeclass Support</em>: While nearly every schema language supports generating
type definitions in supported target languages, to our knowledge no schema
language supports generating commonly used functions that operate on those
types. Unlike other schema languages, LambdaBuffers supports code generation
for <em>typeclass instances</em> (or the equivalent in languages that lack support
for typeclasses) to reduce the amount of boilerplate required to
productively make use of the generated types. While LambdaBuffers is still a
work-in-progress, we expect that, upon completion, an extensive test suite
will provide a high degree of assurance that the instances/methods generated
by the LambdaBuffers code generator behave identically.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-lambdabuffers"><a class="header" href="#using-lambdabuffers">Using LambdaBuffers</a></h1>
<p>LambdaBuffers heavily relies on Nix to orchestrate code generation and dependency management.
If you don't have Nix installed with flakes enabled, please refer to the
<a href="getting-started.html">Getting Started</a> guide.</p>
<p>To set up a project with LambdaBuffers and multi-language stack, refer to our demo project at <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano">lambda-for-cardano</a>.</p>
<p>To see, how LambdaBuffers code is transpiled into other languages, see:</p>
<ul>
<li><a href="haskell.html">LambdaBuffers to Haskell</a></li>
<li><a href="plutustx.html">LambdaBuffers to PlutusTx</a></li>
<li><a href="purescript.html">LambdaBuffers to Purescript</a></li>
<li><a href="plutarch.html">LambdaBuffers to Plutarch</a></li>
<li><a href="rust.html">LambdaBuffers to Rust</a></li>
<li><a href="typescript.html">LambdaBuffers to Typescript</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-to-haskell"><a class="header" href="#lambdabuffers-to-haskell">LambdaBuffers to Haskell</a></h1>
<p>Let's take a look at how LambdaBuffers modules map into Haskell modules and how
LambdaBuffers type definitions map into Haskell type definitions.</p>
<p>We'll use the <code>lbf-prelude-to-haskell</code> CLI tool which is just a convenient wrapper over
the raw <code>lbf</code> CLI. We can get this tool by either loading the LambdaBuffers Nix
environment that comes packaged with all the CLI tools:</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf&lt;tab&gt;
lbf                        lbf-plutus-to-purescript   lbf-prelude-to-purescript
lbf-plutus-to-haskell      lbf-prelude-to-haskell
</code></pre>
<p>Or we can simply just refer directly to the <code>lbf-prelude-to-haskell</code> CLI by <code>nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-haskell</code>.</p>
<p>In this chapter, we're going to use the latter option.</p>
<p>Let's now use <code>lbf-prelude-to-haskell</code> to process the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/examples/Document.lbf">Document.lbf</a> schema.</p>
<pre><code class="language-purescript">module Document

-- Importing types
import Prelude (Text, List, Set, Bytes)

-- Author
sum Author = Ivan | Jovan | Savo

-- Reviewer
sum Reviewer = Bob | Alice

-- Document
record Document a = {
  author : Author,
  reviewers : Set Reviewer,
  content : Chapter a
 }

-- Chapter
record Chapter a = {
  content : a,
  subChapters : List (Chapter a)
 }

-- Some actual content
sum RichContent = Image Bytes | Gif Bytes | Text Text

-- Rich document
prod RichDocument = (Document RichContent)
</code></pre>
<pre><code class="language-shell">$ nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-haskell -- Document.lbf
$ find autogen/
autogen/
autogen/LambdaBuffers
autogen/LambdaBuffers/Document.hs
autogen/build.json
</code></pre>
<p>As we can see the <code>autogen</code> directory has been created that contains the generated Haskell modules.
Note the <code>autogen/build.json</code> file as it contains all the necessary Hackage dependencies the generated module needs in order to be properly compiled by GHC.</p>
<p>The outputted Haskell module in <code>autogen/LambdaBuffers/Document.hs</code>:</p>
<pre><code class="language-haskell">module LambdaBuffers.Document (Author(..)
                              , Chapter(..)
                              , Document(..)
                              , Reviewer(..)
                              , RichContent(..)
                              , RichDocument(..)) where

import qualified LambdaBuffers.Prelude
import qualified Prelude


data Author = Author'Ivan  | Author'Jovan  | Author'Savo  deriving Prelude.Show

data Chapter a = Chapter { chapter'content :: a
                         , chapter'subChapters :: LambdaBuffers.Prelude.List (Chapter a)} deriving Prelude.Show

data Document a = Document { document'author :: Author
                           , document'reviewers :: LambdaBuffers.Prelude.Set Reviewer
                           , document'content :: Chapter a} deriving Prelude.Show

data Reviewer = Reviewer'Bob  | Reviewer'Alice  deriving Prelude.Show

data RichContent = RichContent'Image LambdaBuffers.Prelude.Bytes
                    | RichContent'Gif LambdaBuffers.Prelude.Bytes
                    | RichContent'Text LambdaBuffers.Prelude.Text deriving Prelude.Show

newtype RichDocument = RichDocument (Document RichContent) deriving Prelude.Show
</code></pre>
<p>We can compile the code with the following commands.
Note the dev shell <code>dev-prelude-haskell</code> as it includes the <code>LambdaBuffers.Prelude</code> dependency.</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#dev-prelude-haskell
$ ghc autogen/LambdaBuffers/Document.hs
[1 of 1] Compiling LambdaBuffers.Document ( autogen/LambdaBuffers/Document.hs, autogen/LambdaBuffers/Document.o )
</code></pre>
<h2 id="sum-types"><a class="header" href="#sum-types">Sum types</a></h2>
<p>The types <code>Author</code>, <code>Reviewer</code>, and <code>RichContent</code> have been declared as sum types in the LambdaBuffers schema using the <code>sum</code> keyword.</p>
<p>As we can see, nothing too surprising here, all the <code>sum</code> types become <code>data</code>
in Haskell.</p>
<p>The only thing to notice is that the type name was prepended with <code>'</code> (single
quote) to the defined constructor names as to make sure they are unique.</p>
<h2 id="product-types"><a class="header" href="#product-types">Product types</a></h2>
<p>The type <code>RichDocument</code> have been declared as a product type in the
LambdaBuffers schema using the <code>prod</code> keyword.</p>
<p>They become Haskell <code>newtype</code> if they have a single type in their body, otherwise they are <code>data</code>.</p>
<p>Note that the constructor has the same name as the type.</p>
<h2 id="record-types"><a class="header" href="#record-types">Record types</a></h2>
<p>The types <code>Document</code> and <code>Chapter</code> have been declared as record types in the
LambdaBuffers schema using the <code>record</code> keyword.</p>
<p>Like with product types, they become Haskell <code>newtype</code> if they have a single
type in their body, otherwise they are <code>data</code>.</p>
<p>Also like with product types, the constructor has the same name as the type.</p>
<p>The field names, similar to sum constructor names, are prepended with the
lowercased name of the type with a single quote (<code>'</code>) to maintain uniqueness.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-to-plutustx"><a class="header" href="#lambdabuffers-to-plutustx">LambdaBuffers to PlutusTx</a></h1>
<p>Let's take a look at how LambdaBuffers modules map into PlutusTx modules, and how LambdaBuffers type definitions map into PlutusTx type definitions.</p>
<p>We'll use the <code>lbf-plutus-to-plutustx</code> CLI tool which is just a convenient wrapper over the raw <code>lbf</code> CLI. One can get this tool by either loading the LambdaBuffers Nix environment that comes packaged with all the CLI tools:</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf&lt;tab&gt;
lbf                          lbf-plutus-to-haskell        lbf-plutus-to-purescript     lbf-plutus-to-typescript     lbf-prelude-to-purescript    lbf-prelude-to-typescript
lbf-list-modules-typescript  lbf-plutus-to-plutustx       lbf-plutus-to-rust           lbf-prelude-to-haskell       lbf-prelude-to-rust
</code></pre>
<p>Alternatively, one can simply refer directly to the <code>lbf-plutus-to-plutustx</code> CLI by executing <code>nix run github:mlabs-haskell/lambda-buffers#lbf-plutus-to-plutustx</code>; or for a more interactive experience, one can enter the development shell <code>nix develop github:mlabs-haskell/lambda-buffers#dev-plutus-haskell</code> which includes the <code>lbf-plutus-to-plutustx</code> executable along with a version of GHC with the required package set to compile the autogenerated PlutusTx projects.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h2>
<p>Owing to the fact that PlutusTx is a GHC plug-in, the mapping from LambdaBuffers modules to PlutusTx modules closely mirrors the LambdaBuffers to Haskell mapping described in the <a href="./haskell.html">Haskell chapter</a>.
The key points are as follows.</p>
<ul>
<li>
<p>LambdaBuffers' data types (sums, products, and records) are mapped similarly to the Haskell backend.</p>
</li>
<li>
<p>The LambdaBuffers' <code>Prelude.Eq</code> instances are mapped to <code>PlutusTx.Eq.Eq</code> instances.</p>
</li>
<li>
<p>The LambdaBuffers' <code>Plutus.V1.PlutusData</code> instances are mapped to a <code>PlutusTx.ToData</code> instance and a <code>PlutusTx.FromData</code> instance.</p>
</li>
<li>
<p>The opaque types in LambdaBuffers' Prelude are often mapped to the corresponding <code>PlutusTx</code> Prelude type e.g. LambdaBuffers' Prelude's opaque <code>Prelude.Map</code> type is mapped to <code>PlutusTx.AssocMap</code>. The full mapping can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-codegen/data/plutustx-prelude.json">here</a></p>
</li>
<li>
<p>The opaque types in LambdaBuffers' <code>Plutus.V1</code>, <code>Plutus.V2</code> and <code>Plutus.V3</code> modules are mapped to the obvious corresponding Plutus Ledger API types. The full mapping can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-codegen/data/plutustx-plutus.json">here</a>.</p>
</li>
<li>
<p>A LambdaBuffers module, say <code>&lt;lb-module&gt;</code>, is translated to the PlutusTx module <code>LambdaBuffers.&lt;lb-module&gt;.PlutusTx</code></p>
</li>
</ul>
<h2 id="example-code-generation"><a class="header" href="#example-code-generation">Example code generation</a></h2>
<p>In the following example, we'll enter a development shell with the <code>lbf-plutus-to-plutustx</code> executable, create an example LambdaBuffers schema file, use the PlutusTx backend to compile it, inspect the generated code and files, and compile the autogenerated code with GHCi.</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#dev-plutus-haskell
$ cat &gt; Example.lbf
module Example

import Prelude
import Plutus.V1 (PlutusData, AssetClass)

record Example a = {
  foo : AssetClass,
  bar : a
  }

derive Eq (Example a)
derive PlutusData (Example a)

$ lbf-plutus-to-plutustx Example.lbf
Success from: /nix/store/dcwir06wiq7pd3g8dfljhfxscm8yss94-lambda-buffers-compiler-exe-lbc-0.1.0.0/bin/lbc compile --input-file .work/compiler-input.pb --output-file .work/compiler-output.pb [INFO]
Compilation OK [INFO]
Success from: /nix/store/sqqsg2jx871saxfxj2mly5g4pd6qsb64-lbg-plutustx/bin/lbg-plutustx --input .work/codegen-input.pb --output .work/codegen-output.pb --gen-dir autogen --gen-class Prelude.Eq --gen-class Plutus.V1.PlutusData '--config=/nix/store/x5f8a22dwx008wlv24xf8a6mdm65flil-codegen-configs/plutustx-prelude.json' '--config=/nix/store/x5f8a22dwx008wlv24xf8a6mdm65flil-codegen-configs/plutustx-plutus.json' Example [INFO]
Codegen OK [INFO]

$ find autogen
autogen/
autogen/LambdaBuffers
autogen/LambdaBuffers/Example
autogen/LambdaBuffers/Example/PlutusTx.hs
autogen/build.json

$ cat autogen/LambdaBuffers/Example/PlutusTx.hs

{-# LANGUAGE NoImplicitPrelude,NoPolyKinds #-}
{-# OPTIONS_GHC -fno-ignore-interface-pragmas -fno-omit-interface-pragmas -fno-specialise -fno-strictness -fobject-code #-}
module LambdaBuffers.Example.PlutusTx (Example(..)) where

import qualified LambdaBuffers.Plutus.V1.PlutusTx
import qualified LambdaBuffers.Prelude.PlutusTx
import qualified LambdaBuffers.Runtime.PlutusTx.LamVal
import qualified PlutusTx
import qualified PlutusTx.Bool
import qualified PlutusTx.Builtins
import qualified PlutusTx.Eq
import qualified PlutusTx.Maybe
import qualified PlutusTx.Prelude
import qualified Prelude


data Example a = Example { example'foo :: LambdaBuffers.Plutus.V1.PlutusTx.AssetClass
                         , example'bar :: a} deriving Prelude.Show


instance (PlutusTx.Eq.Eq a) =&gt; PlutusTx.Eq.Eq (Example a) where
  {-# INLINABLE (==) #-}
  (==) = (\x0 -&gt; (\x1 -&gt; (PlutusTx.Bool.&amp;&amp;) ((PlutusTx.Eq.==) (example'foo x0) (example'foo x1)) ((PlutusTx.Eq.==) (example'bar x0) (example'bar x1)) ) )

instance (PlutusTx.ToData a) =&gt; PlutusTx.ToData (Example a) where
  {-# INLINABLE toBuiltinData #-}
  toBuiltinData = (\x0 -&gt; PlutusTx.Builtins.mkList ([PlutusTx.toBuiltinData (example'foo x0)
                                                     , PlutusTx.toBuiltinData (example'bar x0)]) )

instance (PlutusTx.FromData a) =&gt; PlutusTx.FromData (Example a) where
  {-# INLINABLE fromBuiltinData #-}
  fromBuiltinData = (\x0 -&gt; LambdaBuffers.Runtime.PlutusTx.LamVal.casePlutusData ((\x1 -&gt; (\x2 -&gt; PlutusTx.Maybe.Nothing ) )) ((\x3 -&gt; case x3 of
                                                                                                                                         [x4
                                                                                                                                          , x5] -&gt; (PlutusTx.Prelude.&gt;&gt;=) (PlutusTx.fromBuiltinData (x4)) ((\x6 -&gt; (PlutusTx.Prelude.&gt;&gt;=) (PlutusTx.fromBuiltinData (x5)) ((\x7 -&gt; PlutusTx.Maybe.Just (Example { example'foo = x6
                                                                                                                                                                                                                                                                                                                , example'bar = x7 }) )) ))
                                                                                                                                         x8 -&gt; PlutusTx.Maybe.Nothing )) ((\x9 -&gt; PlutusTx.Maybe.Nothing )) ((\x10 -&gt; PlutusTx.Maybe.Nothing )) (x0) )[10:19 PM] [jared@pletbjerg ~/Documents/Work/lambda-buffers]$

$ ghci autogen/LambdaBuffers/Example/PlutusTx.hs
...
</code></pre>
<h2 id="example-project"><a class="header" href="#example-project">Example project</a></h2>
<p>A complete example project using the generated PlutusTx modules can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutustx">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-to-purescript"><a class="header" href="#lambdabuffers-to-purescript">LambdaBuffers to Purescript</a></h1>
<p>Let's take a look at how LambdaBuffers modules map into Purescript modules and how
LambdaBuffers type definitions map into Purescript type definitions.</p>
<p>We'll use the <code>lbf-prelude-to-purescript</code> CLI tool which is just a convenient wrapper over
the raw <code>lbf</code> CLI. We can get this tool by either loading the LambdaBuffers Nix
environment that comes packaged with all the CLI tools:</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf&lt;tab&gt;
lbf                        lbf-plutus-to-purescript   lbf-prelude-to-purescript
lbf-plutus-to-haskell      lbf-prelude-to-haskell
</code></pre>
<p>Or we can simply just refer directly to the <code>lbf-prelude-to-purescript</code> CLI by <code>nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-purescript</code>.</p>
<p>In this chapter, we're going to use the latter option.</p>
<p>Let's now use <code>lbf-prelude-to-purescript</code> to process the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/examples/Document.lbf">Document.lbf</a> schema</p>
<pre><code class="language-purescript">module Document

-- Importing types
import Prelude (Text, List, Set, Bytes)

-- Author
sum Author = Ivan | Jovan | Savo

-- Reviewer
sum Reviewer = Bob | Alice

-- Document
record Document a = {
  author : Author,
  reviewers : Set Reviewer,
  content : Chapter a
 }

-- Chapter
record Chapter a = {
  content : a,
  subChapters : List (Chapter a)
 }

-- Some actual content
sum RichContent = Image Bytes | Gif Bytes | Text Text

-- Rich document
prod RichDocument = (Document RichContent)
</code></pre>
<pre><code class="language-shell">$ nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-purescript -- Document.lbf
$ find autogen/
autogen/
autogen/build.json
autogen/LambdaBuffers
autogen/LambdaBuffers/Document.purs
</code></pre>
<p>As we can see the <code>autogen</code> directory has been created that contains the generated Purescript modules.
Note the <code>autogen/build.json</code> file as it contains all the necessary dependencies the generated module needs in order to be properly compiled by <code>purs</code> compiler.</p>
<p>The outputted Purescript module in <code>autogen/LambdaBuffers/Document.hs</code>:</p>
<pre><code class="language-purescript">module LambdaBuffers.Document (Author(..)
                              , Chapter(..)
                              , Document(..)
                              , Reviewer(..)
                              , RichContent(..)
                              , RichDocument(..)) where

import LambdaBuffers.Prelude as LambdaBuffers.Prelude
import Data.Generic.Rep as Data.Generic.Rep
import Data.Newtype as Data.Newtype
import Data.Show as Data.Show
import Data.Show.Generic as Data.Show.Generic


data Author = Author'Ivan  | Author'Jovan  | Author'Savo 
derive instance Data.Generic.Rep.Generic Author _
instance Data.Show.Show Author where
  show = Data.Show.Generic.genericShow

newtype Chapter a = Chapter { content :: a
                            , subChapters :: LambdaBuffers.Prelude.List (Chapter a)}
derive instance Data.Newtype.Newtype (Chapter a) _
derive instance Data.Generic.Rep.Generic (Chapter a) _
instance (Data.Show.Show a) =&gt; Data.Show.Show (Chapter a) where
  show = Data.Show.Generic.genericShow

newtype Document a = Document { author :: Author
                              , reviewers :: LambdaBuffers.Prelude.Set Reviewer
                              , content :: Chapter a}
derive instance Data.Newtype.Newtype (Document a) _
derive instance Data.Generic.Rep.Generic (Document a) _
instance (Data.Show.Show a) =&gt; Data.Show.Show (Document a) where
  show = Data.Show.Generic.genericShow

data Reviewer = Reviewer'Bob  | Reviewer'Alice 
derive instance Data.Generic.Rep.Generic Reviewer _
instance Data.Show.Show Reviewer where
  show = Data.Show.Generic.genericShow

data RichContent = RichContent'Image LambdaBuffers.Prelude.Bytes
                    | RichContent'Gif LambdaBuffers.Prelude.Bytes
                    | RichContent'Text LambdaBuffers.Prelude.Text
derive instance Data.Generic.Rep.Generic RichContent _
instance Data.Show.Show RichContent where
  show = Data.Show.Generic.genericShow

newtype RichDocument = RichDocument (Document RichContent)
derive instance Data.Newtype.Newtype RichDocument _
derive instance Data.Generic.Rep.Generic RichDocument _
instance Data.Show.Show RichDocument where
  show = Data.Show.Generic.genericShow
</code></pre>
<h2 id="sum-types-1"><a class="header" href="#sum-types-1">Sum types</a></h2>
<p>The types <code>Author</code>, <code>Reviewer</code>, and <code>RichContent</code> have been declared as sum types in the LambdaBuffers schema using the <code>sum</code> keyword.</p>
<p>As we can see, nothing too surprising here, all the <code>sum</code> types become <code>data</code>
in Purescript.</p>
<p>The only thing to notice is that the type name was prepended with <code>'</code> (single
quote) to the defined constructor names as to make sure they are unique.</p>
<h2 id="product-types-1"><a class="header" href="#product-types-1">Product types</a></h2>
<p>The type <code>RichDocument</code> have been declared as a product type in the
LambdaBuffers schema using the <code>prod</code> keyword.</p>
<p>They become Purescript <code>newtype</code> if they have a single type in their body, otherwise they are <code>data</code>.</p>
<p>Note that the constructor has the same name as the type.</p>
<h2 id="record-types-1"><a class="header" href="#record-types-1">Record types</a></h2>
<p>The types <code>Document</code> and <code>Chapter</code> have been declared as record types in the
LambdaBuffers schema using the <code>record</code> keyword.</p>
<p>They always become Purescript <code>newtype</code>, and wrapped within is a Purescript
record type with the fields named exactly like they are named in the
LambdaBuffers source module.</p>
<p>Also like with product types, the constructor has the same name as the type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-for-plutarch"><a class="header" href="#lambdabuffers-for-plutarch">LambdaBuffers for Plutarch</a></h1>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus">Plutarch</a> is a typed eDSL in Haskell for writing efficient Plutus Core validators.</p>
<p>LambdaBuffers creates Plutarch type definitions and associated Plutarch type class implementations for <a href="plutarch.html#plutustype">PlutusType</a>, <a href="plutarch.html#pisdata">PIsData</a> and <a href="plutarch.html#pshow">PShow</a> classes.</p>
<p>Additionally, when instructed by a LambdaBuffers <code>derive</code> statement type class implementations for <a href="plutarch.html#peq">PEq</a> and <a href="plutarch.html#ptryfrom">PTryFrom</a> are also printed.</p>
<p>A small example:</p>
<pre><code class="language-shell">❯ nix develop github:mlabs-haskell/lambda-buffers#dev-plutarch
❯ cat &gt; Example.lbf
module Example

import Prelude
import Plutus.V1 (PlutusData, AssetClass)

record Example a = {
  foo : AssetClass,
  bar : a
  }

derive Eq (Example a)
derive Json (Example a)
derive PlutusData (Example a)

❯ lbf-plutus-to-plutarch Example.lbf
[lbf][INFO] Compilation OK
[lbf][INFO] Codegen OK

❯ find autogen/
autogen/
autogen/build.json
autogen/LambdaBuffers
autogen/LambdaBuffers/Example
autogen/LambdaBuffers/Example/Plutarch.hs
</code></pre>
<p>For a full example see <a href="plutarch.html#example">Example</a>.</p>
<h2 id="lambdabuffers-modules"><a class="header" href="#lambdabuffers-modules">LambdaBuffers modules</a></h2>
<p>Writing .lbf schemas with API types intended for Plutarch backend will typically use the following LambdaBuffers schema modules:</p>
<ol>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude/Prelude.lbf">Prelude</a>,</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V1.lbf">Plutus.V1</a>,</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V2.lbf">Plutus.V2</a>.</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V3.lbf">Plutus.V3</a>.</li>
</ol>
<p>Take a look at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/api/Example.lbf">Example.lbf</a> schema as an example.</p>
<h2 id="haskell-libraries"><a class="header" href="#haskell-libraries">Haskell libraries</a></h2>
<p>The necessary LambdaBuffers runtime libraries a typical Plutarch project needs when working with LambdaBuffers:</p>
<ol>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/runtimes/haskell/lbr-plutarch">lbr-plutarch</a> a Haskell runtime library necessary for working with <code>lbf-xyz</code> libraries.</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude">lbf-prelude-plutarch</a> that contains the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude">LambdaBuffers Prelude</a> schema library generated by LambdaBuffers.</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">lbf-plutus-plutarch</a> that contains the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">LambdaBuffers Plutus</a> schema library generated by LambdaBuffers.</li>
</ol>
<p>Of course, additional imports for Plutarch libraries are also necessary <a href="https://github.com/Plutonomicon/plutarch-plutus">plutarch</a> and optionally <a href="https://github.com/Plutonomicon/plutarch-plutus/tree/master/plutarch-extra">plutarch-extra</a>.</p>
<p>For a full example see <a href="plutarch.html#example">Example</a>.</p>
<h3 id="inspecting-the-generated-output"><a class="header" href="#inspecting-the-generated-output">Inspecting the generated output</a></h3>
<p>You can inspect the generated libraries using Nix:</p>
<pre><code class="language-shell">❯ nix build .#lbf-prelude-plutarch
❯ find result/autogen/
result/autogen/
result/autogen/LambdaBuffers
result/autogen/LambdaBuffers/Prelude
result/autogen/LambdaBuffers/Prelude/Plutarch.hs

❯ nix build .#lbf-plutus-plutarch
❯ find result/autogen/
result/autogen/
result/autogen/LambdaBuffers
result/autogen/LambdaBuffers/Plutus
result/autogen/LambdaBuffers/Plutus/V3
result/autogen/LambdaBuffers/Plutus/V3/Plutarch.hs
result/autogen/LambdaBuffers/Plutus/V2
result/autogen/LambdaBuffers/Plutus/V2/Plutarch.hs
result/autogen/LambdaBuffers/Plutus/V1
result/autogen/LambdaBuffers/Plutus/V1/Plutarch.hs
</code></pre>
<h2 id="haskell-modules"><a class="header" href="#haskell-modules">Haskell modules</a></h2>
<p>The set of imports a Plutarch program using LambdaBuffers would typically need is the following:</p>
<pre><code class="language-haskell">import LambdaBuffers.Plutus.V1.Plutarch ()
import LambdaBuffers.Plutus.V2.Plutarch ()
import LambdaBuffers.Plutus.V3.Plutarch ()
import LambdaBuffers.Prelude.Plutarch ()
import LambdaBuffers.Runtime.Plutarch ()
import Plutarch.Prelude ()
import Plutarch.LedgerApi.V1 ()
import Plutarch.LedgerApi.V2 ()
import Plutarch.LedgerApi.V3 ()
</code></pre>
<ol>
<li>LambdaBuffers.Plutus.V1.Plutarch is a module generated from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V1.lbf">Plutus.V1</a> LambdaBuffers schema and provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">lbf-plutus-plutarch</a> runtime library.</li>
<li>LambdaBuffers.Plutus.V2.Plutarch is a module generated from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V2.lbf">Plutus.V2</a> LambdaBuffers schema and provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">lbf-plutus-plutarch</a> runtime library.</li>
<li>LambdaBuffers.Plutus.V3.Plutarch is a module generated from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V2.lbf">Plutus.V3</a> LambdaBuffers schema and provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">lbf-plutus-plutarch</a> runtime library.</li>
<li>LambdaBuffers.Prelude.Plutarch is a module generated from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude/Prelude.lbf">Prelude</a> LambdaBuffers schema and provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude">lbf-prelude-plutarch</a> runtime library.</li>
<li>LambdaBuffers.Runtime.Plutarch is a module provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/runtimes/haskell/lbr-plutarch">lbr-plutarch</a> runtime library.</li>
</ol>
<blockquote>
<p>Generated Plutarch module for a LambdaBuffers schema <code>Foo/Bar.lbf</code> (ie. <code>Foo.Bar</code>) is stored at <code>Foo/Bar/Plutarch.hs</code></p>
</blockquote>
<h2 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h2>
<p>Plutarch backend doesn't support recursive type definitions unfortunately (see #131).</p>
<p>The following will not work:</p>
<pre><code class="language-lbf">module ModuleWithRecursiveType

import Prelude (Eq)
import Plutus.V1 (PlutusData)

sum List a = Cons a (List a) | Nil
derive Eq (List a)
derive PlutusData (List a)
</code></pre>
<p>Additionally, LambdaBuffers record types are mapped to Plutarch product types:</p>
<pre><code class="language-lbf">module ModuleWithARecordType

import Prelude (Eq, Integer, Bool)
import Plutus.V1 (PlutusData)

record Foo = {
  bar: Integer,
  baz: Bool
  }
derive Eq Foo
derive PlutusData Foo
</code></pre>
<p>Essentially, the record definitions are 'degraded' into product types such that the order of product fields is the order of record fields as they are defined at source.</p>
<p>For example the <code>Foo</code> record defined above would have no difference in Plutarch if it was defined as product <code>Foo</code> below:</p>
<pre><code class="language-lbf">prod Foo = Integer Bool
</code></pre>
<p>The Plutarch backend doesn't support the use of <code>Char</code>, <code>Text</code>, <code>Bytes</code> (there's a Plutus.V1.Bytes), <code>Set</code> and <code>Map</code> (there's a Plutus.V1.Map) from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude/Prelude.lbf">LambdaBuffers Prelude</a> module.</p>
<h2 id="plutarch"><a class="header" href="#plutarch">Plutarch</a></h2>
<h3 id="type-definition-mapping"><a class="header" href="#type-definition-mapping">Type definition mapping</a></h3>
<p>Plutarch backend supports all types from the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">LambdaBuffers Plutus</a> schema library, as to enable full featured Plutus script development.</p>
<p>Additionally, it also supports some types from the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude">LambdaBuffers Prelude</a> schema library, namely <code>Bool</code>, <code>Integer</code>, <code>Maybe</code>, <code>Either</code> and <code>List</code>.</p>
<pre><code class="language-lbf">module Foo

sum Sum = Some a | Nothing

record Record a = {
  foo : Bytes,
  bar: a
}

prod Product a = Bytes a
</code></pre>
<p>translates into Plutarch equivalent:</p>
<pre><code class="language-haskell">module LambdaBuffers.Foo.Plutarch (Sum(..), Record(..), Product(..)) where

import qualified LambdaBuffers.Plutus.V1.Plutarch
import qualified LambdaBuffers.Prelude.Plutarch
import qualified LambdaBuffers.Runtime.Plutarch
import qualified Plutarch.Prelude
import qualified Plutarch.Internal.PlutusType
import qualified Plutarch.Unsafe

data Sum (a :: PType) (s :: Plutarch.Prelude.S) = Sum'Some (Plutarch.Prelude.Term s (Plutarch.Prelude.PAsData LambdaBuffers.Plutus.V1.Plutarch.Bytes)) (Plutarch.Term s (Plutarch.Prelude.PAsData PAsData))
                                  | Sum'Nothing
  deriving stock GHC.Generics.Generic
  deriving anyclass Plutarch.Prelude.PShow

data Record (a :: PType) (s :: Plutarch.Prelude.S) = Record (Plutarch.Prelude.Term s (Plutarch.Prelude.PAsData LambdaBuffers.Plutus.V1.Plutarch.Bytes)) (Plutarch.Term s (Plutarch.Prelude.PAsData PAsData))
  deriving stock GHC.Generics.Generic
  deriving anyclass Plutarch.Prelude.PShow

data Product (a :: PType) (s :: Plutarch.Prelude.S) = Product (Plutarch.Prelude.Term s (Plutarch.Prelude.PAsData LambdaBuffers.Plutus.V1.Plutarch.Bytes)) (Plutarch.Term s (Plutarch.Prelude.PAsData PAsData))
  deriving stock GHC.Generics.Generic
  deriving anyclass Plutarch.Prelude.PShow
</code></pre>
<h3 id="type-class-implementations"><a class="header" href="#type-class-implementations">Type class implementations</a></h3>
<p>Plutarch has a couple of fundamental type classes essential to its operations namely, <code>PlutusType</code>, <code>PIsData</code>, <code>PTryFrom</code> and <code>PEq</code>.</p>
<h4 id="plutustype"><a class="header" href="#plutustype">PlutusType</a></h4>
<p>Printing an implementation for this class for a particular type is governed by <code>derive Plutus.V1.PlutusData &lt;type&gt;</code> statements in .lbf schemas.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/Internal/PlutusType.hs#L56">PlutusType</a> serves to (de)construct Plutarch eDSL terms from Haskell 'native' terms.</p>
<pre><code class="language-haskell">class PlutusType (a :: PType) where
  type PInner a :: PType
  pcon' :: forall s. a s -&gt; Term s (PInner a)
  pmatch' :: forall s b. Term s (PInner a) -&gt; (a s -&gt; Term s b) -&gt; Term s b
</code></pre>
<p>Additionally, Plutarch enables specifying terms to have different 'value' representation, like Scott encoded terms or PlutusData encoded terms.
This is what the <code>PInner</code> type family is used to specify.
LambdaBuffers only cares about <code>PlutusData</code> encoded terms since we're using it to specify Plutus datum structures.</p>
<p>The task is to generate a <code>pcon'</code> implementation such that we can construct Plutarch <code>Term</code>s that have some <code>PInner</code> representation of type <code>PData</code>, from Haskell 'native' values.
The <code>pcon'</code> implementation must match the LB Plutus PlutusData encoding class standard, and so we'll use the same 'to Plutus data' specification to generate <code>pcon'</code> implementations.</p>
<p>Constructing is always only one part of the story, there's also deconstruction that is captured by the <code>pmatch'</code> method.
This method serves to 'pattern match' on a value that was already constructed using <code>pcon'</code> and dispatch said value to a provided continuation function.
It's important to note that there's a subtle but important distinction to be made between the <code>ptryFrom</code> and <code>pmatch'</code> methods.
<code>pmatch'</code> assumes that the value it receives is indeed correct, as it was constructed using the <code>pcon'</code> method.
This means that <code>pmatch'</code> should never error, and if it does that means the implementation is wrong.
<code>ptryFrom</code> is different, as it takes some <code>PData</code> and tries to parse it into a <code>PType</code>, but can fail.</p>
<p>However, in LambdaBuffers, both of these methods follow the exact same logical pattern, and they correspond and can be generated using the <code>from Plutus data</code> specification.</p>
<h4 id="ptryfrom"><a class="header" href="#ptryfrom">PTryFrom</a></h4>
<p>Printing an implementation for this class for a particular type is governed by <code>derive Plutus.V1.PlutusData &lt;type&gt;</code> statements in .lbf schemas.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/TryFrom.hs#L73">PTryFrom</a> serves specify how <code>PData</code> is 'parsed' into a Plutarch type.
N
It's generally used to convert between Plutarch types, but that's a fairly general use case, and we generally use this class in a very narrow form to specify how <code>PData</code> is 'parsed' into a Plutarch type.</p>
<pre><code class="language-haskell">class PSubtype a b =&gt; PTryFrom (a :: PType) (b :: PType) where
  type PTryFromExcess a b :: PType
  type PTryFromExcess a b = PTryFromExcess a (PInner b)
  ptryFrom' :: forall s r. Term s a -&gt; ((Term s b, Reduce (PTryFromExcess a b s)) -&gt; Term s r) -&gt; Term s r
  default ptryFrom' :: forall s r. (PTryFrom a (PInner b), PTryFromExcess a b ~ PTryFromExcess a (PInner b)) =&gt; Term s a -&gt; ((Term s b, Reduce (PTryFromExcess a b s)) -&gt; Term s r) -&gt; Term s r
  ptryFrom' opq f = ptryFrom @(PInner b) @a opq \(inn, exc) -&gt; f (punsafeCoerce inn, exc)
</code></pre>
<p>There's some additionally features exhibited by this type class, most noteworthy is the <code>PTryFromExcess</code> type family that enables us specify the part of the structure that wasn't parsed and is left unexamined.
It's a form of optimization that becomes very important if you have a very complex data type such as <code>ScriptContext</code> from the <code>plutus-ledger-api</code>.</p>
<p>Apparently, a good intuition pump for this 'excess' business is that of a <a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">zipper</a>.
We focus on a certain part of a data structure, only ever providing links to other parts that are left un-examined.</p>
<p>LambdaBuffers doesn't use this feature and sets the <code>PTryFromExcess</code> to a unit type, signaling that nothing is left unexamined.</p>
<h4 id="pisdata"><a class="header" href="#pisdata">PIsData</a></h4>
<p>Printing an implementation for this class for a particular type is governed by <code>derive Plutus.V1.PlutusData &lt;type&gt;</code> statements in .lbf schemas.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/Builtin.hs#L354">PIsData</a> serves to track 'is it Plutus data encoded?' with types.</p>
<pre><code class="language-haskell">newtype PAsData (a :: PType) (s :: S) = PAsData (Term s a)

class PIsData a where
  pfromDataImpl :: Term s (PAsData a) -&gt; Term s a
  default pfromDataImpl :: PIsData (PInner a) =&gt; Term s (PAsData a) -&gt; Term s a
  pfromDataImpl x = punsafeDowncast $ pfromDataImpl (punsafeCoerce x :: Term _ (PAsData (PInner a)))

  pdataImpl :: Term s a -&gt; Term s PData
  default pdataImpl :: PIsData (PInner a) =&gt; Term s a -&gt; Term s PData
  pdataImpl x = pdataImpl $ pto x
</code></pre>
<pre><code class="language-haskell">instance PIsData FooTrivial where
  pdataImpl = punsafeCoerce
  pfromDataImpl = punsafeCoerce

instance PEq FooTrivial where
  (#==) = \l r -&gt; pdata l #== pdata r
</code></pre>
<blockquote>
<p>Due to generated types having a <code>PAsData</code> attached to them, be ready to use <code>pdata</code> and <code>pfromData</code> to switch between forms.</p>
</blockquote>
<h4 id="peq"><a class="header" href="#peq">PEq</a></h4>
<p>Printing an implementation for this class for a particular type is governed by <code>derive Prelude.Eq &lt;type&gt;</code> statements in .lbf schemas.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/Bool.hs#L74">PEq</a> serves to track provide equality checks to Plutarch types.</p>
<pre><code class="language-haskell">class PEq t where
  (#==) :: Term s t -&gt; Term s t -&gt; Term s PBool
  default (#==) ::
    (PGeneric t, PlutusType t, All2 PEq (PCode t)) =&gt;
    Term s t -&gt;
    Term s t -&gt;
    Term s PBool
  a #== b = gpeq # a # b

infix 4 #==
</code></pre>
<blockquote>
<p>We don't generate an implementation from the LambdaBuffers 'equality spec', rather we delegate the equality check to the underlying 'PData' representations that all generated types have for performance.</p>
</blockquote>
<h4 id="pshow"><a class="header" href="#pshow">PShow</a></h4>
<p>All generated types have a PShow instance derived using the internal Plutarch deriving mechanism.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/Show.hs#L52">PShow</a> serves to stringify Plutarch types which is very useful during debugging.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let work through the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch">Plutarch example</a> available in the repo.</p>
<p>First, please check the <a href="getting-started.html">Getting started</a> guide on how to prepare to work with the repo and setup Nix.</p>
<p>Let's see what we have here:</p>
<pre><code class="language-shell">lambda-buffers/docs/plutarch ❯ find
.
./build.nix
./cabal.project
./hie.yaml
./plutarch-example.cabal
./app
./app/Example.hs
./api
./api/Example.lbf
./.envrc
</code></pre>
<p>The salient bits we should focus on are:</p>
<ol>
<li>The LambdaBuffers .lbf schema in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/api/Example.lbf">./api/Example.lbf</a> that describes the API types used by our little program,</li>
<li>The Haskell Plutarch program in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/app/Example.hs">./app/Example.hs</a> that works with the API types.</li>
</ol>
<p>To inspect the generated library:</p>
<pre><code class="language-shell">lambda-buffers/docs/plutarch ❯ nix build .#lbf-plutarch-example-api
lambda-buffers/docs/plutarch ❯ find autogen/
autogen/
autogen/build.json
autogen/LambdaBuffers
autogen/LambdaBuffers/Example
autogen/LambdaBuffers/Example/Plutarch.hs
</code></pre>
<blockquote>
<p>The name of the generated library <code>lbf-plutarch-example-api</code> is set in the ./plutarch/build.nix Nix build file.</p>
</blockquote>
<p>However, it's not expected for users to need to do this. If you have any issue please reach out.</p>
<p>Inspecting the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/plutarch-example.cabal">Cabal file</a> shows the standard runtime libraries we need:</p>
<pre><code class="language-shell">lambda-buffers/docs/plutarch ❯ cabal info .
* plutarch-example-0.1.0.0 (program)
    Synopsis:      LambdaBuffers Plutarch example
    Versions available: [ Not available from server ]
    Versions installed: [ Unknown ]
    Homepage:      [ Not specified ]
    Bug reports:   [ Not specified ]
    License:       NONE
    Author:        Drazen Popovic
    Maintainer:    bladyjoker@gmail.com
    Source repo:   [ Not specified ]
    Executables:   plutarch-example
    Flags:         dev
    Dependencies:  base &gt;=4.16, lbf-plutarch-example-api, lbf-plutus-plutarch,
                   lbf-prelude-plutarch, lbr-plutarch, plutarch, plutarch-ledger-api,
                   text &gt;=1.2
    Cached:        Yes
</code></pre>
<p>Run the program:</p>
<pre><code class="language-shell">lambda-buffers/docs/plutarch ❯ cabal run
"Friends, peace and love!!!"
</code></pre>
<p>Take a look at the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/app/Example.hs">Example.hs</a> to see how generated types are used, namely how they are constructed with <code>pcon</code> and deconstructed with <code>pmatch</code> (or <code>pmatchC</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-to-rust"><a class="header" href="#lambdabuffers-to-rust">LambdaBuffers to Rust</a></h1>
<p>Let's take a look at how LambdaBuffers modules map into Rust modules and how
LambdaBuffers type definitions map into Rust type definitions.</p>
<p>We'll use the <code>lbf-prelude-to-rust</code> CLI tool which is just a convenient wrapper over
the raw <code>lbf</code> CLI. We can get this tool by either loading the LambdaBuffers Nix
environment that comes packaged with all the CLI tools:</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf&lt;tab&gt;
lbf                        lbf-plutus-to-purescript   lbf-prelude-to-haskell     lbf-prelude-to-rust
lbf-plutus-to-haskell      lbf-plutus-to-rust         lbf-prelude-to-purescript  
</code></pre>
<p>Or we can simply just refer directly to the <code>lbf-prelude-to-rust</code> CLI by <code>nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-rust</code>.</p>
<p>In this chapter, we're going to use the latter option.</p>
<p>Let's now use <code>lbf-prelude-to-rust</code> to process the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/examples/Document.lbf">Document.lbf</a> schema.</p>
<pre><code class="language-purescript">module Document

-- Importing types
import Prelude (Text, List, Set, Bytes)

-- Author
sum Author = Ivan | Jovan | Savo

-- Reviewer
sum Reviewer = Bob | Alice

-- Document
record Document a = {
  author : Author,
  reviewers : Set Reviewer,
  content : Chapter a
 }

-- Chapter
record Chapter a = {
  content : a,
  subChapters : List (Chapter a)
 }

-- Some actual content
sum RichContent = Image Bytes | Gif Bytes | Text Text

-- Rich document
prod RichDocument = (Document RichContent)
</code></pre>
<pre><code class="language-shell">$ nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-rust -- Document.lbf
$ find autogen/
autogen/
autogen/LambdaBuffers
autogen/LambdaBuffers/Document.hs
autogen/build.json
</code></pre>
<p>As we can see the <code>autogen</code> directory has been created that contains the generated Rust modules.
Note the <code>autogen/build.json</code> file as it contains all the necessary Cargo dependencies the generated module needs in order to be properly compiled by Rust.</p>
<p>The outputted Rust module in <code>autogen/document.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_implicit_prelude]
#![allow(warnings)]
<span class="boring">fn main() {
</span>extern crate lbf_prelude;
extern crate std;


#[derive(std::fmt::Debug, std::clone::Clone)]
pub enum Author{Ivan, Jovan, Savo}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub struct Chapter&lt;A&gt;{pub content: A,
                     pub sub_chapters: std::boxed::Box&lt;lbf_prelude::prelude::List&lt;Chapter&lt;A&gt;&gt;&gt;}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub struct Document&lt;A&gt;{pub author: Author,
                      pub reviewers: lbf_prelude::prelude::Set&lt;Reviewer&gt;,
                      pub content: Chapter&lt;A&gt;}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub enum Reviewer{Bob, Alice}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub enum RichContent{Image(lbf_prelude::prelude::Bytes),
                    Gif(lbf_prelude::prelude::Bytes),
                    Text(lbf_prelude::prelude::Text)}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub struct RichDocument(pub Document&lt;RichContent&gt;);

<span class="boring">}</span></code></pre></pre>
<h2 id="sum-types-2"><a class="header" href="#sum-types-2">Sum types</a></h2>
<p>The types <code>Author</code>, <code>Reviewer</code>, and <code>RichContent</code> have been declared as sum types in the LambdaBuffers schema using the <code>sum</code> keyword.</p>
<p>As we can see, nothing too surprising here, all the <code>sum</code> types become <code>enum</code>
in Rust.</p>
<h2 id="product-types-2"><a class="header" href="#product-types-2">Product types</a></h2>
<p>The type <code>RichDocument</code> have been declared as a product type in the
LambdaBuffers schema using the <code>prod</code> keyword.</p>
<p>They become Rust tuple <code>struct</code> (or named tuple)</p>
<h2 id="record-types-2"><a class="header" href="#record-types-2">Record types</a></h2>
<p>The types <code>Document</code> and <code>Chapter</code> have been declared as record types in the
LambdaBuffers schema using the <code>record</code> keyword.</p>
<p>Like with product types, they become Rust <code>struct</code> with named fields.</p>
<p>All types and their fields are public, allowing to manipulate them without accessors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-to-typescript"><a class="header" href="#lambdabuffers-to-typescript">LambdaBuffers to Typescript</a></h1>
<p>This chapter will walk through a translation from a LambdaBuffers' module into a Typescript module.</p>
<p>To demonstrate this, we will use the <code>lbf-prelude-to-typescript</code> CLI tool which is just a convenient wrapper over the raw <code>lbf</code> CLI.
To this end, we may enter a development shell which provides this tool along with many other Lambda Buffers CLI tools with the following command.</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf&lt;tab&gt;
lbf                          lbf-plutus-to-haskell        lbf-plutus-to-rust           lbf-prelude-to-haskell       lbf-prelude-to-rust
lbf-list-modules-typescript  lbf-plutus-to-purescript     lbf-plutus-to-typescript     lbf-prelude-to-purescript    lbf-prelude-to-typescript

</code></pre>
<p>Or, we may directly refer to the <code>lbf-prelude-to-typescript</code> CLI with the following command.</p>
<pre><code class="language-shell">nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-typescript
</code></pre>
<p>In this chapter, we will use the former option.</p>
<p>Consider the <a href="./examples/Document.lbf">Document.lbf</a> schema which we may recall is as follows.</p>
<pre><code class="language-purescript">module Document

-- Importing types
import Prelude (Text, List, Set, Bytes)

-- Author
sum Author = Ivan | Jovan | Savo

-- Reviewer
sum Reviewer = Bob | Alice

-- Document
record Document a = {
  author : Author,
  reviewers : Set Reviewer,
  content : Chapter a
 }

-- Chapter
record Chapter a = {
  content : a,
  subChapters : List (Chapter a)
 }

-- Some actual content
sum RichContent = Image Bytes | Gif Bytes | Text Text

-- Rich document
prod RichDocument = (Document RichContent)
</code></pre>
<p>We generate the corresponding Typescript code with the following commands.</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf-list-modules-typescript lbf-document=. &gt; lb-pkgs.json 
$ lbf-prelude-to-typescript --gen-opt="--packages lb-pkgs.json" Document.lbf
$ find autogen/
autogen/
autogen/LambdaBuffers
autogen/LambdaBuffers/Document.mts
autogen/build.json
</code></pre>
<p>The generated <code>autogen</code> directory created contains the generated Typescript modules.</p>
<p>Note that <code>lbf-list-modules-typescript</code> is needed to create a JSON object which maps package names (for NPM) to Lambda Buffers' modules.
Thus, in this example, one should have a <code>package.json</code> file which associates the key <code>"name"</code> with the string value <code>"lbf-document"</code>.</p>
<p>The <code>autogen/build.json</code> file can be ignored.</p>
<p>The file <code>autogen/LambdaBuffers/Document.mts</code> contains the outputted Typescript module:</p>
<pre><code class="language-ts">// @ts-nocheck
import * as LambdaBuffers$Document from './Document.mjs'
import * as LambdaBuffers$Prelude from './Prelude.mjs'

export type Author = | { name : 'Ivan' }
                     | { name : 'Jovan' }
                     | { name : 'Savo' }
export const Author : unique symbol = Symbol('Author')
export type Chapter&lt;$a&gt; = { content : $a
                          , subChapters : LambdaBuffers$Prelude.List&lt;Chapter&lt;$a&gt;&gt;
                          }
export const Chapter : unique symbol = Symbol('Chapter')
export type Document&lt;$a&gt; = { author : Author
                           , reviewers : LambdaBuffers$Prelude.Set&lt;Reviewer&gt;
                           , content : Chapter&lt;$a&gt;
                           }
export const Document : unique symbol = Symbol('Document')
export type Reviewer = | { name : 'Bob' } | { name : 'Alice' }
export const Reviewer : unique symbol = Symbol('Reviewer')
export type RichContent = | { name : 'Image'
                            , fields : LambdaBuffers$Prelude.Bytes
                            }
                          | { name : 'Gif'
                            , fields : LambdaBuffers$Prelude.Bytes
                            }
                          | { name : 'Text'
                            , fields : LambdaBuffers$Prelude.Text
                            }
export const RichContent : unique symbol = Symbol('RichContent')
export type RichDocument = Document&lt;RichContent&gt;
export const RichDocument : unique symbol = Symbol('RichDocument')
</code></pre>
<h2 id="product-types-3"><a class="header" href="#product-types-3">Product types</a></h2>
<p>The type <code>RichDocument</code> have been declared as a product type in the LambdaBuffers schema using the <code>prod</code> keyword.</p>
<p>In general, product types are mapped to <a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types">tuple types</a> in Typescript most of the time. The exception is if there is only one element in the tuple in which case the type is translated to a type alias.</p>
<p>More precisely, given a LambdaBuffers' product type as follows</p>
<pre><code class="language-purescript">prod MyProduct = SomeType1 ... SomeTypeN
</code></pre>
<p>where the <code>...</code> denotes iterated <code>SomeTypei</code> for some <code>i</code>, then</p>
<ul>
<li>
<p>If <code>N = 0</code> so <code>prod MyProduct =</code>, then we map this to the Typescript type</p>
<pre><code class="language-ts">export type MyProduct = []
</code></pre>
</li>
<li>
<p>If <code>N = 1</code> so <code>prod MyProduct = SomeType1</code>, then we map this to the Typescript type</p>
<pre><code class="language-ts">export type MyProduct = SomeType1
</code></pre>
<p>i.e., <code>MyProduct</code> simply aliases <code>SomeType1</code></p>
</li>
<li>
<p>If <code>N &gt;= 2</code> so <code>prod MyProduct = SomeType1 ... SomeTypeN</code>, then we map this to the Typescript type</p>
<pre><code class="language-ts">export type MyProduct = [SomeType1, ..., SomeTypeN]
</code></pre>
<p>i.e., <code>MyProduct</code> is a tuple with a fixed number of elements with known types.</p>
</li>
</ul>
<h2 id="sum-types-3"><a class="header" href="#sum-types-3">Sum types</a></h2>
<p>The types <code>Author</code>, <code>Reviewer</code>, and <code>RichContent</code> have been declared as sum types in the LambdaBuffers schema using the <code>sum</code> keyword.</p>
<p>In general, sum types are mapped to a <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types">union type</a> in Typescript and with the additional following rules.
Given a LambdaBuffers' sum type as follows</p>
<pre><code class="language-purescript">sum MySum
    = Branch1 Branch1Type1 ... Branch1TypeM1
    | ...
    | BranchN BranchNType1 ... BranchNTypeMN
</code></pre>
<p>where the <code>...</code> denotes either an iterated <code>Branchi</code> for some <code>i</code>, or an iterated <code>BranchiTypej</code> for some <code>i</code> and <code>j</code>, then each branch, say <code>Branchi</code> is translated as follows.</p>
<ul>
<li>
<p>If <code>Branchi</code> has no fields i.e., <code>| Branchi</code>, then the corresponding Typescript type's union member is</p>
<pre><code class="language-ts">| { name: 'Branchi' }
</code></pre>
</li>
<li>
<p>If <code>Branchi</code> has one or more fields i.e., <code>| Branchi BranchiType1 ... BranchiTypeMi</code>, then the corresponding Typescript type's union member is</p>
<pre><code class="language-ts">| { name: 'Branchi' 
  , fields: &lt;Product translation of BranchiType1 ... BranchiTypeMi&gt;
  }
</code></pre>
<p>where <code>&lt;Product translation of BranchiType1 ... BranchiTypeMi&gt;</code> denotes the right hand side of the <a href="typescript.html#product-types">product translation</a> of <code>prod FieldsProduct = BranchiType1 ... BranchiTypeMi</code>.</p>
<p>So, for example, given <code>| Branchi BranchiType1</code>,  the corresponding Typescript type is as follows</p>
<pre><code class="language-ts">| { name: 'Branchi'
  , fields: BranchiType1
  }
</code></pre>
<p>And given <code>| Branchi BranchiType1 BranchiType2</code>, the corresponding Typescript type is as follows.</p>
<pre><code class="language-ts">| { name: 'Branchi'
  , fields: [BranchiType1, BranchiType2]
  }
</code></pre>
</li>
</ul>
<h2 id="record-types-3"><a class="header" href="#record-types-3">Record types</a></h2>
<p>The types <code>Document</code> and <code>Chapter</code> have been declared as record types in the LambdaBuffers schema using the <code>record</code> keyword.</p>
<p>Record types are mapped to <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#object-types">object types</a> in Typescript.
Given a LambdaBuffers' record type as follows</p>
<pre><code class="language-purescript">record MyRecord = { field1: SomeType1, ..., fieldN: SomeTypeN }
</code></pre>
<p>where <code>...</code> denotes iterated <code>fieldi: SomeTypei</code> for some <code>i</code>, the corresponding Typescript type is</p>
<pre><code class="language-ts">type MyRecord = { field1: SomeType1, ..., fieldN, SomeTypeN }
</code></pre>
<h2 id="type-classes-quickstart"><a class="header" href="#type-classes-quickstart">Type classes quickstart</a></h2>
<p>Typescript has no builtin implementation of type classes. As such, LambdaBuffers rolled its own type classes.
A complete usage example can be found in the <a href="./typescript-prelude/src/index.mts">Typescript Prelude sample project</a>, but assuming the packaging is setup correctly, the interface to use a typeclass is as follows</p>
<pre><code class="language-ts">import * as LbrPrelude from "lbr-prelude";

// In Haskell, this is `10 == 11`
LbrPrelude.Eq[LbrPrelude.Integer].eq(10n, 11n) // false

// In Haskell, this is `Just 3 == Nothing`
LbrPrelude.Eq[LbrPrelude.Maybe](LbrPrelude.Eq[LbrPrelude.Integer])
    .eq( { name: 'Just', fields: 3 }
       , { name: 'Nothing' }) // false
</code></pre>
<p>In particular, we access a global variable <code>LbrPrelude.Eq</code> which contains the type class instances, and pick out a particular instance with the type's name like <code>LbrPrelude.Integer</code>. Note that the <code>LbrPrelude.Maybe</code> instance requires knowledge of the <code>Eq</code> instance of the <code>LbrPrelude.Integer</code>, so we must pass that in as a function argument.</p>
<h2 id="type-classes-in-detail"><a class="header" href="#type-classes-in-detail">Type classes in detail</a></h2>
<p>A type class in Typescript is an object type which defines a set of methods.
For example, the <code>Eq</code> type class in Haskell defines the set of methods <code>==</code> (equality) and <code>/=</code> (inequality) as follows.</p>
<pre><code class="language-haskell">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
</code></pre>
<p>The corresponding <a href="https://github.com/mlabs-haskell/prelude-typescript/blob/main/src/Lib/Eq.ts"><code>Eq</code> class</a> in Typescript is:</p>
<pre><code class="language-ts">export interface Eq&lt;A&gt; {
  readonly eq: (l: Readonly&lt;A&gt;, r: Readonly&lt;A&gt;) =&gt; boolean;
  readonly neq: (l: Readonly&lt;A&gt;, r: Readonly&lt;A&gt;) =&gt; boolean;
}
</code></pre>
<p>Each type class in Typescript must have an associated global variable which maps unique representations of its instance types to the corresponding object of the type class implementation.
For example, the <code>Eq</code> type class has the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/runtimes/typescript/lbr-prelude/src/LambdaBuffers/Eq.ts#L11">global variable</a> defined in the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/runtimes/typescript/lbr-prelude">lbr-prelude</a> library defined as follows</p>
<pre><code class="language-ts">export const Eq: EqInstances = { } as EqInstances
</code></pre>
<p>where <code>EqInstances</code> is an interface type that is initially empty but will be extended with instances of types later.</p>
<pre><code class="language-ts">export interface EqInstances { }
</code></pre>
<p>Finally, the following invariant is maintained in the code generator:</p>
<ul>
<li>Every type <code>T</code> has an associated unique <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">symbol</a> also called <code>T</code>.</li>
</ul>
<p>So, the type <code>Integer</code> has</p>
<pre><code class="language-ts">export type Integer = bigint
export const Integer: unique symbol = Symbol('Integer')
</code></pre>
<p>and implementing its <code>Eq</code> instance amounts to the following code.</p>
<pre><code class="language-ts">export interface EqInstances {
    [Integer]: Eq&lt;Integer&gt;
}
Eq[Integer] = { eq: (l,r) =&gt; l === r
              , neq: (l,r) =&gt; l !== r
              }
</code></pre>
<p>For types defined in the LambdaBuffers schema, this chunk of code will be automatically generated provided there is an appropriate <code>derive</code> construct.</p>
<h3 id="type-instances-with-constraints"><a class="header" href="#type-instances-with-constraints">Type instances with constraints</a></h3>
<p>Recall in Haskell that the <code>Eq</code> instance for a tuple may be defined as follows</p>
<pre><code class="language-haskell">instance (Eq a, Eq b) =&gt; Eq (MyPair a b) where
    MyPair a1 a2 == MyPair b1 b2 = a1 == b1 &amp;&amp; a2 == b2
    MyPair a1 a2 != MyPair b1 b2 = a1 != b1 || a2 != b2
</code></pre>
<p>The corresponding Typescript type definition and instance would be defined as follows</p>
<pre><code class="language-ts">export type MyPair&lt;a, b&gt; = [a, b]
export const MyPair: unique symbol = Symbol('MyPair')

export interface EqInstances {
    [MyPair]: &lt;A,B&gt;(a : Eq&lt;A&gt;, b : Eq&lt;B&gt;) =&gt; Eq&lt;MyPair&lt;A,B&gt;&gt;
}
Eq[MyPair] = (dictA, dictB) =&gt; { return { eq: (a,b) =&gt; dictA.eq(a[0], b[0]) &amp;&amp; dictB.eq(a[1], b[1])
                                        , neq: (a,b) =&gt; dictA.neq(a[0], b[0]) || dictB.neq(a[1], b[1])
                                        } 
                               }
</code></pre>
<p>Note that the constraints <code>(Eq a, Eq b) =&gt;</code> become arguments <code>dictA</code> and <code>dictB</code> that are used to construct the <code>Eq</code> instance for <code>MyPair</code>.</p>
<p>This loosely follows the original translation given in the paper <a href="https://dl.acm.org/doi/10.1145/75277.75283">How to make ad-hoc polymorphism less ad hoc</a> with some minor modifications.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>
<p>Only Haskell 2010 typeclasses are supported for the Typescript code generator. So, the following schemas will probably generate incorrect code.</p>
<pre><code class="language-purescript">derive Eq (MyPair a a)
derive Eq (MyMaybe (MyMaybe Integer))
derive Eq (MyMaybe Integer)
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="installing-nix"><a class="header" href="#installing-nix">Installing Nix</a></h2>
<p>This repository relies heavily on the <a href="https://nixos.org/download.html">Nix Package
Manager</a> for both development and package
distribution.</p>
<p>To install run the following command:</p>
<pre><code class="language-sh">sh &lt;(curl -L https://nixos.org/nix/install) --daemon
</code></pre>
<p>and follow the instructions.</p>
<pre><code class="language-sh">$ nix --version
nix (Nix) 2.8.0
</code></pre>
<blockquote>
<p>NOTE: The repository should work with Nix version greater or equal to 2.8.0.</p>
</blockquote>
<p>Make sure to enable <a href="https://nixos.wiki/wiki/Flakes#Enable_flakes">Nix Flakes</a>
and IFD by editing either <code>~/.config/nix/nix.conf</code> or <code>/etc/nix/nix.conf</code> on
your machine and add the following configuration entries:</p>
<pre><code class="language-yaml">experimental-features = nix-command flakes
allow-import-from-derivation = true
</code></pre>
<p>Optionally, to improve build speed, it is possible to set up a binary caches
maintained by IOHK and Plutonomicon by setting additional configuration entries:</p>
<pre><code class="language-yaml">substituters = https://cache.nixos.org https://iohk.cachix.org https://cache.iog.io https://public-plutonomicon.cachix.org
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= iohk.cachix.org-1:DpRUyj7h7V830dp/i6Nti+NEO2/nhblbov/8MW7Rqoo= public-plutonomicon.cachix.org-1:3AKJMhCLn32gri1drGuaZmFrmnue+KkKrhhubQk/CWc=
</code></pre>
<h2 id="building-and-development"><a class="header" href="#building-and-development">Building and development</a></h2>
<p>To facilitate seamlessly moving between directories and associated Nix
development shells we use <a href="https://direnv.net">direnv</a> and
<a href="https://github.com/nix-community/nix-direnv">nix-direnv</a>:</p>
<p>To install both using <code>nixpkgs</code>:</p>
<pre><code class="language-sh">nix profile install nixpkgs#direnv
nix profile install nixpkgs#nix-direnv
</code></pre>
<p>Your shell and editors should pick up on the <code>.envrc</code> files in different
directories and prepare the environment accordingly.  Use <code>direnv allow</code> to
enable the direnv environment and <code>direnv reload</code> to reload it when necessary.</p>
<p>Additionally, throughout the repository one can use:</p>
<pre><code class="language-sh">$ pre-commit run --all
cabal-fmt............................................(no files to check)Skipped
fourmolu.................................................................Passed
hlint....................................................................Passed
markdownlint.............................................................Passed
nix-linter...............................................................Passed
nixpkgs-fmt..............................................................Passed
shellcheck...........................................(no files to check)Skipped
typos....................................................................Passed
</code></pre>
<p>To run all the code quality tooling specified in the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/pre-commit.nix">pre-commit-check config file</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-design"><a class="header" href="#lambdabuffers-design">LambdaBuffers Design</a></h1>
<p>The goal of the LambdaBuffers project is to enable software developers to
specify their application types in a common format that can be conveniently
shared and their values effectively communicated across language barriers.</p>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>Software projects that span multiple language environments often interact in a
sub-optimal manner. Significant effort is spent in making application messages
declared in one language environment available to other language environments.</p>
<p>This burden is particularly onerous in manually written and managed
serialization/encoding code which is used to communicate application values
in the context of networking, configuration and databases.</p>
<p>Ensuring compatibility, consistency and correctness of application messages is a
difficult, tedious and error prone process that often results in unwarranted
costs to the business and unsustainable technical debt.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ol>
<li>Expressive types,</li>
<li>Expressive semantics annotation,</li>
<li>Extensible to new types,</li>
<li>Extensible to new semantics,</li>
<li>Universally consistent semantics,</li>
<li>Modular API architecture.</li>
</ol>
<h3 id="expressive-types"><a class="header" href="#expressive-types">Expressive Types</a></h3>
<p>Application types that users can define should be expressive enough to
facilitate type driven domain modeling and to express application
programming interfaces.</p>
<p>Taking inspiration from existing type systems, LambdaBuffers supports <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic
data types</a> that facilitate
elegant type composition. Such types are well studied and widely used in
functional programming languages such as Haskell.</p>
<p>LambdaBuffers supports first class sum, product and record types. Types can be
parameterized, effectively enabling generic types. LambdaBuffers also supports
recursive type definitions, which allow users to succinctly define elegant and
expressive data structures.</p>
<h3 id="expressive-semantics-annotation"><a class="header" href="#expressive-semantics-annotation">Expressive Semantics Annotation</a></h3>
<p>Enabling users to manage the <em>semantics</em> associated with their types is
essential for adapting LambdaBuffers to a variety of different domains and use
cases.</p>
<p>While most existing schema systems only facilitate type declarations in a
variety of languages, LambdaBuffers takes a further step and provides users with
the capability to manage the <em>semantics</em> of the types defined in schemata by
indicating which basic operations and functions a type ought to support.</p>
<p>For example, suppose a user would like some types to support certain encoding
(e.g. JSON or CBOR). In order to support a particular encoding, functions that
serialize and deserialize the types are needed in the target language(s).
Another example: Users may wish to declare that certain types are numeric - i.e.
that values of these types can be added, subtracted or multiplied in a given
target language. Most types could be declared to support an equality relation,
which requires a function that can check values for equality in the target
language(s).</p>
<p>In order to provide users the capability to manage the <em>semantics</em> of the types
they define, LambdaBuffers supports <a href="https://en.wikipedia.org/wiki/Type_class">type
classes</a>, also known as <em>type
constraints</em>. Type classes are a well-established mechanism for supporting ad
hoc polymorphism, backed by a large amount of academic research and widely used
in functional programming languages such as Haskell, PureScript, and (albeit
under a different name) Rust.</p>
<p>One essential difference between LambdaBuffers type classes and type classes as
implemented in Haskell/PureScript/Rust is that LambdaBuffers does not allow
users to declare the implementation of type class instances. Instead, users
declare <em>instance clauses</em> for their types which signify the <em>semantics</em> (i.e.
functions, methods) they wish to be generated in the target language. All
implementation are generated uniformly as elaborated in the specification
document for a given type class.</p>
<p>For each new type class declared, code generation tooling must be updated to
handle the new type class.</p>
<h3 id="extensible-to-new-types"><a class="header" href="#extensible-to-new-types">Extensible to New Types</a></h3>
<p>Enabling users to introduce new <em>built-in</em> types allows LambdaBuffers to be
adapted in many different domains and use cases.</p>
<p>These types have special treatment <em>under the hood</em> and are generally mapped onto
existing types and their value representations in the targeted language
environments. For example, a primitive <code>Int</code> type in the LambdaBuffers schema
language may be mapped to <code>Int</code> in Haskell and <code>i32</code> in Rust. Primitive
parameterized types are also possible: A primitive <code>Maybe</code> type might be mapped
to <code>Maybe</code> in Haskell and to <code>Option&lt;_&gt;</code> in Rust.</p>
<p>LambdaBuffers supports <a href="https://en.wikipedia.org/wiki/Opaque_data_type">opaque
types</a> to provide users with the
power to define their own primitive or builtin types.</p>
<p>Example opaque types include various integer types, sequence types, text types,
sets, maps and other semantically richer data types. Generally, such types are
already well-defined and widely used in various language environments and come
equipped with rich libraries that work with them. Redefining them <em>ab ovo</em> would
be counterproductive as users would have to re-implement and reinvent the rich
support for such types.</p>
<h3 id="extensible-to-new-semantics"><a class="header" href="#extensible-to-new-semantics">Extensible to New Semantics</a></h3>
<p>Enabling users to introduce new <em>type semantics</em> facilitates LambdaBuffers to be
adapted in many different domains and use cases.</p>
<p>In LambdaBuffers, introducing new <em>type semantics</em> works by first declaring a
<em>type class</em>, which is simply the name of the class bundled with any
super-classes (should they exist). Next, specification document that elaborates
how instances are to be generated for members of the class must be created,
taking care to ensure that instances are always generated uniformly. Finally, a
code generation module for the class must be written that implements compliant
code generation for different target languages.</p>
<p>Concretely, serialization has special treatment in most technologies in this
space, however in LambdaBuffers, this is just a new type class.</p>
<p>For each new type class, deliberate effort must be invested to support
that 'semantics' in different target language environments in a compliant manner.
(Because type class instances are generated uniformly relative to the
structure of the original type, in accordance with a set of deriving rules
provided in the code generation implementation, the amount of boilerplate
required to implement a new class is substantially reduced if not
entirely eliminated.)</p>
<p>The LambdaBuffers team will officially support a certain set of type classes and
provide code generation modules for a set of officially supported language
environments. However, modular design will hopefully facilitate community
contributions in a sustainable fashion.</p>
<h3 id="universally-consistent-semantics"><a class="header" href="#universally-consistent-semantics">Universally Consistent Semantics</a></h3>
<p>The types specified by users must be handled in a compatible manner across
language environments. This is a critical requirement that underpins this
project.</p>
<p>If two values of a LambdaBuffers type are considered as 'equal' in one language
environment, they should be considered equal in all others. In a similar
fashion, if LambdaBuffers type has a declared JSON serialization semantics,
values encoded as JSON in one language environment have to have the same
encoding performed in all other language environments.</p>
<p>LambdaBuffers does not provide a way to formally verify consistency across languages,
however, a comprehensive test suite will be developed to ensure that new code
generation modules are indeed implemented correctly.</p>
<h3 id="modular-api-architecture"><a class="header" href="#modular-api-architecture">Modular API Architecture</a></h3>
<p>LambdaBuffers establishes three separate components of the architecture, namely
<em>Frontend</em>, <em>Compiler</em> and <em>Codegen</em>*.</p>
<p><em>Frontend</em> is a user facing component that features a way to input, specify or
otherwise construct application types. <em>Frontend</em> also orchestrates the overall
work that includes the <em>Compiler</em> and <em>Codegen</em>, invoking each of these
components as required by different workflows the <em>Frontend</em> supports.
LambdaBuffers officially supports a <em>Frontend</em> component implementation that
features a text based language for specifying LambdaBuffers types. However,
because of the modular API architecture approach, a <em>Frontend</em> can be
implemented in any language and in any fashion as long as they are able to
interface with the <em>Compiler</em> and <em>Codegen</em> components.</p>
<p>The <em>Compiler</em> is a key component that is made available via the <em>Compiler
Input</em> specified via <a href="https://protobuf.dev/">Google Protocol Buffers</a>. It
performs all the necessary checks to ensure that the naming, type definitions
and their declared semantics are indeed valid.</p>
<p>The <em>Codegen</em> component consumes the <em>Compiler Output</em> that contains all the
information necessary to perform valid and robust code generation. <em>Frontend</em>
communicates with the <em>Codegen</em> to understand its <em>Capabilities</em>, enabling each
<em>Codegen</em> module to gradually build up support for desired opaque types and
declared semantics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocol-documentation"><a class="header" href="#protocol-documentation">Protocol Documentation</a></h1>
<p><a name="top"></a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li>
<p><a href="api.html#lang-proto">lang.proto</a></p>
<ul>
<li>
<p><a href="api.html#lambdabuffers-ClassConstraint">ClassConstraint</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ClassDef">ClassDef</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ClassName">ClassName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ConstrName">ConstrName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Constraint">Constraint</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Derive">Derive</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-FieldName">FieldName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-InstanceClause">InstanceClause</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Kind">Kind</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Kind-KindArrow">Kind.KindArrow</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Module">Module</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ModuleNamePart">ModuleNamePart</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Opaque">Opaque</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Product">Product</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Record">Record</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Record-Field">Record.Field</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-SourcePosition">SourcePosition</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Sum">Sum</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Sum-Constructor">Sum.Constructor</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Ty">Ty</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyAbs">TyAbs</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyApp">TyApp</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyArg">TyArg</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyBody">TyBody</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyClassRef">TyClassRef</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyClassRef-Foreign">TyClassRef.Foreign</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyClassRef-Local">TyClassRef.Local</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyDef">TyDef</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyName">TyName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyRef">TyRef</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyRef-Foreign">TyRef.Foreign</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyRef-Local">TyRef.Local</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyVar">TyVar</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Tys">Tys</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-VarName">VarName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Kind-KindRef">Kind.KindRef</a></p>
</li>
</ul>
</li>
<li>
<p><a href="api.html#compiler-proto">compiler.proto</a></p>
<ul>
<li><a href="api.html#lambdabuffers-compiler-Error">Error</a></li>
<li><a href="api.html#lambdabuffers-compiler-Input">Input</a></li>
<li><a href="api.html#lambdabuffers-compiler-InternalError">InternalError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError">KindCheckError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-CyclicKindError">KindCheckError.CyclicKindError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-InconsistentTypeError">KindCheckError.InconsistentTypeError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-UnboundTyRefError">KindCheckError.UnboundTyRefError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-UnboundTyVarError">KindCheckError.UnboundTyVarError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-UnificationError">KindCheckError.UnificationError</a></li>
<li><a href="api.html#lambdabuffers-compiler-NamingError">NamingError</a></li>
<li><a href="api.html#lambdabuffers-compiler-Output">Output</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError">ProtoParseError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleClassDefError">ProtoParseError.MultipleClassDefError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleConstructorError">ProtoParseError.MultipleConstructorError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleFieldError">ProtoParseError.MultipleFieldError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleImportError">ProtoParseError.MultipleImportError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleModuleError">ProtoParseError.MultipleModuleError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleTyArgError">ProtoParseError.MultipleTyArgError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleTyDefError">ProtoParseError.MultipleTyDefError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-OneOfNotSetError">ProtoParseError.OneOfNotSetError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-UnknownEnumError">ProtoParseError.UnknownEnumError</a></li>
<li><a href="api.html#lambdabuffers-compiler-Result">Result</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError">TyClassCheckError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError">TyClassCheckError.DeriveOpaqueError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError">TyClassCheckError.ImportNotFoundError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-MissingRuleError">TyClassCheckError.MissingRuleError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError">TyClassCheckError.OverlappingRulesError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead">TyClassCheckError.OverlappingRulesError.QHead</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError">TyClassCheckError.SuperclassCycleError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError">TyClassCheckError.UnboundClassRefError</a></li>
</ul>
</li>
<li>
<p><a href="api.html#codegen-proto">codegen.proto</a></p>
<ul>
<li><a href="api.html#lambdabuffers-codegen-Error">Error</a></li>
<li><a href="api.html#lambdabuffers-codegen-Input">Input</a></li>
<li><a href="api.html#lambdabuffers-codegen-InternalError">InternalError</a></li>
<li><a href="api.html#lambdabuffers-codegen-Output">Output</a></li>
<li><a href="api.html#lambdabuffers-codegen-Result">Result</a></li>
<li><a href="api.html#lambdabuffers-codegen-UnsupportedClassError">UnsupportedClassError</a></li>
<li><a href="api.html#lambdabuffers-codegen-UnsupportedOpaqueError">UnsupportedOpaqueError</a></li>
</ul>
</li>
<li>
<p><a href="api.html#scalar-value-types">Scalar Value Types</a></p>
</li>
</ul>
<p><a name="lang-proto"></a></p>
<p align="right"><a href="api.html#top">Top</a></p>
<h2 id="langproto"><a class="header" href="#langproto">lang.proto</a></h2>
<p><a name="lambdabuffers-ClassConstraint"></a></p>
<h3 id="classconstraint"><a class="header" href="#classconstraint">ClassConstraint</a></h3>
<p>Class constraints</p>
<p>A special constraint type denoting the constraints that occur on the rhs of
class definitions. Only used to specify super class constraints in a
<code>ClassDef</code>.</p>
<p>Not to be confused with <code>Constraint</code> which denote type class rules.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef">TyClassRef</a></td><td></td><td>Type class reference.</td></tr>
<tr><td>args</td><td><a href="api.html#lambdabuffers-TyVar">TyVar</a></td><td>repeated</td><td>Type variables quantified over <code>ClassDef</code> arguments.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ClassDef"></a></p>
<h3 id="classdef"><a class="header" href="#classdef">ClassDef</a></h3>
<p>Type class definition</p>
<p>LambdaBuffers use type classes to talk about the various 'meanings' or
'semantics' we want to associate with the types in LambdaBuffers schemata.</p>
<p>For instance, most types can have <code>Eq</code> semantics, meaning they can be
compared for equality. Other can have <code>Ord</code> semantics, meaning they can be
ordered.</p>
<p>Using type classes and instance declarations, much like in Haskell, users can
specify the 'meaning' of each type they declare. For example, serialization
in LambdaBuffers is just another type class, it's treated the same as any
other type class. Concretely, if we wish to provide JSON serialization for
LambdaBuffers types, we declare such a type class and provide desired
semantic rules:</p>
<pre><code class="language-lbf">module Foo

class JSON a

sum Foo a b = Bar a | Baz b

derive JSON (Foo a b)
</code></pre>
<p>Note that for each type class introduced, the Codegen machinery must be
updated to support said type class. In other words, it doesn't come for free
and for each new type class, a Codegen support must be implemented for any
<code>InstanceClause</code> declared by the user. Once all the <code>InstanceClause</code>s have an
implementation provided, all the <code>Derive</code>d implementation come for free.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Type class name.</td></tr>
<tr><td>class_args</td><td><a href="api.html#lambdabuffers-TyArg">TyArg</a></td><td>repeated</td><td>Type class arguments. Class with no arguments is a trivial class. Compiler MAY report an error. TODO(bladyjoker): MultipleClassArgError.</td></tr>
<tr><td>supers</td><td><a href="api.html#lambdabuffers-ClassConstraint">ClassConstraint</a></td><td>repeated</td><td>Superclass constraints.</td></tr>
<tr><td>documentation</td><td><a href="api.html#string">string</a></td><td></td><td>Documentation elaborating on the type class.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ClassName"></a></p>
<h3 id="classname"><a class="header" href="#classname">ClassName</a></h3>
<p>Type class name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ConstrName"></a></p>
<h3 id="constrname"><a class="header" href="#constrname">ConstrName</a></h3>
<p>Sum type constructor name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Constraint"></a></p>
<h3 id="constraint"><a class="header" href="#constraint">Constraint</a></h3>
<p>Constraint term</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef">TyClassRef</a></td><td></td><td>Name of the type class.</td></tr>
<tr><td>args</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Constraint arguments. Constraint with no arguments is a trivial constraint. Compiler MAY report an error.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Derive"></a></p>
<h3 id="derive"><a class="header" href="#derive">Derive</a></h3>
<p>Derive statement</p>
<p>Derive statements enable user to specify 'semantic' rules for their types much
like <code>InstanceClause</code>s do. However, the Codegen will be able to derive an
implementation for any such constraint.</p>
<pre><code class="language-lbf">module Prelude

class Eq a

sum Maybe a = Just a | Nothing

derive Eq (Maybe a)
</code></pre>
<p>The rule installed for the derive statement is:</p>
<pre><code class="language-prolog">eq(maybe(A)) :- eq(just(A) | Nothing).
</code></pre>
<p>The rule relates the desired <code>Ty</code> term to its (lambda calculus)
'evaluated' form.</p>
<p>&gt; Currently, there's only support for deriving type class rules and
implementations for <code>Ty</code> terms of <code>Kind.KIND_REF_TYPE</code>. That means,
type classes like Ord and Eq...</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constraint</td><td><a href="api.html#lambdabuffers-Constraint">Constraint</a></td><td></td><td>Constraint to derive.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-FieldName"></a></p>
<h3 id="fieldname"><a class="header" href="#fieldname">FieldName</a></h3>
<p>Record type field name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [a-z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-InstanceClause"></a></p>
<h3 id="instanceclause"><a class="header" href="#instanceclause">InstanceClause</a></h3>
<p>Instance clause</p>
<p>Instance clauses enable users to specify ad-hoc 'semantic' rules for their
types. Each such instance must be supported explicitly in the Codegen by
providing runtime implementations.</p>
<p>This rule form is used when declaring 'opaque' implementations on <code>Opaque</code>
types.</p>
<pre><code class="language-lbf">module Prelude

class Eq a

opaque Maybe a

instance Eq a =&amp;gt; Eq (Maybe a)
</code></pre>
<p>The rule installed for the clause is:</p>
<pre><code class="language-prolog">eq(maybe(A)) :- eq(A).
</code></pre>
<p>The instance clause is verbatim added to the rule set.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>head</td><td><a href="api.html#lambdabuffers-Constraint">Constraint</a></td><td></td><td>Head of the clause that holds only when the <code>body</code> holds. Type variables introduced in the head of the rule become available in the scope of the body of the rule.</td></tr>
<tr><td>constraints</td><td><a href="api.html#lambdabuffers-Constraint">Constraint</a></td><td>repeated</td><td>Instance (rule) body, conjunction of constraints.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind"></a></p>
<h3 id="kind"><a class="header" href="#kind">Kind</a></h3>
<p>Kinds</p>
<p>A type of a type is called a 'kind'.
In Lambda Buffers, all type terms, namely TyArg, TyVar, TyRef, TyApp and TyAbs,
are either of kind <code>Type</code> or <code>Type -&amp;gt; Type</code> and <code>Type -&amp;gt; Type -&amp;gt; Type</code>
etc.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>kind_ref</td><td><a href="api.html#lambdabuffers-Kind-KindRef">Kind.KindRef</a></td><td></td><td></td></tr>
<tr><td>kind_arrow</td><td><a href="api.html#lambdabuffers-Kind-KindArrow">Kind.KindArrow</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind-KindArrow"></a></p>
<h3 id="kindkindarrow"><a class="header" href="#kindkindarrow">Kind.KindArrow</a></h3>
<p>A kind arrow.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>left</td><td><a href="api.html#lambdabuffers-Kind">Kind</a></td><td></td><td></td></tr>
<tr><td>right</td><td><a href="api.html#lambdabuffers-Kind">Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Module"></a></p>
<h3 id="module"><a class="header" href="#module">Module</a></h3>
<p>Module</p>
<p>A module encapsulates type, class and instance definitions.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Module name.</td></tr>
<tr><td>type_defs</td><td><a href="api.html#lambdabuffers-TyDef">TyDef</a></td><td>repeated</td><td>Type definitions. Duplicate type definitions MUST be reported with <code>ProtoParseError.MultipleTyDefError</code>.</td></tr>
<tr><td>class_defs</td><td><a href="api.html#lambdabuffers-ClassDef">ClassDef</a></td><td>repeated</td><td>Type class definitions. Duplicate class definitions MUST be reported with <code>ProtoParseError.MultipleClassDefError</code>.</td></tr>
<tr><td>instances</td><td><a href="api.html#lambdabuffers-InstanceClause">InstanceClause</a></td><td>repeated</td><td>Type class instance clauses.</td></tr>
<tr><td>derives</td><td><a href="api.html#lambdabuffers-Derive">Derive</a></td><td>repeated</td><td>Type class derive statements.</td></tr>
<tr><td>imports</td><td><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></td><td>repeated</td><td>Imported modules the Compiler consults when searching for type class rules. TODO(bladyjoker): Rename to ruleImports. Duplicate imports MUST be reported with <code>ProtoParseError.MultipleImportError</code>.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ModuleName"></a></p>
<h3 id="modulename"><a class="header" href="#modulename">ModuleName</a></h3>
<p>Module name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>parts</td><td><a href="api.html#lambdabuffers-ModuleNamePart">ModuleNamePart</a></td><td>repeated</td><td>Parts of the module name denoting a hierarchical namespace.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ModuleNamePart"></a></p>
<h3 id="modulenamepart"><a class="header" href="#modulenamepart">ModuleNamePart</a></h3>
<p>Module name part</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Opaque"></a></p>
<h3 id="opaque"><a class="header" href="#opaque">Opaque</a></h3>
<p>Opaque type.</p>
<p>A type that has an <code>Opaque</code> body represents a 'built-in' or a 'primitive' type
that's handled by the semantics 'under the hood'. It's called 'opaque' to denote
the fact that the Compiler has no knowledge of its structure, and relies that
the necessary knowledge is implemented elsewhere. The Codegen modules for any
target language have to be able to handle such types specifically and map to
existing value level representations and corresponding types.</p>
<p>Codegen modules would have to implement support for such defined types, for
example:</p>
<ul>
<li>In Python <code>Set a</code> would map to <code>set()</code> from the standard library,</li>
<li>In Haskell <code>Set a</code> would map to <code>containers</code>.Data.Set.Set type.</li>
</ul>
<p>Every <code>Opaque</code> type has to be considered deliberately for each language
environment targeted by Codegen modules.</p>
<p>TODO(bladyjoker): Consider attaching explicit Kind terms to Opaques.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Product"></a></p>
<h3 id="product"><a class="header" href="#product">Product</a></h3>
<p>A product type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>fields</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Fields in a products are types.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Record"></a></p>
<h3 id="record"><a class="header" href="#record">Record</a></h3>
<p>A record type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>fields</td><td><a href="api.html#lambdabuffers-Record-Field">Record.Field</a></td><td>repeated</td><td>Record fields.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Record-Field"></a></p>
<h3 id="recordfield"><a class="header" href="#recordfield">Record.Field</a></h3>
<p>Field in a record type.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>field_name</td><td><a href="api.html#lambdabuffers-FieldName">FieldName</a></td><td></td><td>Record field name.</td></tr>
<tr><td>field_ty</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td></td><td>Field type.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-SourceInfo"></a></p>
<h3 id="sourceinfo"><a class="header" href="#sourceinfo">SourceInfo</a></h3>
<p>Frontend Source information</p>
<p>Frontends are advised to include <em>Source</em> information to denote how their
Source* content maps to the <em>Compiler Input</em>. It's essential when reporting
Compiler* errors back to the Frontend.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>file</td><td><a href="api.html#string">string</a></td><td></td><td>A filename denoting the Source file.</td></tr>
<tr><td>pos_from</td><td><a href="api.html#lambdabuffers-SourcePosition">SourcePosition</a></td><td></td><td>Starting position in Source.</td></tr>
<tr><td>pos_to</td><td><a href="api.html#lambdabuffers-SourcePosition">SourcePosition</a></td><td></td><td>End position in Source.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-SourcePosition"></a></p>
<h3 id="sourceposition"><a class="header" href="#sourceposition">SourcePosition</a></h3>
<p>Position in Source</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>column</td><td><a href="api.html#int32">int32</a></td><td></td><td>Column index in the Source.</td></tr>
<tr><td>row</td><td><a href="api.html#int32">int32</a></td><td></td><td>Row index in the Source.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Sum"></a></p>
<h3 id="sum"><a class="header" href="#sum">Sum</a></h3>
<p>A sum type term.</p>
<p>A type defined as a Sum type is just like a Haskell algebraic data type and
represents a sum of products.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constructors</td><td><a href="api.html#lambdabuffers-Sum-Constructor">Sum.Constructor</a></td><td>repeated</td><td>Sum type constructors. Empty <code>constructors</code> means <code>void</code> and means that the type can't be constructed. Compiler MAY report an error. Duplicate constructors MUST be reported with <code>ProtoParseError.MultipleConstructorError</code>.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Sum-Constructor"></a></p>
<h3 id="sumconstructor"><a class="header" href="#sumconstructor">Sum.Constructor</a></h3>
<p>Constructor of a Sum type is a Product type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constr_name</td><td><a href="api.html#lambdabuffers-ConstrName">ConstrName</a></td><td></td><td>Constructor name.</td></tr>
<tr><td>product</td><td><a href="api.html#lambdabuffers-Product">Product</a></td><td></td><td>Product type term.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Ty"></a></p>
<h3 id="ty"><a class="header" href="#ty">Ty</a></h3>
<p>Type term</p>
<p>A type term that occurs in bodies of type definitions (message TyDef):</p>
<pre><code class="language-lbf">sum Maybe a = Just a | Nothing

sum Either a b = Left a | Right b

sum SomeType a = Foo a (Maybe a) | Bar (Either (Maybe a) (SomeType a))
</code></pre>
<p>or in instance declarations:</p>
<pre><code class="language-lbf">instance Eq (Maybe a)

instance Eq (SomeType Int)

instance (Eq (Maybe a), Eq (SomeType a)) Eq (Either (Maybe a) (SomeType a))
</code></pre>
<p>Check out <a href="examples/tys.textproto">examples</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_var</td><td><a href="api.html#lambdabuffers-TyVar">TyVar</a></td><td></td><td>A type variable.</td></tr>
<tr><td>ty_app</td><td><a href="api.html#lambdabuffers-TyApp">TyApp</a></td><td></td><td>A type application.</td></tr>
<tr><td>ty_ref</td><td><a href="api.html#lambdabuffers-TyRef">TyRef</a></td><td></td><td>A type reference.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyAbs"></a></p>
<h3 id="tyabs"><a class="header" href="#tyabs">TyAbs</a></h3>
<p>Type abstraction</p>
<p>A type term that introduces type abstractions (ie. type functions). This
type term can only be introduced in the context of a
[type definition](@ref TyDef).</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_args</td><td><a href="api.html#lambdabuffers-TyArg">TyArg</a></td><td>repeated</td><td>List of type variables. No type arguments means <code>delay</code> or <code>const ty_body</code>, meaning <code>TyAbs [] ty_body = ty_body</code>. Duplicate type arguments MUST be reported with <code>ProtoParseError.MultipleTyArgError</code>.</td></tr>
<tr><td>ty_body</td><td><a href="api.html#lambdabuffers-TyBody">TyBody</a></td><td></td><td>Type body.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyApp"></a></p>
<h3 id="tyapp"><a class="header" href="#tyapp">TyApp</a></h3>
<p>Type application</p>
<p>A type term that applies a type abstraction to a list of arguments.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_func</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td></td><td>Type function. TODO(bladyjoker): Rename to ty_abs?</td></tr>
<tr><td>ty_args</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Arguments to apply. No arguments to apply means <code>force</code>, meaning `TyApp ty_func [] = ty_func``</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyArg"></a></p>
<h3 id="tyarg"><a class="header" href="#tyarg">TyArg</a></h3>
<p>Type arguments</p>
<p>Arguments in type abstractions.</p>
<p>Type arguments and therefore type variables have kinds, the Compiler only
accepts <code>Type</code> kinded type arguments ans therefore type variables.</p>
<p>However, to allow for future evolution if ever necessary, we attach the Kind
term to type arguments, even though the Compiler will reject any TyArg that's
not of kind <code>Type</code>.</p>
<p>Note, this effectively means that lambda Buffers doesn't support higher-kinded
types (ie. HKT).</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>arg_name</td><td><a href="api.html#lambdabuffers-VarName">VarName</a></td><td></td><td>Argument name corresponds to variable names.</td></tr>
<tr><td>arg_kind</td><td><a href="api.html#lambdabuffers-Kind">Kind</a></td><td></td><td>Argument kind.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyBody"></a></p>
<h3 id="tybody"><a class="header" href="#tybody">TyBody</a></h3>
<p>Type body.</p>
<p>Lambda Buffers type bodies type terms that can only be specified in the
<code>TyAbs</code> context. It's a built-in type term that can only occur enclosed
within a <code>TyAbs</code> term which introduces <code>TyVar</code>s in the scope of the term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>opaque</td><td><a href="api.html#lambdabuffers-Opaque">Opaque</a></td><td></td><td></td></tr>
<tr><td>sum</td><td><a href="api.html#lambdabuffers-Sum">Sum</a></td><td></td><td></td></tr>
<tr><td>product</td><td><a href="api.html#lambdabuffers-Product">Product</a></td><td></td><td></td></tr>
<tr><td>record</td><td><a href="api.html#lambdabuffers-Record">Record</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef"></a></p>
<h3 id="tyclassref"><a class="header" href="#tyclassref">TyClassRef</a></h3>
<p>Type class references</p>
<p>It is necessary to know whether a type class is defined locally or in a
foreign module when referring to it in a constraint, this allows users (and
requires the frontend) to explicitly communicate that information.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>local_class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef-Local">TyClassRef.Local</a></td><td></td><td></td></tr>
<tr><td>foreign_class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef-Foreign">TyClassRef.Foreign</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef-Foreign"></a></p>
<h3 id="tyclassrefforeign"><a class="header" href="#tyclassrefforeign">TyClassRef.Foreign</a></h3>
<p>Foreign class reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Foreign module class name.</td></tr>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Foreign module name.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef-Local"></a></p>
<h3 id="tyclassreflocal"><a class="header" href="#tyclassreflocal">TyClassRef.Local</a></h3>
<p>Local type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Local module class name.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyDef"></a></p>
<h3 id="tydef"><a class="header" href="#tydef">TyDef</a></h3>
<p>Type definition</p>
<p>A type definition consists of a type name and its associated type term.</p>
<p>One way to look at it is that a type definition introduces a named 'type
abstraction' in the module scope. Concretely, <code>Either</code> can be considered a type
lambda of kind <code>Type -&amp;gt; Type -&amp;gt; Type</code>.</p>
<p>In fact, type definitions are the only way to introduce such types.</p>
<p>Once introduced in the module scope, type definitions are referred to using
[TyRef](@ref TyRef) term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="api.html#lambdabuffers-TyName">TyName</a></td><td></td><td>Type name.</td></tr>
<tr><td>ty_abs</td><td><a href="api.html#lambdabuffers-TyAbs">TyAbs</a></td><td></td><td>Type term.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyName"></a></p>
<h3 id="tyname"><a class="header" href="#tyname">TyName</a></h3>
<p>Type name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef"></a></p>
<h3 id="tyref"><a class="header" href="#tyref">TyRef</a></h3>
<p>Type reference</p>
<p>A type term that denotes a reference to a type available that's declared
locally or in foreign modules.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>local_ty_ref</td><td><a href="api.html#lambdabuffers-TyRef-Local">TyRef.Local</a></td><td></td><td></td></tr>
<tr><td>foreign_ty_ref</td><td><a href="api.html#lambdabuffers-TyRef-Foreign">TyRef.Foreign</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef-Foreign"></a></p>
<h3 id="tyrefforeign"><a class="header" href="#tyrefforeign">TyRef.Foreign</a></h3>
<p>Foreign type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="api.html#lambdabuffers-TyName">TyName</a></td><td></td><td>Foreign module type name.</td></tr>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Foreign module name.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef-Local"></a></p>
<h3 id="tyreflocal"><a class="header" href="#tyreflocal">TyRef.Local</a></h3>
<p>Local type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="api.html#lambdabuffers-TyName">TyName</a></td><td></td><td>Local module type name.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyVar"></a></p>
<h3 id="tyvar"><a class="header" href="#tyvar">TyVar</a></h3>
<p>Type variable</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>var_name</td><td><a href="api.html#lambdabuffers-VarName">VarName</a></td><td></td><td>Variable name.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Tys"></a></p>
<h3 id="tys"><a class="header" href="#tys">Tys</a></h3>
<p>A list of type terms useful for debugging</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ties</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-VarName"></a></p>
<h3 id="varname"><a class="header" href="#varname">VarName</a></h3>
<p>Type variable name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [a-z]+</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind-KindRef"></a></p>
<h3 id="kindkindref"><a class="header" href="#kindkindref">Kind.KindRef</a></h3>
<p>A built-in kind.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>KIND_REF_UNSPECIFIED</td><td>0</td><td>Unspecified kind SHOULD be inferred by the Compiler.</td></tr>
<tr><td>KIND_REF_TYPE</td><td>1</td><td>A <code>Type</code> kind (also know as <code>*</code> in Haskell) built-in.</td></tr>
</tbody></table>
</div>
<p><a name="compiler-proto"></a></p>
<p align="right"><a href="api.html#top">Top</a></p>
<h2 id="compilerproto"><a class="header" href="#compilerproto">compiler.proto</a></h2>
<p><a name="lambdabuffers-compiler-Error"></a></p>
<h3 id="error"><a class="header" href="#error">Error</a></h3>
<p>Compiler Error</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>proto_parse_errors</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError">ProtoParseError</a></td><td>repeated</td><td>Errors occurred during proto parsing.</td></tr>
<tr><td>naming_errors</td><td><a href="api.html#lambdabuffers-compiler-NamingError">NamingError</a></td><td>repeated</td><td>Errors occurred during naming checking.</td></tr>
<tr><td>kind_check_errors</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError">KindCheckError</a></td><td>repeated</td><td>Errors occurred during kind checking.</td></tr>
<tr><td>ty_class_check_errors</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError">TyClassCheckError</a></td><td>repeated</td><td>Errors occurred during type class checking.</td></tr>
<tr><td>internal_errors</td><td><a href="api.html#lambdabuffers-compiler-InternalError">InternalError</a></td><td>repeated</td><td>Errors internal to the compiler implementation.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Input"></a></p>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<p>Compiler Input</p>
<p>Compiler Input is a fully self contained list of modules, the entire
compilation closure needed by the Compiler to perform its task.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="api.html#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Modules to compile. Duplicate modules MUST be reported with <code>ProtoParseError.MultipleModuleError</code>.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-InternalError"></a></p>
<h3 id="internalerror"><a class="header" href="#internalerror">InternalError</a></h3>
<p>Errors internal to the implementation.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msg</td><td><a href="api.html#string">string</a></td><td></td><td>Error message.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">lambdabuffers.SourceInfo</a></td><td></td><td>Source information if meaningful.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError"></a></p>
<h3 id="kindcheckerror"><a class="header" href="#kindcheckerror">KindCheckError</a></h3>
<p>Kind checking errors.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>unbound_ty_ref_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-UnboundTyRefError">KindCheckError.UnboundTyRefError</a></td><td></td><td></td></tr>
<tr><td>unbound_ty_var_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-UnboundTyVarError">KindCheckError.UnboundTyVarError</a></td><td></td><td></td></tr>
<tr><td>unification_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-UnificationError">KindCheckError.UnificationError</a></td><td></td><td></td></tr>
<tr><td>cyclic_kind_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-CyclicKindError">KindCheckError.CyclicKindError</a></td><td></td><td></td></tr>
<tr><td>inconsistent_type_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-InconsistentTypeError">KindCheckError.InconsistentTypeError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-CyclicKindError"></a></p>
<h3 id="kindcheckerrorcyclickinderror"><a class="header" href="#kindcheckerrorcyclickinderror">KindCheckError.CyclicKindError</a></h3>
<p>A cyclic kind was encountered. Infinite kinds like this are not acceptable,
and we do not support them. We could not construct infinite kind in ty_def.</p>
<p>As the implementation currently stands such an error is (most likely) not
representable - therefore not reachable. Such an error would usually occur
for a term like: λa. a a - in which case the inference would try to unify
two kinds of the form: m and m -&gt; n - because m appears in both terms -
the cyclic unification error would be thrown.</p>
<p>In the case of LambdaBuffers - such an error is not (currently) achievable
as the kind of the variable is given by the context - (i.e. λa : m . a a,
where m is a kind) therefore the unification would fail with Unification
Error. Nevertheless - future features might require it.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-InconsistentTypeError"></a></p>
<h3 id="kindcheckerrorinconsistenttypeerror"><a class="header" href="#kindcheckerrorinconsistenttypeerror">KindCheckError.InconsistentTypeError</a></h3>
<p>The actual_kind differs from the expected_kind.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>actual_kind</td><td><a href="api.html#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
<tr><td>expected_kind</td><td><a href="api.html#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnboundTyRefError"></a></p>
<h3 id="kindcheckerrorunboundtyreferror"><a class="header" href="#kindcheckerrorunboundtyreferror">KindCheckError.UnboundTyRefError</a></h3>
<p>Unbound type reference ty_ref detected in term ty_def.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_ref</td><td><a href="api.html#lambdabuffers-TyRef">lambdabuffers.TyRef</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnboundTyVarError"></a></p>
<h3 id="kindcheckerrorunboundtyvarerror"><a class="header" href="#kindcheckerrorunboundtyvarerror">KindCheckError.UnboundTyVarError</a></h3>
<p>Unbound variable ty_var detected in term ty_def.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_var</td><td><a href="api.html#lambdabuffers-TyVar">lambdabuffers.TyVar</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnificationError"></a></p>
<h3 id="kindcheckerrorunificationerror"><a class="header" href="#kindcheckerrorunificationerror">KindCheckError.UnificationError</a></h3>
<p>In ty_def an error has occurred when trying to unify kind ty_kind_lhs
with ty_kind_rhs.</p>
<p>FIXME(cstml): Add source of constraint to the error such that user can see
where the constraint was generated - therefore where the error precisely
is.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_kind_lhs</td><td><a href="api.html#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
<tr><td>ty_kind_rhs</td><td><a href="api.html#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-NamingError"></a></p>
<h3 id="namingerror"><a class="header" href="#namingerror">NamingError</a></h3>
<p>Naming error message</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name_err</td><td><a href="api.html#lambdabuffers-ModuleNamePart">lambdabuffers.ModuleNamePart</a></td><td></td><td></td></tr>
<tr><td>ty_name_err</td><td><a href="api.html#lambdabuffers-TyName">lambdabuffers.TyName</a></td><td></td><td></td></tr>
<tr><td>var_name_err</td><td><a href="api.html#lambdabuffers-VarName">lambdabuffers.VarName</a></td><td></td><td></td></tr>
<tr><td>constr_name_err</td><td><a href="api.html#lambdabuffers-ConstrName">lambdabuffers.ConstrName</a></td><td></td><td></td></tr>
<tr><td>field_name_err</td><td><a href="api.html#lambdabuffers-FieldName">lambdabuffers.FieldName</a></td><td></td><td></td></tr>
<tr><td>class_name_err</td><td><a href="api.html#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Output"></a></p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>Output of the Compiler.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>error</td><td><a href="api.html#lambdabuffers-compiler-Error">Error</a></td><td></td><td></td></tr>
<tr><td>result</td><td><a href="api.html#lambdabuffers-compiler-Result">Result</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError"></a></p>
<h3 id="protoparseerror"><a class="header" href="#protoparseerror">ProtoParseError</a></h3>
<p>All errors that occur because of Google Protocol Buffer's inability to
enforce certain invariants.
Some of invariance:</p>
<ul>
<li>using Proto <code>map</code> restricts users to <code>string</code> keys which impacts
API documentation, which is why <code>repeated</code> fields are used throughout,</li>
<li>using Proto 'oneof' means users have to check if such a field is
set or report an error otherwise.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>multiple_module_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleModuleError">ProtoParseError.MultipleModuleError</a></td><td></td><td></td></tr>
<tr><td>multiple_tydef_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleTyDefError">ProtoParseError.MultipleTyDefError</a></td><td></td><td></td></tr>
<tr><td>multiple_classdef_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleClassDefError">ProtoParseError.MultipleClassDefError</a></td><td></td><td></td></tr>
<tr><td>multiple_tyarg_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleTyArgError">ProtoParseError.MultipleTyArgError</a></td><td></td><td></td></tr>
<tr><td>multiple_constructor_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleConstructorError">ProtoParseError.MultipleConstructorError</a></td><td></td><td></td></tr>
<tr><td>multiple_field_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleFieldError">ProtoParseError.MultipleFieldError</a></td><td></td><td></td></tr>
<tr><td>multiple_import_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleImportError">ProtoParseError.MultipleImportError</a></td><td></td><td></td></tr>
<tr><td>one_of_not_set_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-OneOfNotSetError">ProtoParseError.OneOfNotSetError</a></td><td></td><td></td></tr>
<tr><td>unknown_enum_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-UnknownEnumError">ProtoParseError.UnknownEnumError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleClassDefError"></a></p>
<h3 id="protoparseerrormultipleclassdeferror"><a class="header" href="#protoparseerrormultipleclassdeferror">ProtoParseError.MultipleClassDefError</a></h3>
<p>Multiple ClassDefs with the same ClassName were found in ModuleName.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>class_defs</td><td><a href="api.html#lambdabuffers-ClassDef">lambdabuffers.ClassDef</a></td><td>repeated</td><td>Conflicting class definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleConstructorError"></a></p>
<h3 id="protoparseerrormultipleconstructorerror"><a class="header" href="#protoparseerrormultipleconstructorerror">ProtoParseError.MultipleConstructorError</a></h3>
<p>Multiple Sum Constructors with the same ConstrName were found in
ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>constructors</td><td><a href="api.html#lambdabuffers-Sum-Constructor">lambdabuffers.Sum.Constructor</a></td><td>repeated</td><td>Conflicting constructors.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleFieldError"></a></p>
<h3 id="protoparseerrormultiplefielderror"><a class="header" href="#protoparseerrormultiplefielderror">ProtoParseError.MultipleFieldError</a></h3>
<p>Multiple Record Fields with the same FieldName were found in
ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>fields</td><td><a href="api.html#lambdabuffers-Record-Field">lambdabuffers.Record.Field</a></td><td>repeated</td><td>Conflicting record fields.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleImportError"></a></p>
<h3 id="protoparseerrormultipleimporterror"><a class="header" href="#protoparseerrormultipleimporterror">ProtoParseError.MultipleImportError</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>imports</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td>repeated</td><td>Conflicting module imports.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleModuleError"></a></p>
<h3 id="protoparseerrormultiplemoduleerror"><a class="header" href="#protoparseerrormultiplemoduleerror">ProtoParseError.MultipleModuleError</a></h3>
<p>Multiple Modules with the same ModuleName were found.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="api.html#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Conflicting type definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleTyArgError"></a></p>
<h3 id="protoparseerrormultipletyargerror"><a class="header" href="#protoparseerrormultipletyargerror">ProtoParseError.MultipleTyArgError</a></h3>
<p>Multiple TyArgs with the same ArgName were found in ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>ty_args</td><td><a href="api.html#lambdabuffers-TyArg">lambdabuffers.TyArg</a></td><td>repeated</td><td>Conflicting type abstraction arguments.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleTyDefError"></a></p>
<h3 id="protoparseerrormultipletydeferror"><a class="header" href="#protoparseerrormultipletydeferror">ProtoParseError.MultipleTyDefError</a></h3>
<p>Multiple TyDefs with the same TyName were found in ModuleName.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_defs</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td>repeated</td><td>Conflicting type definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-OneOfNotSetError"></a></p>
<h3 id="protoparseerroroneofnotseterror"><a class="header" href="#protoparseerroroneofnotseterror">ProtoParseError.OneOfNotSetError</a></h3>
<p>Proto <code>oneof</code> field is not set.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>message_name</td><td><a href="api.html#string">string</a></td><td></td><td>Proto message name in which the <code>oneof</code> field is not set.</td></tr>
<tr><td>field_name</td><td><a href="api.html#string">string</a></td><td></td><td>The <code>oneof</code> field that is not set.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-UnknownEnumError"></a></p>
<h3 id="protoparseerrorunknownenumerror"><a class="header" href="#protoparseerrorunknownenumerror">ProtoParseError.UnknownEnumError</a></h3>
<p>Proto <code>enum</code> field is unknown.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>enum_name</td><td><a href="api.html#string">string</a></td><td></td><td>Proto <code>enum</code> name.</td></tr>
<tr><td>got_tag</td><td><a href="api.html#string">string</a></td><td></td><td>The unknown tag for the <code>enum</code>.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Result"></a></p>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<p>Compiler Result ~ a successful Compilation Output.</p>
<p><a name="lambdabuffers-compiler-TyClassCheckError"></a></p>
<h3 id="tyclasscheckerror"><a class="header" href="#tyclasscheckerror">TyClassCheckError</a></h3>
<p>Type class checking errors.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>unbound_class_ref_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError">TyClassCheckError.UnboundClassRefError</a></td><td></td><td></td></tr>
<tr><td>superclass_cycle_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError">TyClassCheckError.SuperclassCycleError</a></td><td></td><td></td></tr>
<tr><td>import_not_found_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError">TyClassCheckError.ImportNotFoundError</a></td><td></td><td></td></tr>
<tr><td>derive_opaque_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError">TyClassCheckError.DeriveOpaqueError</a></td><td></td><td></td></tr>
<tr><td>missing_rule_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-MissingRuleError">TyClassCheckError.MissingRuleError</a></td><td></td><td></td></tr>
<tr><td>overlapping_rules_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError">TyClassCheckError.OverlappingRulesError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError"></a></p>
<h3 id="tyclasscheckerrorderiveopaqueerror"><a class="header" href="#tyclasscheckerrorderiveopaqueerror">TyClassCheckError.DeriveOpaqueError</a></h3>
<p>In <code>module_name</code> it wasn't possible to solve <code>constraint</code> because a
<code>sub_constraint</code> has been derived on an <code>Opaque</code> type. <code>Opaque</code> type can
only have an <code>InstanceClause</code> declared for them.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError"></a></p>
<h3 id="tyclasscheckerrorimportnotfounderror"><a class="header" href="#tyclasscheckerrorimportnotfounderror">TyClassCheckError.ImportNotFoundError</a></h3>
<p>Import <code>missing</code> wasn't found in <code>module_name</code></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>missing</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-MissingRuleError"></a></p>
<h3 id="tyclasscheckerrormissingruleerror"><a class="header" href="#tyclasscheckerrormissingruleerror">TyClassCheckError.MissingRuleError</a></h3>
<p>In <code>module_name</code> while trying to solve <code>constraint</code> it wasn't possible to
find a rule (<code>Derive</code> or <code>InstanceClause</code>) for <code>sub_constraint</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError"></a></p>
<h3 id="tyclasscheckerroroverlappingruleserror"><a class="header" href="#tyclasscheckerroroverlappingruleserror">TyClassCheckError.OverlappingRulesError</a></h3>
<p>In <code>module_name</code> while trying to solve <code>constraint</code> <code>overlaps</code> (<code>Derive</code>
or <code>InstanceClause</code>) were found that could be used to solve the
<code>sub_constraint</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>overlaps</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead">TyClassCheckError.OverlappingRulesError.QHead</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead"></a></p>
<h3 id="tyclasscheckerroroverlappingruleserrorqhead"><a class="header" href="#tyclasscheckerroroverlappingruleserrorqhead">TyClassCheckError.OverlappingRulesError.QHead</a></h3>
<p>NOTE(bladyjoker): This should rather be oneof <code>Derive</code> and
<code>InstanceClause</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>head</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError"></a></p>
<h3 id="tyclasscheckerrorsuperclasscycleerror"><a class="header" href="#tyclasscheckerrorsuperclasscycleerror">TyClassCheckError.SuperclassCycleError</a></h3>
<p>Superclass cycle <code>cycled_class_refs</code> was detected when checking a
class definition for <code>class_name</code> in module <code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
<tr><td>cycled_class_refs</td><td><a href="api.html#lambdabuffers-TyClassRef">lambdabuffers.TyClassRef</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError"></a></p>
<h3 id="tyclasscheckerrorunboundclassreferror"><a class="header" href="#tyclasscheckerrorunboundclassreferror">TyClassCheckError.UnboundClassRefError</a></h3>
<p>Unbound <code>class_ref</code> detected in <code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef">lambdabuffers.TyClassRef</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="codegen-proto"></a></p>
<p align="right"><a href="api.html#top">Top</a></p>
<h2 id="codegenproto"><a class="header" href="#codegenproto">codegen.proto</a></h2>
<p><a name="lambdabuffers-codegen-Error"></a></p>
<h3 id="error-1"><a class="header" href="#error-1">Error</a></h3>
<p>Codegen Error</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>internal_errors</td><td><a href="api.html#lambdabuffers-codegen-InternalError">InternalError</a></td><td>repeated</td><td></td></tr>
<tr><td>unsupported_opaque_errors</td><td><a href="api.html#lambdabuffers-codegen-UnsupportedOpaqueError">UnsupportedOpaqueError</a></td><td>repeated</td><td></td></tr>
<tr><td>unsupported_class_errors</td><td><a href="api.html#lambdabuffers-codegen-UnsupportedClassError">UnsupportedClassError</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Input"></a></p>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<p>Codegen Input</p>
<p>Codegen Input is a fully self contained list of modules,
that have been checked by the Compiler.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="api.html#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Modules to codegen.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-InternalError"></a></p>
<h3 id="internalerror-1"><a class="header" href="#internalerror-1">InternalError</a></h3>
<p>Errors internal to the implementation.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msg</td><td><a href="api.html#string">string</a></td><td></td><td>Error message.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">lambdabuffers.SourceInfo</a></td><td></td><td>Source information if meaningful.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Output"></a></p>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<p>Codegen output.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>error</td><td><a href="api.html#lambdabuffers-codegen-Error">Error</a></td><td></td><td></td></tr>
<tr><td>result</td><td><a href="api.html#lambdabuffers-codegen-Result">Result</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Result"></a></p>
<h3 id="result-1"><a class="header" href="#result-1">Result</a></h3>
<p>Codegen Result ~ a successful Codegen Output.</p>
<p><a name="lambdabuffers-codegen-UnsupportedClassError"></a></p>
<h3 id="unsupportedclasserror"><a class="header" href="#unsupportedclasserror">UnsupportedClassError</a></h3>
<p>Unsupported <code>Class</code> error for a class <code>class_name</code> defined in module
<code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-UnsupportedOpaqueError"></a></p>
<h3 id="unsupportedopaqueerror"><a class="header" href="#unsupportedopaqueerror">UnsupportedOpaqueError</a></h3>
<p>Unsupported <code>Opaque</code> error for a type <code>ty_name</code> defined in module
<code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_name</td><td><a href="api.html#lambdabuffers-TyName">lambdabuffers.TyName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="scalar-value-types"><a class="header" href="#scalar-value-types">Scalar Value Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>.proto Type</th><th>Notes</th><th>C++</th><th>Java</th><th>Python</th><th>Go</th><th>C#</th><th>PHP</th><th>Ruby</th></tr></thead><tbody>
<tr><td><a name="double" /> double</td><td></td><td>double</td><td>double</td><td>float</td><td>float64</td><td>double</td><td>float</td><td>Float</td></tr>
<tr><td><a name="float" /> float</td><td></td><td>float</td><td>float</td><td>float</td><td>float32</td><td>float</td><td>float</td><td>Float</td></tr>
<tr><td><a name="int32" /> int32</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="int64" /> int64</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="uint32" /> uint32</td><td>Uses variable-length encoding.</td><td>uint32</td><td>int</td><td>int/long</td><td>uint32</td><td>uint</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="uint64" /> uint64</td><td>Uses variable-length encoding.</td><td>uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>ulong</td><td>integer/string</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sint32" /> sint32</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sint64" /> sint64</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="fixed32" /> fixed32</td><td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td><td>uint32</td><td>int</td><td>int</td><td>uint32</td><td>uint</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="fixed64" /> fixed64</td><td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td><td>uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>ulong</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="sfixed32" /> sfixed32</td><td>Always four bytes.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sfixed64" /> sfixed64</td><td>Always eight bytes.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="bool" /> bool</td><td></td><td>bool</td><td>boolean</td><td>boolean</td><td>bool</td><td>bool</td><td>boolean</td><td>TrueClass/FalseClass</td></tr>
<tr><td><a name="string" /> string</td><td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td><td>string</td><td>String</td><td>str/unicode</td><td>string</td><td>string</td><td>string</td><td>String (UTF-8)</td></tr>
<tr><td><a name="bytes" /> bytes</td><td>May contain any arbitrary sequence of bytes.</td><td>string</td><td>ByteString</td><td>str</td><td>[]byte</td><td>ByteString</td><td>string</td><td>String (ASCII-8BIT)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-frontend-lbf-syntax"><a class="header" href="#lambdabuffers-frontend-lbf-syntax">LambdaBuffers Frontend (.lbf) syntax</a></h1>
<p>The input to the LambdaBuffers Frontend is a text file which contains a module that defines a specification of the types and type class instances you want to generate. This chapter gives the exact syntax of a LambdaBuffers Frontend file, and informally describes meaning of the syntactic constructs.</p>
<p>The name of a LambdaBuffers Frontend file must end with <code>.lbf</code>, and hence may also be referred to as a .lbf file or a .lbf schema.</p>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<p>In the following description of a LambdaBuffers Frontend file's syntax, we use a similar BNF syntax from <a href="https://www.haskell.org/onlinereport/haskell2010/">Section 10.1 of the Haskell Report</a>. So, the following notational conventions are used for presenting syntax.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody>
<tr><td><code>[pattern]</code></td><td>optional</td></tr>
<tr><td><code>{pattern}</code></td><td>zero or more repetitions</td></tr>
<tr><td><code>(pattern)</code></td><td>grouping</td></tr>
<tr><td><code>pat1⎮pat2</code></td><td>choice</td></tr>
<tr><td><code>pat1\pat2</code></td><td>difference -- elements generated by <code>pat1</code> except those generated by <code>pat2</code></td></tr>
<tr><td><code>'terminal'</code></td><td>terminal syntax surrounded by single quotes</td></tr>
</tbody></table>
</div><!-- Apparently, `mdbook`'s markdown can't escape the vertical bar in codeblocks in a table....
     So, we're using code point U+23AE to look like a vertical bar when it really isn't...

| `pat1|pat2`  | choice                                                                      | 
-->
<p>Note that the terminal syntax permits C-style escape sequences e.g. <code>'\n'</code> denotes line feed (newline), and <code>'\r'</code> denotes carriage return.</p>
<p>Productions will be of the form:</p>
<pre><code class="language-text">nonterm -&gt; alt1 | ... | altn
</code></pre>
<h2 id="input-file-representation"><a class="header" href="#input-file-representation">Input file representation</a></h2>
<p>The input file is Unicode text where the encoding is subject to the system locale. We will often use the unqualified term <em>character</em> to refer to a Unicode code point in the input file.</p>
<h2 id="characters"><a class="header" href="#characters">Characters</a></h2>
<p>The following terms are used to denote specific Unicode character categories:</p>
<ul>
<li>
<p><code>upper</code> denotes a Unicode code point categorized as an uppercase letter or titlecase letter (i.e., with General Category value Lt or Lu).</p>
</li>
<li>
<p><code>lower</code> denotes a Unicode code point categorized as a lower-case letter (i.e., with General Category value Ll).</p>
</li>
<li>
<p><code>alphanum</code> denotes either <code>upper</code> or <code>lower</code>; or a Unicode code point categorized as a modifier letter, other letter, decimal digit number, letter number, or other number (i.e., with General Category value Lt, Lu, Ll, Lm, Lo, Nd, Nl or No).</p>
</li>
<li>
<p><code>space</code> denotes a Unicode code point categorized as a separator space (i.e., with General Category value Zs), or any of the control characters <code>'\t'</code>, <code>'\n'</code>, <code>'\r'</code>, <code>'\f'</code>, or <code>'\v'</code>.</p>
</li>
</ul>
<p>Interested readers may find details of Unicode character categories in <a href="https://www.unicode.org/versions/Unicode15.1.0/">Section 4.5 of The Unicode Standard 15.1.0</a>, and the <a href="https://unicode.org/ucd/">Unicode Character Database</a>.</p>
<h2 id="lexical-syntax"><a class="header" href="#lexical-syntax">Lexical syntax</a></h2>
<p>Tokens form the vocabulary of LambdaBuffers Frontend files. The classes of tokens are defined as follows.</p>
<pre><code class="language-text">keyword         -&gt; 'module' | 'sum' | 'prod' | 'record'
                 | 'opaque' | 'class' | 'instance' | 'import' 
                 | 'qualified' | 'as'
modulename      -&gt; uppercamelcase
longmodulename  -&gt; modulealias modulename
typename        -&gt; uppercamelcase
fieldname       -&gt; lowercamelcase\keyword
longtypename    -&gt; modulealias typename
varname         -&gt; lowers\keyword
punctuation     -&gt; '&lt;=' | ',' | '(' | ')' | '{' | '}' 
                 | ':' | ':-' | '=' | '|'
classname       -&gt; uppercamelcase
longclassname   -&gt; modulealias uppercamelcase
</code></pre>
<p>where</p>
<pre><code class="language-text">uppercamelcase -&gt; upper { alphanum }
lowercamelcase -&gt; lower { alphanum }
modulealias    -&gt; { uppercamelcase '.' }
lowers         -&gt; lower { lower }
</code></pre>
<p>Input files are broken into <em>tokens</em> which use the <em>maximal munch</em> rule i.e., at each point, the next token is the longest sequence of characters that form a valid token. <code>space</code>s or line comments are ignored except as it separates tokens that would otherwise combine into a single token.</p>
<h3 id="line-comments"><a class="header" href="#line-comments">Line comments</a></h3>
<p>A <em>line comment</em> starts with the terminal <code>'--'</code> followed by zero or more printable Unicode characters stopping at the first end of line (<code>'\n'</code> or <code>'\r\n'</code>).</p>
<h2 id="syntax-of-lambdabuffers-frontend-files"><a class="header" href="#syntax-of-lambdabuffers-frontend-files">Syntax of LambdaBuffers Frontend files</a></h2>
<p>A LambdaBuffers Frontend file defines a module that is a collection of data types, classes, instance clauses, and derive clauses.</p>
<p>The overall layout of a LambdaBuffers Frontend file is:</p>
<pre><code class="language-text">module -&gt; 'module' longmodulename { import } { statement }
</code></pre>
<p>The file must specify the module's <code>longmodulename</code> where its <code>modulename</code> must match the LambdaBuffers Frontend file's file name not including the <code>.lbf</code> extension.
After, the file may contain a sequence of <code>import</code>s followed by a sequence of <code>statement</code>s.</p>
<h3 id="import"><a class="header" href="#import">Import</a></h3>
<p>Imports bring <em>entities</em> (types and classes) of other modules into scope.</p>
<pre><code class="language-text">import     -&gt; 'import' [ 'qualified' ] longmodulename [ 'as' longmodulename ] [ importspec ]
importspec -&gt; '(' [ { typename ',' } typename [','] ] ')'
</code></pre>
<p>If <code>importspec</code> is omitted, then all entities specified in the module are imported; otherwise only the specified entities are imported.</p>
<h3 id="statement"><a class="header" href="#statement">Statement</a></h3>
<p>Statements define types, classes, instance clauses, and derive clauses.</p>
<pre><code class="language-text">statement -&gt; typedef
           | classdef
           | instanceclause
           | deriveclause
</code></pre>
<h4 id="type-definitions"><a class="header" href="#type-definitions">Type definitions</a></h4>
<p>Types may be either sum types, product types, record types, or opaque types.</p>
<pre><code class="language-text">typedef -&gt; prodtypedef | sumtypedef |  recordtypedef | opaquetypedef
</code></pre>
<h5 id="product-type-definition"><a class="header" href="#product-type-definition">Product type definition</a></h5>
<p>A product type definition defines a new product type.</p>
<pre><code class="language-text">prodtypedef -&gt; 'prod' typename { varname } '=' prod
prod        -&gt; { typeexp }
typeexp     -&gt; varname
             | longtypename
             | '(' prod ')'
</code></pre>
<p>Product type definitions instruct the code generator to generate a product type for the target language.</p>
<h5 id="sum-type-definition"><a class="header" href="#sum-type-definition">Sum type definition</a></h5>
<p>A sum type definition defines a new sum type.</p>
<pre><code class="language-text">sumtypedef     -&gt; 'sum' typename { varname } '=' sum
sum            -&gt; sumconstructor { '|' sumconstructor }
sumconstructor -&gt; typename prod
</code></pre>
<p>Sum type definitions instruct the code generator to generate a sum type for the target language.</p>
<h5 id="record-type-definition"><a class="header" href="#record-type-definition">Record type definition</a></h5>
<p>A record type definition defines a new record type.</p>
<pre><code class="language-text">recordtypedef -&gt; 'record' typename { varname } '=' record
record        -&gt; '{' [ field { ',' field  } ] '}'
field         -&gt; fieldname ':' prod
</code></pre>
<p>Record type definitions instruct the code generator to generate a record type for the target language.</p>
<h5 id="opaque-type-definition"><a class="header" href="#opaque-type-definition">Opaque type definition</a></h5>
<p>An opaque type definition defines a new opaque type.</p>
<pre><code class="language-text">opaquetypedef -&gt; 'opaque' typename { varname }
</code></pre>
<p>Opaque type definitions must map to existing types in the target language and it's up to the Codegen module to determine how that's exactly done.</p>
<h4 id="class-definition"><a class="header" href="#class-definition">Class definition</a></h4>
<p>A class definition introduces a new class.</p>
<pre><code class="language-text">classdef       -&gt; 'class' [ constraintexps '&lt;=' ] classname { varname }
constraintexp  -&gt; longclassname { varname }
                | '(' constraintexps ')'
constraintexps -&gt; [ constraintexp { ',' constraintexp } ]
</code></pre>
<p>Class definitions communicate with the code generator the implementations that already exist (via instance clauses) or that one would like to generate (via derive clauses).</p>
<h4 id="instance-clause"><a class="header" href="#instance-clause">Instance clause</a></h4>
<p>An instance clause specifies a type is an instance of a class.</p>
<pre><code class="language-text">instanceclause -&gt; 'instance'  constraint [ ':-' constraintexps ]
constraint     -&gt; longclassname { typeexp }
</code></pre>
<p>Instance clauses do not instruct the code generator to generate code, but instead instructs the compiler (semantic checking) that the target language environment provides type class implementations for the given type (provided that the given <code>constraintexps</code> also have implementations).</p>
<h4 id="derive-clause"><a class="header" href="#derive-clause">Derive clause</a></h4>
<p>Derive clauses instruct the code generator to generate code for a type so that it is an instance of a class.</p>
<pre><code class="language-text">deriveclause -&gt; 'derive' constraint
</code></pre>
<p>Note the code generation of a type for a class is implemented via builtin derivation rules (which developers may extend).</p>
<h3 id="syntax-reference"><a class="header" href="#syntax-reference">Syntax reference</a></h3>
<p>The summarized productions of a LambdaBuffers Frontend file is as follows.</p>
<pre><code class="language-text">module -&gt; 'module' longmodulename { import } { statement }

import     -&gt; 'import' [ 'qualified' ] longmodulename [ 'as' longmodulename ] [ importspec ]
importspec -&gt; '(' [ { typename ',' } typename [','] ] ')'

statement -&gt; typedef
           | classdef
           | instanceclause
           | deriveclause

typedef -&gt; prodtypedef | sumtypedef |  recordtypedef | opaquetypedef

prodtypedef -&gt; 'prod' typename { varname } '=' prod
prod        -&gt; { typeexp }
typeexp     -&gt; varname
             | longtypename
             | '(' prod ')'

sumtypedef     -&gt; 'sum' typename { varname } '=' sum
sum            -&gt; sumconstructor { '|' sumconstructor }
sumconstructor -&gt; typename prod

recordtypedef -&gt; 'record' typename { varname } '=' record
record        -&gt; '{' [ field { ',' field  } ] '}'
field         -&gt; fieldname ':' prod

opaquetypedef -&gt; 'opaque' typename { varname }

classdef       -&gt; 'class' [ constraintexps '&lt;=' ] classname { varname }
constraintexp  -&gt; longclassname { varname }
                | '(' constraintexps ')'
constraintexps -&gt; [ constraintexp { ',' constraintexp } ]

instanceclause -&gt; 'instance'  constraint [ ':-' constraintexps ]
constraint     -&gt; longclassname { typeexp }

deriveclause -&gt; 'derive' constraint
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-compiler"><a class="header" href="#lambdabuffers-compiler">LambdaBuffers Compiler</a></h1>
<p>The <em>Compiler</em> component sits between the <em>Frontend</em> component and the code
generation component named <em>Codegen</em>. The purpose of the <em>Compiler</em> is to
perform various checks on the <a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-CompilerInput">Compiler
input</a>
provided by the <em>Frontend</em> ensuring that supplied type, class and instance
clause definitions are valid or otherwise communicate any error conditions
determined during processing.</p>
<p>The end goal of the <em>Compiler</em> is to ensure that the <em>Codegen</em> component is
capable of processing the <em>Compiler Output</em> by providing correct and complete
information.</p>
<h2 id="compiler-interface"><a class="header" href="#compiler-interface">Compiler Interface</a></h2>
<p>The <em>Compiler</em> operates on the <em>Compiler Input</em> message specified in the
<a href="../lambda-buffers-proto/compiler.proto">compiler.proto</a> <a href="https://protobuf.dev/">Google Protocol
Buffers</a> schema - enabling, any <em>Frontend</em> to interface
with the <em>Compiler</em> in a language agnostic manner.</p>
<p>Similarly, the <em>Compiler Output</em> message is also specified in the
<a href="../lambda-buffers-proto/compiler.proto">compiler.proto</a> <a href="https://protobuf.dev/">Google Protocol
Buffers</a> schema that is then consumed by <em>Codegen</em>
modules, able to be written in any programming environment capable of
communicating via <a href="https://protobuf.dev/">Google Protocol Buffers</a>.</p>
<p>Refer to the <a href="../lambda-buffers-proto/compiler-proto.html">Compiler Proto
documentation</a> for more information.</p>
<h2 id="checking-type-definitions"><a class="header" href="#checking-type-definitions">Checking Type Definitions</a></h2>
<p>The first step the Compiler performs is <em>kind checking and inference</em> on <a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-TyDef">type
definitions</a>
provided by the <em>Frontend</em> and otherwise raises <a href="compiler.html#missing-link">kind checking errors</a>.</p>
<p>When successful, the Compiler outputs a <a href="compiler.html#missing-link">Compiler Output</a> that
annotates each <a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-Ty">type
term</a> with
<a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-Kind">kind</a>
information.</p>
<p>In standard <em>type checking</em> terminology LambdaBuffers 'terms' are <a href="https://en.wikipedia.org/wiki/Abstract_data_type">abstract data
type</a> declarations and their
'types' are <em>kinds</em>.</p>
<p>Currently, the <em>Compiler</em> accepts:</p>
<ol>
<li>
<p>type terms of kind <code>Type</code> (such as <code>Int</code> or <code>Bool</code>),</p>
</li>
<li>
<p>type function terms of kind <code>Type → Type</code> (such as <code>Maybe</code> or <code>Either</code> -
though note that type functions are not "first class" in the sense that they
cannot be passed as arguments to other type functions).</p>
</li>
</ol>
<p>There are future plans to expand this to Higher Kinded Types (such as <code>MaybeT</code>,
<code>StateT</code> etc - i.e. types parameterized on type function terms) - subject to
research into <em>Codegen</em> of such types in the target languages.</p>
<p>The <em>Compiler</em> supports recursive types.</p>
<p>All LambdaBuffers <a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-TyArg">type
variables</a>
terms must be monomorphically kinded, with polymorphic kinds defaulting to
monomorphic ones. For example <code>Phantom a = Phantom</code> would resolve to the
monomorphic kind <code>Type → Type</code> rather than the polymorphic kind <code>∀a. a → Type</code>.</p>
<h3 id="kind-checker"><a class="header" href="#kind-checker">Kind Checker</a></h3>
<p>The kind checker is designed around a simply typed lambda calculus type system
with inference via unification (<em>John Alan Robinson's</em> unification algorithm is
being currently used). We've also introduced a <code>let</code> binding rule that allows
later additions to the typing context. The typing rules are the following:</p>
<pre><code class="language-text"> x : σ ∈ Γ
----------- [Variable]
 Γ ⊢ x : σ


      Γ,x:σ ⊢ e:τ
------------------------ [Abstraction]
 Γ ⊢ (λ x:σ. e):(σ → τ)


Γ ⊢ x:(σ → τ)    Γ ⊢ y:σ
------------------------- [Application]
       Γ ⊢ x y : τ


Γ ⊢ e₁:σ    Γ, e₁ : σ ⊢ e₂:τ
----------------------------- [Let]
   Γ ⊢ let x = e₁ in e₂ : τ
</code></pre>
<p>The type checking strategy is as follows:</p>
<ol>
<li>
<p>A context is built from the type definitions. Type variables which are not
annotated with any further kind information are defaulted to be of kind
<code>Type</code>.</p>
</li>
<li>
<p>The RHS of the type terms are converted into their <em>Sums of Products</em>
canonical representation. The variables from the left hand side of the term
are introduced to the right hand side as abstractions.</p>
</li>
<li>
<p>The derivation for each term is built.</p>
</li>
<li>
<p>Then the unification tries to find a solution.</p>
</li>
</ol>
<p>Terms for which unification cannot find a consistent derivation are deemed
incorrect and a kind checking error is thrown. Note that currently all of the
inferred kinds have a restriction to be monomorphic - therefore no free or
universally quantified variables can appear in the final kind signature.</p>
<h2 id="checking-type-cardinality"><a class="header" href="#checking-type-cardinality">Checking Type Cardinality</a></h2>
<p>In addition to <em>kind checking</em>, the Compiler could perform a special check for
types to determine their cardinality. This is especially useful to catch and
report on <em>non inhabited</em> types that users might define.</p>
<p>For example, <code>data F a = F (F a)</code> declares a <em>non-inhabited recursive type</em> that
can't be constructed. LambdaBuffers Compiler <em>SHOULD</em> reject such types as they
can't possibly be constructed and generated typeclass instances would in turn be
ill-defined.</p>
<p>This problem is equivalent to a problem of <a href="https://en.wikipedia.org/wiki/Component_(graph_theory)">calculating graph
components</a>.</p>
<h2 id="normalizing-type-definitions"><a class="header" href="#normalizing-type-definitions">Normalizing Type Definitions</a></h2>
<p>Finally, the compiler should be able to <em>normalize</em> expressions. For example, it
may be possible to define a data type in the schema language in a form similar
to: <code>data G a = G ((Either) ((Maybe) a) Int)</code>, where the bracketing indicates
the order of application within the term. The example term would normalize to
<code>data G a = G (Either (Maybe a) Int)</code> - resulting in a cleaner (and more
performant) code generation.</p>
<h2 id="checking-typeclass-definitions-and-instance-clauses"><a class="header" href="#checking-typeclass-definitions-and-instance-clauses">Checking Typeclass Definitions and Instance Clauses</a></h2>
<p>The <em>Compiler</em> should, if possible, ensure that all instance declarations for
schemata are derivable using hard-coded derivation axioms.</p>
<p>Other schema languages support generating type definitions in many languages
from a single definition in the schema language. One key feature that sets
LambdaBuffers apart from these alternatives is support for
<a href="https://en.wikipedia.org/wiki/Type_class"><em>typeclasses</em></a>, which enable the
generation of <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">ad-hoc polymorphic
functions</a> that operate on
types generated from LambdaBuffers schemata.</p>
<p>The LambdaBuffers schema language doesn't allow users to specify typeclass instance
implementations themselves. Users, instead, will write <em>instance clauses</em> as
part of the schema definition, and the LambdaBuffers code generator will derive
these declared instances when generating code.</p>
<p>Two important consequences of this design decision are:</p>
<ol>
<li>
<p><em>All instances must be derived structurally</em>. As an example, consider the
arbitrary product type <code>data P a b = P a b</code>. The semantics of the generated
instance (i.e. the behavior of the generated code) must be determinable from the
<em>structure of the type</em> - that it is a product - and the instances for its
arguments <code>a</code> and <code>b</code>, and by those features alone. (Since <code>a</code> and <code>b</code> are type
variables here, writing a direct instance for any interesting class is likely
impossible, so LambdaBuffers supports constrained instances such as <code>instance (C a, C b) =&gt; C (P a b)</code>)</p>
</li>
<li>
<p><em>All instances must be uniform across supported languages</em>. Because the
LambdaBuffers <em>Codegen</em> component (and <em>not</em> the user) is responsible for
generating instances, we must ensure that the codegen component is suitably
equipped to generate instances in each language that exhibit behavior which is,
to the greatest extent possible, equivalent to the behavior of generated
instances in any other language. We <em>must</em> have an extensive test quite to
verify uniform behavior of generated instances.</p>
</li>
</ol>
<p>In languages with a typeclass system (Haskell, PureScript) or equivalent (Rust's
Traits), we will utilize the existing system and <em>should</em> (to the extent that
doing so is feasible) utilize existing typeclasses and instances from commonly
used or standard libraries. In languages lacking a type system that is
sufficiently rich to express typeclass relations, we will generate instances
using idiomatic language features. (The details will depend on the particular
language.)</p>
<h2 id="missing-link"><a class="header" href="#missing-link">Missing link</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-codegen"><a class="header" href="#lambdabuffers-codegen">LambdaBuffers Codegen</a></h1>
<p>NOTE: The implementation of the code generation framework is still in early
stages and will likely undergo substantial changes as development
continues. This document serves to outline general principles that any
implementation of the LambdaBuffers code generation framework ought to adhere
to.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ol>
<li>Modular &amp; reusable components</li>
<li>Ergonomic interface</li>
<li>Extensible to new opaque types</li>
<li>Extensible to new type classes</li>
</ol>
<h3 id="modular--reusable-components"><a class="header" href="#modular--reusable-components">Modular &amp; Reusable Components</a></h3>
<p>Because the code generation modules for each target language will almost
certainly constitute the bulk of the final LambdaBuffers codebase, it is
essential that components of the code generation framework be as modular and
reusable as is practicable.</p>
<p>Although each target language has its own distinct syntax and semantics, many
syntactic forms exist in multiple target languages. For example, Haskell and
PureScript both use a comma-separated set enclosed in square brackets
(e.g. <code>[1,2,3]</code>) to represent a <code>List _/[_]</code> value, while Rust uses a similar
form (in conjunction with a macro, e.g. <code>vec![1,2,3]</code>) to represent a
<code>Vector&lt;_&gt;</code> value. To reduce redundant and superfluous code, common syntactic
patterns such at this should be abstracted out into a set of functions that can
be reused across languages.</p>
<h3 id="ergonomic-interface"><a class="header" href="#ergonomic-interface">Ergonomic Interface</a></h3>
<p>While the LambdaBuffers team will support a finite set of specific target
languages, adding support for an additional language should be as painless as
possible (ceteris paribus) to encourage and facilitate open source contributions
by third parties. A basic set of tools which can be used to write code
generation modules for any target language should be developed, and all code
generation modules written by the LambdaBuffers team should employ those tools
(in order to provide a robust set of examples for future contributors, among
other benefits).</p>
<h3 id="extensible-to-new-opaque-types"><a class="header" href="#extensible-to-new-opaque-types">Extensible to New Opaque Types</a></h3>
<p>Users and contributors should be able to easily extend the default set of
supported opaque types to support additional opaque types. In the context of
code generation, this means: Users should have the ability to specify the target
type for a given opaque type in the target language (including the package or
module that contains the target type if the target type is not part of the
language's standard library).</p>
<p>Because type class instances must be derived structurally, and because an opaque
type is by definition a type with no visible internal structure, users should be
provided with an ergonomic interface for noting the presence of a type class
instance for an opaque type's target type in a particular language (if the
instance exists in the standard library), or for referring to the module where
such an instance is located (if the instance is defined in a library or by the
user in one of their own modules).</p>
<h3 id="extensible-to-new-type-classes"><a class="header" href="#extensible-to-new-type-classes">Extensible to New Type Classes</a></h3>
<p>Users and contributors should be able to easily extend the default set of
supported type classes to support additional type classes and facilitate the
derivation of instances for newly defined classes.</p>
<p>In practice, the type class code generation machinery must consist of two
distinct parts: First, a set of deriving rules which correspond to instances
that already exist (in some module or in a language's standard
library/prelude). Second, code generation functions that operate on user-defined
types which satisfy those rules.</p>
<p>Each of these parts should be ergonomic, well-documented, and the implementation
of the default set of supported type classes ought to be thoroughly commented in
order that users have a diverse set of real examples to work from.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-command-line-interface"><a class="header" href="#lambdabuffers-command-line-interface">LambdaBuffers Command Line Interface</a></h1>
<p>LambdaBuffers consists of three runtime command line interface components:</p>
<ul>
<li><a href="lambda-buffers-frontend-cli">lambda-buffers-frontend-cli</a></li>
<li><a href="lambda-buffers-compiler-cli">lambda-buffers-compiler-cli</a></li>
<li><a href="todo-link">lambda-buffers-codegen-cli</a></li>
</ul>
<p>The <em>Frontend</em> CLI orchestrates work between the user and the <em>Compiler</em> and
<em>Codegen</em> components.</p>
<p>It's desirable to have both the <em>Compiler</em> CLI and the <em>Codegen</em> CLI subject to
a strict API with a specified set of flags to enable CLI implementation from
various sources. This would be especially helpful with <em>Codegen</em> modules that
bring about support for new targets, opaque types and typeclasses.</p>
<!-- TODO(bladyjoker): Complete this chapter -->
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file -->
<h1 id="comparison-matrix"><a class="header" href="#comparison-matrix">Comparison Matrix</a></h1>
<p>Legend:</p>
<ul>
<li>🟢 Available (grading added in some cases spanning: Bad, Average, Good, Excellent)</li>
<li>🟡 In development</li>
<li>🔵 Potential future feature</li>
<li>🔴 Not currently available</li>
<li>❔ Not clear</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th><strong>Feature</strong></th><th><strong>Proto Buffers</strong></th><th><strong>ADL</strong></th><th><strong>JSON Schema</strong></th><th><strong>Lambda Buffers</strong></th><th><strong>CDDL</strong></th><th><strong>ASN.1</strong></th></tr></thead><tbody>
<tr><td>Sum types</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>🟢</td></tr>
<tr><td>Record types</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td></tr>
<tr><td>Product types</td><td>🔴</td><td>🔴</td><td>🔴</td><td>🟢</td><td>❔</td><td>🔴</td></tr>
<tr><td>Recursive types</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>❔</td></tr>
<tr><td>Parameterized types (generic types)</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>🔴</td></tr>
<tr><td>Type annotations/constraints</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🔵</td><td>🟢</td><td>🟢</td></tr>
<tr><td>Add new builtin types</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Add new type semantics (e.g. different encodings)</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🟢</td></tr>
<tr><td>Manage type semantics (at language level)</td><td>🔴</td><td>🔴</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Codegen support</td><td>🟢 (Excellent)</td><td>🟢 (Average)</td><td>🟢 (Excellent)</td><td>🟡</td><td>🟢 (Bad)</td><td>🟢 (Average)</td></tr>
<tr><td>DevOps tooling - build system integration</td><td>🟢</td><td>🔴</td><td>❔</td><td>🟡</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Documentation tooling</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🔵</td><td>🔴</td><td>❔</td></tr>
<tr><td>Formatting, linting, and development environment tools</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Language checker API</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Codegen API</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Language specification</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td></tr>
<tr><td>Backwards compatibility strategy</td><td>🟢</td><td>🔴</td><td>🔴</td><td>🔴</td><td>🔴</td><td>🔴</td></tr>
</tbody></table>
</div>
<h2 id="descriptions"><a class="header" href="#descriptions">Descriptions</a></h2>
<h3 id="sum-types-4"><a class="header" href="#sum-types-4">Sum Types</a></h3>
<p>Types of the form <code>Time = Present | Past | Future</code>, which allow a type do be
constructed by one of many variants. Think Rust's <code>enums</code>.</p>
<h3 id="product-types-4"><a class="header" href="#product-types-4">Product Types</a></h3>
<p>Types of the form <code>Person = MkPerson Age Name</code>, where <code>MkPerson</code> is of Kind
<code>Type-&gt;Type-&gt;Type</code>. Product types combine multiple elements into one data type
without tagging the elements.</p>
<h3 id="record-types-4"><a class="header" href="#record-types-4">Record Types</a></h3>
<p>Types of the form <code>Person = MkPerson { age :: Age, name :: Name }</code>. Record types
are similar to <code>structs</code> in most programming languages.</p>
<h3 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h3>
<p>Recursive types are defined by the presence of the LHS type in its RHS
definition. A classic example is:</p>
<pre><code class="language-text">List a = Nil | Cons a (List a)
^^^^^^                 ^^^^^^
</code></pre>
<h3 id="parameterized-types-generics"><a class="header" href="#parameterized-types-generics">Parameterized Types (Generics)</a></h3>
<p>Type functions allow for the introduction of type variables in the LHS definition
of the term - creating a parametrised type definition. The classic example is
<code>Maybe a</code> which is the equivalento of <code>Option &lt;A&gt;</code> in rust:</p>
<pre><code class="language-text">Maybe a = Nothing | Just a
</code></pre>
<p>Using the above type definition we can now define another type that uses <code>Maybe</code>
and instantiates it to use <code>Integer</code></p>
<pre><code class="language-text">Time_Saved_via_LambdaBuffers = Maybe Integer
</code></pre>
<h3 id="type-annotations--constraints"><a class="header" href="#type-annotations--constraints">Type Annotations / Constraints</a></h3>
<p>There exists a system of constraining or further annotating types - enriching
the type's specification.</p>
<h3 id="add-new-built-in-types"><a class="header" href="#add-new-built-in-types">Add New Built-in Types</a></h3>
<p>Refer to <a href="design.html#extensible-to-new-types">design document</a>.</p>
<h3 id="add-new-type-semantics"><a class="header" href="#add-new-type-semantics">Add New Type Semantics</a></h3>
<p>Refer to the <a href="design.html#extensible-to-new-semantics">design document</a>.</p>
<h3 id="manage-type-semantics-at-language-level"><a class="header" href="#manage-type-semantics-at-language-level">Manage Type Semantics (at Language Level)</a></h3>
<p>Refer to the <a href="design.html#expressive-semantics-annotation">design document</a>..</p>
<h3 id="codegen-support"><a class="header" href="#codegen-support">Codegen Support</a></h3>
<p>Codegen support relates to the language being able to generate types for other
programming languages.</p>
<h3 id="devops-tooling---build-system-integration"><a class="header" href="#devops-tooling---build-system-integration">DevOps Tooling - Build System Integration</a></h3>
<p>The framework/language provides a seamless way of integrating with normal build
tools and systems (eg. Bazel, Nix, etc.).</p>
<h3 id="documentation-tooling"><a class="header" href="#documentation-tooling">Documentation Tooling</a></h3>
<p>The language can generate human readable documentation in an easy to share and
view format. For example HTML, or Markdown.</p>
<h3 id="formatting-linting-and-development-environment-tools"><a class="header" href="#formatting-linting-and-development-environment-tools">Formatting, Linting, and Development Environment Tools</a></h3>
<p>Tools that allow formatting, linting, and automating standardisation of the
language specific files.</p>
<h3 id="language-checker-api"><a class="header" href="#language-checker-api">Language Checker API</a></h3>
<p>The language checker component exposes an API to interface with itself in a
language agnostic manner.</p>
<h3 id="codegen-api"><a class="header" href="#codegen-api">Codegen API</a></h3>
<p>The language codegen component exposes an API to interface with itself in a
language agnostic manner.</p>
<h3 id="language-specification"><a class="header" href="#language-specification">Language Specification</a></h3>
<p>There exists a well defined language specification document.</p>
<h3 id="backwards-compatibility-strategy"><a class="header" href="#backwards-compatibility-strategy">Backwards Compatibility Strategy</a></h3>
<p>The language makes certain backwards compatibility guarantees between versions of
the same type definition.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>https://json-schema.org/implementations.html</li>
<li>https://www.rfc-editor.org/rfc/rfc8610</li>
<li>https://github.com/timbod7/adl</li>
<li>https://www.itu.int/en/ITU-T/asn1/Pages/introduction.aspx</li>
<li>https://protobuf.dev/</li>
<li>https://github.com/dcSpark/cddl-codegen</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-buffers-aiken-research-document"><a class="header" href="#lambda-buffers-aiken-research-document">Lambda Buffers: Aiken Research Document</a></h1>
<p>The Lambda Buffers team has deeply researched the Aiken programming language with the intention to find a technical path to integrate it with Lambda Buffers along the already integrated languages Plutus, Haskell, Rust and JavaScript.
The conclusion of this research phase is that, while it would be indeed possible for Lambda Buffers to provide limited support for Aiken, it would result in a poor user experience that would be in conflict with the major language features of Aiken or in conflict with the key functionalities provided by Lambda Buffers.
This document presents in detail the challenges found and its impact on the feasibility or convenience to undertake the Aiken integration.</p>
<h2 id="aiken-limitations"><a class="header" href="#aiken-limitations">Aiken limitations</a></h2>
<p>This section describes limitations with Aiken.</p>
<p>All testing / observations with Aiken were done with the following version.</p>
<pre><code class="language-bash">$ aiken --version
aiken v1.0.28-alpha+c9a1519
</code></pre>
<h3 id="aiken-has-no-type-class-support"><a class="header" href="#aiken-has-no-type-class-support">Aiken has no type class support</a></h3>
<p>A key feature of Lambda Buffers is to provide both types and type class instances.
Aiken has no support for type classes, so one must generate the type class system themselves.
In other words, one must provide:</p>
<ul>
<li>
<p>A calling convention for functions with type classes.</p>
</li>
<li>
<p>Functions to create instance dictionaries for instances of the type class.</p>
</li>
</ul>
<p>The former is straightforward to implement.
One can explicit pass an instance dictionary for each function that requires a type class as per the usual compilation of type class code to type class free code.</p>
<p>The latter requirement poses troubles for Aiken.
Aiken does not allow one to create instance dictionaries (product types of the instance's methods) since composite types in Aiken cannot contain a function type.</p>
<p>For example, the following Aiken type</p>
<pre><code class="language-ruost">type EqDict&lt;a&gt; {
    eq: fn(a,a) -&gt; Bool, 
    neq: fn(a,a) -&gt; Bool, 
}
</code></pre>
<p>would produce an error as follows.</p>
<pre><code class="language-bash">$ aiken build
    Compiling me/package 0.0.0 (/aikentest/package)
    Compiling aiken-lang/stdlib 1.8.0 (/aikentest/package/build/packages/aiken-lang-stdlib)
        Error aiken::check::illegal::function_in_type

  × While trying to make sense of your code...
  ╰─▶ I found a type definition that has a function type in it. This is not allowed.

   ╭─[/aikentest/package/validators/myvalidator.ak:3:1]
 3 │ type EqDict&lt;a&gt; {
 4 │     eq: fn(a,a) -&gt; Bool,
   ·     ───────────────────
 5 │     neq: fn(a,a) -&gt; Bool,
   ╰────
  help: Data-types can't hold functions. If you want to define method-like functions, group the type definition and the methods under a common namespace in a standalone
        module.

      Summary 1 error, 0 warnings
</code></pre>
<p>This makes it impossible to pass instance dictionaries via Aiken's builtin types for type classes.</p>
<p>Alternatively, one could try to sidestep Aiken's builtin types by creating a type which is a Church encoded tuple
(i.e., implementing a tuple type via function types),
but doing so requires higher ranked types which again Aiken does not support.
Moreover, it appears that Aiken does not provide any "back doors" to the type system (e.g. TypeScript's <code>any</code> type) to trick the type system that using a Church encoded tuple and its projections are well typed.</p>
<p>It's clear now that having an explicit type for an instance dictionary is not feasible in Aiken,
so owing to the fact that an instance dictionary is a product type of functions, one can achieve type classes via dictionary passing by replacing all instance dictionaries as multiple arguments of each method in the type class, and replace the function to create an instance dictionary with multiple functions to create each method in the type class.
This is indeed possible in Aiken, and to demonstrate this technique, consider the following Haskell code (which loosely models code generated from Lambda Buffers)</p>
<pre><code class="language-haskell">class Eq a where
    eq :: a -&gt; a -&gt; Bool

class PlutusData a where
    toData :: a -&gt; Data
    fromData :: Data -&gt; a

data MyOption a = MyJust a | MyNothing

instance Eq a =&gt; Eq (MyOption a) where
    eq (MyJust s) (MyJust t) = s == t
    eq MyNothing  MyNothing  = True
    eq _          _          = False

instance PlutusData a =&gt; PlutusData (MyOption a) where
    toData (MyJust s) = Constr 0 [toData s]
    toData MyNothing  = Constr 1 []

    fromData (Constr 0 [s]) = MyJust (fromData s)
    fromData (Constr 1 [])  = MyNothing
    fromData _              = error "bad parse"
</code></pre>
<p>A translation to type class free code in Aiken is as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use aiken/builtin as builtin
use mypackage/lb_prelude/types_/int as lb_prelude_int  // this would have to be implemented in an lb-prelude runtime

pub type MyOption&lt;t&gt; {
    MyJust(t)
    MyNothing
}

pub fn eq(eqt : fn(t,t) -&gt; Bool) -&gt; fn(MyOption&lt;t&gt;,MyOption&lt;t&gt;) -&gt; Bool {
    fn(a,b) { 
        when a is {
            MyJust(aJust) -&gt; when b is {
                MyJust(bJust) -&gt; eqt(aJust,bJust)
                MyNothing -&gt; False
            }
            MyNothing -&gt; when b is {
                MyJust(_) -&gt; False
                MyNothing -&gt; True
            }
        }
    }
}

pub fn fromData(fromDataT : fn(Data) -&gt; t) -&gt; fn(Data) -&gt; MyOption&lt;t&gt; {
    fn(theData) {
        let answer = 
            builtin.choose_data (theData, 
                  (fn(theData) { 
                        let constr = builtin.un_constr_data(theData)
                        let tag = constr.1st
                        let fields = constr.2nd
                          when tag is {
                                0 -&gt; when fields is {
                                    [ justValue ] -&gt; MyJust(fromDataT(justValue))
                                    _ -&gt; error @"Bad parse"
                                }
                                1 -&gt; when fields is {
                                    [] -&gt; MyNothing
                                    _ -&gt; error @"Bad parse"
                                }
                                _ -&gt; error @"Bad parse"
                            }
                    })(theData), (fn(_theData) { error @"Bad parse" })(theData), (fn(_theData) { error @"Bad parse"})(theData), (fn(_theData){error @"Bad parse"})(theData), (fn(_theData) { error @"Bad parse"})(theData))
        answer
    }
}

pub fn toData(toDataT : fn(t) -&gt; Data) -&gt; fn(MyOption&lt;t&gt;) -&gt; Data {
    fn(theOption) {
        when theOption is {
            MyJust(justValue) -&gt; builtin.constr_data(0, [toDataT(justValue)])
            MyNothing -&gt; builtin.constr_data(1, [])
        }
    }
}

// Example usages:

test from_nothing_test() {
    fromData(lb_prelude_int.fromData)(builtin.constr_data(1, [])) == MyNothing
}

test from_just_test() {
    fromData(lb_prelude_int.fromData)(builtin.constr_data(0, [builtin.i_data(69)])) == MyJust(69)
}

test from_to_nothing_test() {
    toData(lb_prelude_int.toData)(fromData(lb_prelude_int.fromData)(builtin.constr_data(1, []))) == builtin.constr_data(1, [])
}

test from_to_just_test() {
    toData(lb_prelude_int.toData)(fromData(lb_prelude_int.fromData)(builtin.constr_data(0, [builtin.i_data(69)]))) == builtin.constr_data(0, [builtin.i_data(69)])
}
<span class="boring">}</span></code></pre></pre>
<p>This translation of type classes has some limitations such as:</p>
<ul>
<li>
<p>All type class instances must be defined in the same module that the type is defined in i.e., orphan instances are forbidden.</p>
</li>
<li>
<p>Only Haskell2010 type classes would be supported.</p>
</li>
</ul>
<p>While the above has demonstrated how one can translate type class instances in Lambda Buffers to type class free code in Aiken,
this unfortunately leads to a bad user experience for the "builtin" PlutusData type class in Aiken.
Aiken by default "generates" its own PlutusData instances for all composite types.
As such, Aiken provides some nice syntactic features to make writing smart contracts particularly readable.</p>
<p>A common pattern to write a validator in Aiken is as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MyRecord&lt;t&gt; {a : t, b : Int }

validator {
    pub fn hello_world(_redeemer: MyRecord&lt;Int&gt;, _scriptContext: Data) {
                              //  ^~~~ this will automatically use Aiken's builtin PlutusData instances
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Unfortunately, with the type class system described in this section,
an Aiken developer will no longer be able to write this (since Lambda Buffers would generate its own PlutusData instances that are not used by Aiken)
and instead must write the validator more verbosely as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MyRecord&lt;t&gt; {a : t, b : Int }

validator {
    pub fn hello_world(redeemer: Data, _scriptContext: Data) {
       let actualRedeemer = myRecordFromData(intFromData)(redeemer)
        // ^~~~ Aiken users need to write more code in order to use Lambda
        // Buffers so that it will use Lambda Buffers' encoding for the
        // validator. Note that this sample assumes that `myRecordFromData :: (Data -&gt; t) -&gt; Data -&gt; MyRecord&lt;t&gt;` 
        // exists as would be generated by Lambda Buffers.
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Clearly, this increase in code bloat to express the same simple idea contradicts the promises of making smart contracts easy to write on Aiken.</p>
<h3 id="aikens-encoding-of-its-data-is-different-from-lambda-buffers-encoding"><a class="header" href="#aikens-encoding-of-its-data-is-different-from-lambda-buffers-encoding">Aiken's encoding of its data is different from Lambda Buffers encoding</a></h3>
<p>All onchain scripts must be compiled to UPLC which must in some method represent the higher level language constructs like data types in the original language.
Often, data types in a higher level language are translated to UPLC's builtin <code>Data</code> type which supports types like lists, constructors, integers, bytestrings, and maps.
Note that data which will exist as a datum or redeemer must admit a representation with this <code>Data</code> type.</p>
<p>Lambda Buffers chooses a particularly efficient encoding of its data types to <code>Data</code> mapping to its target languages that map to UPLC.
For example, a record like</p>
<pre><code class="language-purescript">record MyRecord = { a : Integer, b : Integer }
</code></pre>
<p>would be translated to</p>
<pre><code class="language-purescript">[a, b]
</code></pre>
<p>i.e., records are lists of all record components<sup class="footnote-reference"><a href="#recordsSpecialCases">1</a></sup>.</p>
<div class="footnote-definition" id="recordsSpecialCases"><sup class="footnote-definition-label">1</sup>
<p>There are some special cases for the encoding in Lambda Buffers. For example, singleton records are encoded as just the single element.</p>
</div>
<p>If Lambda Buffers compiled <code>MyRecord</code> to a <a href="https://aiken-lang.org/language-tour/custom-types">record in Aiken</a> as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type MyRecord {
    a : Int,
    b : Int
}
<span class="boring">}</span></code></pre></pre>
<p>Then, one can observe that Aiken will internally represent this as the following <code>Data</code> type</p>
<pre><code class="language-purescript">Constr 0 [a, b]
</code></pre>
<p>where we note that Aiken includes a useless <code>Constr 0</code> tag meaning Aiken's encoding is less efficient than Lambda Buffers' encoding.</p>
<p>In general, Aiken's documentation for the encoding from Aiken's types to UPLC <code>Data</code> is unclear,
but one can inspect the generated UPLC to verify that Aiken would encode the data as mentioned above.</p>
<p>For example, given the following Aiken module</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MyRecord { a: Int, b: Int }

validator {
    pub fn hello_world(_redeemer: Data, _scriptContext: Data) {
        let theRecord = MyRecord(69, -69)

        theRecord.a == 420 &amp;&amp; theRecord.b == -420
    }
}
<span class="boring">}</span></code></pre></pre>
<p>One can compile and inspect the UPLC as follows</p>
<pre><code class="language-shell">$ aiken build --uplc
...
$ cat artifacts/myvalidator.hello_world.uplc
artifacts/myvalidator.hello_world.uplc
(program
  1.0.0
  [
    (lam
      i_0
      [
        (lam
          i_1
          [
            (lam
              i_2
              [
                (lam
                  i_3
                  (lam
                    i_4
                    (lam
                      i_5
                      (force
                        [
                          [
                            [
                              i_3
                              (force
                                [
                                  [
                                    [
                                      i_3
                                      [
                                        [
                                          (builtin equalsInteger)
                                          [
                                            (builtin unIData)
                                            [
                                              i_1
                                              [
                                                i_2
                                                [
                                                  (builtin unConstrData)
                                                  (con
                                                    data (Constr 0 [I 69, I -69])
                                                  )
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                        (con integer 420)
                                      ]
                                    ]
                                    (delay
                                      [
                                        [
                                          (builtin equalsInteger)
                                          [
                                            (builtin unIData)
                                            [
                                              i_1
                                              [
                                                i_0
                                                [
                                                  i_2
                                                  [
                                                    (builtin unConstrData)
                                                    (con
                                                      data (Constr 0 [I 69, I -69])
                                                    )
                                                  ]
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                        (con integer -420)
                                      ]
                                    )
                                  ]
                                  (delay (con bool False))
                                ]
                              )
                            ]
                            (delay (con unit ()))
                          ]
                          (delay [ (error ) (force (error )) ])
                        ]
                      )
                    )
                  )
                )
                (force (builtin ifThenElse))
              ]
            )
            (force (force (builtin sndPair)))
          ]
        )
        (force (builtin headList))
      ]
    )
    (force (builtin tailList))
  ]
)
</code></pre>
<p>In particular, the following lines are evidence to support that the record is encoded inefficiently as <code>Constr 0 [&lt;integer&gt;, &lt;integer&gt;]</code>.</p>
<pre><code class="language-haskell">      [
        (builtin unConstrData)
        (con
          data (Constr 0 [I 69, I -69])
        )
      ]
</code></pre>
<p>This is awkward for Lambda Buffers since when Aiken works with the <code>MyRecord</code> type,
it is represented with the <code>Constr</code> tag meaning that Lambda Buffers' efficient encoding would be translated to Aiken's inefficient encoding.
Ideally, one would want to change how Aiken encodes its data types internally so that Aiken can use Lambda Buffers' efficient encoding everywhere.
Thus, we lose all benefits of Lambda Buffers' efficient encoding when working with Aiken's mechanisms to define types because Lambda Buffers is forced to take an extra step to translate to Aiken's inefficient encoding.
As such, Aiken's opinionated way of encoding its data is at odds with Lambda Buffers.</p>
<p>To resolve the mismatch in the encoding of data between the two,
one could alternatively sidestep all of Aiken's methods for defining types
and instead use Aiken's opaque types to alias <code>Data</code> and provide ones own constructors / record accesses as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use aiken/builtin as builtin

pub opaque type MyRecord { data: Data }

// Constructor for `MyRecord`
pub fn myRecord(a: Int, b: Int) -&gt; MyRecord {
    MyRecord{ data : builtin.list_data([builtin.i_data(a), builtin.i_data(b)]) }
}

// Projection for the field `a` of `MyRecord`
pub fn myRecord_a(value : MyRecord) -&gt; Int {
    builtin.un_i_data(builtin.head_list(builtin.un_list_data(value)))
}

// Projection for the field `b` of `MyRecord`
pub fn myRecord_b(value : MyRecord) -&gt; Int {
    builtin.un_i_data(builtin.head_list(builtin.tail_list(builtin.un_list_data(value))))
}

validator {
    pub fn hello_world(_redeemer: Data, _scriptContext: Data) {
        let theRecord = myRecord(69, -69)

        myRecord_a(theRecord) == 420 &amp;&amp; myRecord_b(theRecord) == -420
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Interested readers may inspect the compiled UPLC to verify that the data encoding of <code>MyRecord</code> agrees with Lambda Buffers' encoding.</p>
<pre><code class="language-purescript">(program
  1.0.0
  [
    (lam
      i_0
      [
        (lam
          i_1
          [
            (lam
              i_2
              [
                (lam
                  i_3
                  (lam
                    i_4
                    (lam
                      i_5
                      (force
                        [
                          [
                            [
                              i_3
                              [
                                (lam
                                  i_6
                                  (force
                                    [
                                      [
                                        [
                                          i_3
                                          [
                                            [
                                              (builtin equalsInteger)
                                              [
                                                (builtin unIData)
                                                [
                                                  i_1
                                                  [ (builtin unListData) i_6 ]
                                                ]
                                              ]
                                            ]
                                            (con integer 420)
                                          ]
                                        ]
                                        (delay
                                          [
                                            [
                                              (builtin equalsInteger)
                                              [
                                                (builtin unIData)
                                                [
                                                  i_1
                                                  [
                                                    i_0
                                                    [ (builtin unListData) i_6 ]
                                                  ]
                                                ]
                                              ]
                                            ]
                                            (con integer -420)
                                          ]
                                        )
                                      ]
                                      (delay (con bool False))
                                    ]
                                  )
                                )
                                [
                                  (builtin listData)
                                  [
                                    [ i_2 (con data (I 69)) ]
                                    [
                                      [ i_2 (con data (I -69)) ]
                                      (con (list data) [])
                                    ]
                                  ]
                                ]
                              ]
                            ]
                            (delay (con unit ()))
                          ]
                          (delay [ (error ) (force (error )) ])
                        ]
                      )
                    )
                  )
                )
                (force (builtin ifThenElse))
              ]
            )
            (force (builtin mkCons))
          ]
        )
        (force (builtin headList))
      ]
    )
    (force (builtin tailList))
  ]
)
</code></pre>
<p>Note that this would most likely offer a poor user experience as this would essentially replace a large part of Aiken's language construct with our own generated functions for constructing, deconstructing, serialization / deserialization to <code>Data</code>, etc.</p>
<p>In either case,
to mediate the Data serialization / deserialization mismatch of Aiken and Lambda Buffers,
it puts a bulkier mental overhead on the Aiken developer.
For example, as in the previous section, an Aiken developer would expect to write a validator as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MyRecord {a : Int, b : Int }

validator {
    pub fn hello_world(_redeemer: MyRecord, _scriptContext: Data) {
                              //  ^~~~ this will automatically use Aiken's builtin Data serialization and deserialization
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>But, any of the solutions to mediate the Data encoding mismatch of Aiken and Lambda Buffers would force an Aiken developer to instead write a more verbose validator as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MyRecord {a : Int, b : Int }

validator {
    pub fn hello_world(redeemer: Data, _scriptContext: Data) {
        let actualRedeemer = myRecordFromData(redeemer)
                          // ^~~~ Assume that Lambda Buffers would generate `myRecordFromData :: Data -&gt; MyRecord`
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Again, it's clear this contradicts Aiken's goal of making writing smart contracts easy as Lambda Buffers integration would increase the mental overhead of working with all generated data types.</p>
<h3 id="aikens-packages-only-support-fetching-dependencies-remotely"><a class="header" href="#aikens-packages-only-support-fetching-dependencies-remotely">Aiken's packages only support fetching dependencies remotely</a></h3>
<p>Lambda Buffers is more than just a code generator.
In addition to generating code for sharing types and semantics, its Nix tools augment a set of packages for a project with a package of the generated Lambda Buffers code.</p>
<p>Aiken does support having packages, but it appears that it only officially supports fetching packages from either Github, GitLab, or BitBucket i.e., it's unclear how to create a local package set augmented with Lambda Buffers' packages.</p>
<p>For example, the following <code>aiken.toml</code> file</p>
<pre><code class="language-toml">name = "me/package"
version = "0.0.0"
plutus = "v2"
license = "Apache-2.0"
description = "Aiken contracts for project 'package'"

[repository]
user = "me"
project = "package"
platform = "github"

[[dependencies]]
name = "aiken-lang/stdlib"
version = "1.8.0"

source = "github"
[[dependencies]]
name = "me/otherpackage"
version = "0.0.0"
source = "what do I put here if I have my own local package?"
</code></pre>
<p>would produce an error like</p>
<pre><code class="language-bash">$ aiken build
        Error aiken::loading::toml

  × TOML parse error at line 20, column 10
  │    |
  │ 20 | source = "what do I put here if I have my own local package?"
  │    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  │ unknown variant `what do I put here if I have my own local package?`, expected one of `github`, `gitlab`, `bitbucket`
  │
    ╭─[/home/jared/Documents/Work/aikentest/mypackage/aiken.toml:19:1]
 19 │ version = "0.0.0"
 20 │ source = "what do I put here if I have my own local package?"
    ·          ────────────────────────────────────────────────────
 21 │
    ╰────
</code></pre>
<p>where the error message makes it clear that it only expects the source of dependencies to be from either GitHub, GitLab, or BitBucket.</p>
<p>As such, it's unclear how to augment the local set of packages with a Lambda Buffers package.
Indeed, it's possible to trick Aiken into thinking that a Lambda Buffers package is already installed by preparing Aiken's build directory with the dependencies copied in ahead of time,
but this delves into implementation specific details of Aiken that may break between releases.
An example of this technique is <a href="https://github.com/mlabs-haskell/uplc-benchmark/blob/master/nix/aiken/lib.nix#L83">here</a>.</p>
<h2 id="summary-of-aiken-limitations"><a class="header" href="#summary-of-aiken-limitations">Summary of Aiken limitations</a></h2>
<p>This section summarizes the Aiken limitations and incompatibilities with Lambda Buffers.</p>
<ol>
<li>
<p>Aiken has no type classes, but Lambda Buffers requires type classes. As such, Lambda Buffers support for Aiken would require its own implementation of type classes.
Unfortunately, implementing type classes is awkward in Aiken because composite data types in Aiken cannot store functions.
While there are work arounds to implement type classes in Aiken,
this fundamentally will create a poor user experience for an Aiken developer as using Lambda Buffers' generated type classes such as PlutusData would be at odds with the builtin syntactic goodies of Aiken's default PlutusData type class instances.</p>
</li>
<li>
<p>Aiken's PlutusData representation of its data types is different from Lambda Buffers' representation of PlutusData.
This means that we have a choice of either:</p>
<ul>
<li>
<p>Translating Lambda Buffers types to Aiken's builtin composite types which would lead to inefficient code in the already constrained onchain code environment since this would be "massaging" PlutusData representations when we would really want Aiken to use Lambda Buffers PlutusData encoding directly.</p>
</li>
<li>
<p>Translating Lambda Buffers types to a opaque type alias in Aiken which would then require us to generate supporting functions for constructors and destructors which would make Aiken's major language features obsolete, and so have a poor user experience.</p>
</li>
</ul>
<p>To put this more explicitly, we either have inefficient code with a somewhat nice user experience for an Aiken developer, or efficient code with an awful user experience for an Aiken developer.</p>
</li>
<li>
<p>Creating local package sets in Aiken is unclear, but creating such local package sets is a principal feature of Lambda Buffers.
Indeed, there are tricks one can do to work around this, but this depends on internal implementation details of Aiken that may break between releases.</p>
</li>
</ol>
<p>All in all, at the moment it's clear that while it may be possible to integrate Aiken with Lambda Buffers, such integration would have</p>
<ul>
<li>
<p>limited support for Lambda Buffers' key features; and</p>
</li>
<li>
<p>a poor user experience for Aiken developers that use Lambda Buffers.</p>
</li>
</ul>
<p>So, the extra effort needed to mitigate these challenges appear to be counter productive with Aiken's and Lambda Buffers' project goals.
Moreover, Aiken is still in an alpha release and is rapidly changing, so the effort to mitigate these challenges would be squandered away as Aiken evolves.
Thus, given these challenges, it's clear that it would be unwise to undertake the Aiken implementation currently,
and it would be wiser to revisit this later and focus on matters of pressing importance today to better foster adoption of Lambda Buffers.</p>
<p>Lambda Buffers has fortunately seen industry use in other projects such as <a href="https://github.com/mlabs-haskell/DeNS/tree/main">DeNS</a>, <a href="https://github.com/yaadlabs/DAO-Off-Chain">TripHut DAO</a>, etc.,
and there's been feedback to improve the existing facilities in Lambda Buffers which would aid in fostering the adoption of Lambda Buffers in the greater Cardano community.
Some of these issues include the following.</p>
<ul>
<li>
<p>Bugs:</p>
<ul>
<li>
<p>Haskell backend bugs.</p>
<ul>
<li>
<p><a href="https://github.com/mlabs-haskell/lambda-buffers/issues/197">Generated Haskell code is invalid</a></p>
</li>
<li>
<p><a href="https://github.com/mlabs-haskell/lambda-buffers/issues/124">Missing dependencies from the generated files</a></p>
</li>
</ul>
</li>
<li>
<p>Plutarch backend bugs.</p>
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/issues/148">Generated Plutarch code is invalid</a></li>
</ul>
</li>
<li>
<p><a href="https://github.com/mlabs-haskell/lambda-buffers/issues/76">Optimizing the Lambda Buffers compiler performance</a></p>
</li>
</ul>
</li>
<li>
<p>Features:</p>
<ul>
<li>
<p><a href="https://github.com/mlabs-haskell/lambda-buffers/issues/175">Completing the Plutus <code>.lbf</code> schemas to include all Plutus Ledger API types</a></p>
</li>
<li>
<p><a href="https://github.com/mlabs-haskell/lambda-buffers/issues/220">Creating a versioning scheme</a></p>
</li>
<li>
<p><a href="https://github.com/mlabs-haskell/lambda-buffers/issues/221">Separate the PlutusTx backend from a Haskell Plutus backend</a></p>
</li>
<li>
<p><a href="https://github.com/mlabs-haskell/lambda-buffers/pull/193#issuecomment-1942114795">Optimizing slow nix build times</a></p>
</li>
<li>
<p><a href="https://github.com/mlabs-haskell/lambda-buffers/issues/152">Improving error messages for better editor integration</a></p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-reports"><a class="header" href="#catalyst-reports">Catalyst reports</a></h1>
<p>Our project was funded by Catalyst. As a proof of completion, we collected our reports of
finished Catalyst projects here:</p>
<ul>
<li><a href="catalyst09-reports">Catalyst 9 reports</a>
<ul>
<li><a href="catalyst09-reports/milestone-1.html">Milestone 1: Research</a></li>
<li><a href="catalyst09-reports/milestone-2.html">Milestone 2: End to end proof of concept</a></li>
<li><a href="catalyst09-reports/milestone-3.html">Milestone 3: Testing and documentation</a></li>
<li><a href="catalyst09-reports/milestone-3.html">Milestone 4: Project adoption</a></li>
</ul>
</li>
<li><a href="catalyst10-reports">Catalyst 10 reports</a>
<ul>
<li><a href="catalyst10-reports/milestone-1.html">Milestone 1: Rust support</a></li>
<li><a href="catalyst10-reports/milestone-2.html">Milestone 2: Javascript/Typescript support</a></li>
</ul>
</li>
<li><a href="catalyst13-reports">Catalyst 13 reports</a>
<ul>
<li><a href="catalyst13-reports/milestone-2.html">Milestone 2: LambdaBuffers Conway support</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-9-reports"><a class="header" href="#catalyst-9-reports">Catalyst 9 reports</a></h1>
<ul>
<li><a href="catalyst09-reports/milestone-1.html">Milestone 1: Research</a></li>
<li><a href="catalyst09-reports/milestone-2.html">Milestone 2: End to end proof of concept</a></li>
<li><a href="catalyst09-reports/milestone-3.html">Milestone 3: Testing and documentation</a></li>
<li><a href="catalyst09-reports/milestone-3.html">Milestone 4: Project adoption</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-1-research"><a class="header" href="#catalyst-milestone-1-research">Catalyst milestone 1: Research</a></h1>
<h2 id="outputs"><a class="header" href="#outputs">Outputs</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
A report summarizing user interviews and containing a qualitative analysis of the discovered use cases.
<ul>
<li><strong>STATUS</strong>: Done (#17)</li>
<li>An interview with 3 MLabs engineers was performed (1.5h) who's work span multiple Cardano dApp projects. Their <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/feedback/interview-notes.md">feedback</a> is made available in the repo.</li>
<li>Additionally, a survey was sent out to MLabs engineers and their <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/feedback/questionnaire-results.pdf">feedback</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
An architecture design document.
<ul>
<li><strong>STATUS</strong>: Done (#17)</li>
<li>Extensive documentation on <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/design.md">design</a>, <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/compiler.md">compiler</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/codegen.md">codegen</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A language specification document elaborating on the data type model features.
<ul>
<li><strong>STATUS</strong>: Done (#17)</li>
<li>Extensive documentation on <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/design.md">design</a>, <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/compiler.md">compiler</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/codegen.md">codegen</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A related work document comparing the proposed technology via a feature matrix with others in the same space.
<ul>
<li><strong>STATUS</strong>: Done (#17, #18)</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/comparison-matrix.md">Document</a> comparing different schema techologies to LambdaBuffers is made available in the repo</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
An initial compiler implementation that performs some basic checks in accordance with the language specification.
<ul>
<li><strong>STATUS</strong>: Done (#10)</li>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-compiler">initial compiler implementation perform</a> <code>kind checking</code> is made available in the repo.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria"><a class="header" href="#acceptance-criteria">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
At least 3 users/projects have been interviewed about their desired use case for this technology.
<ul>
<li>An interview with 3 MLabs engineers was performed (1.5h) who's work span multiple Cardano dApp projects. Their <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/feedback/interview-notes.md">feedback</a> is made available in the repo.</li>
<li>Additionally, a survey was sent out to MLabs engineers and their <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/feedback/questionnaire-results.pdf">feedback</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The architecture design document is completed and available in the project repository.
<ul>
<li>Extensive documentation on <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/design.md">design</a>, <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/compiler.md">compiler</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/codegen.md">codegen</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The initial compiler implementation is completed, capturing SOME of the intended language semantics as described in the Language Specification
<ul>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-compiler">initial compiler implementation perform</a> <code>kind checking</code> is made available in the repo.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion"><a class="header" href="#evidence-of-milestone-completion">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Completed and reviewed design document is available in the project repository.
<ul>
<li>Extensive documentation on <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/design.md">design</a>, <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/compiler.md">compiler</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/codegen.md">codegen</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Completed and reviewed initial version of the compiler command line tool made available in the project repository.
<ul>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-frontend">Frontend CLI</a> called <code>lambda-buffers-frontend-cli</code> is made available in the repo and is currently able to parse, validate and format <code>.lbf</code> documents that contain the LambdaBuffers type modules:</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">lambda-buffers/lambda-buffers-frontend$ cabal run 
Usage: lambda-buffers-frontend-cli COMMAND

  LambdaBuffers Frontend command-line interface tool

Available options:
  -h,--help                Show this help text

Available commands:
  compile                  Compile a LambdaBuffers Module (.lbf)
  format                   Format a LambdaBuffers Module (.lbf)
</code></pre>
<p>There's ongoing work to integrate the <a href="catalyst09-reports/lambda-buffers-compiler">Compiler CLI</a> in the Frontend CLI.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Compiler is able to validate a schema that uses a subset of types and capabilities from the spec.
<ul>
<li>Both the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-frontend">Frontend</a> and the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-compiler">Compiler</a> components are accompanied by a test suite that is routinely run by the projects' CI system.</li>
<li>A <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-frontend/resources">corpus of <code>lbf</code></a> files is made available in the repo and used in the test suite to ensure correct document handling.</li>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-compiler/test/Test/KindCheck.hs">compiler tests on the kind checking machinery</a> is also made available in the repo.</li>
</ul>
</li>
</ul>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/16dTxgGsxHvcMe5aCgFPDYEJKgX_VQiNAcwhp2RyA48o/edit#gid=1672366179">Catalyst project sheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-2-end-to-end-proof-of-concept"><a class="header" href="#catalyst-milestone-2-end-to-end-proof-of-concept">Catalyst milestone 2: End to end proof of concept</a></h1>
<h2 id="outputs-1"><a class="header" href="#outputs-1">Outputs</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
A configuration DSL for specifying domain data types.
<ul>
<li>LambdaBuffers <strong>Frontend</strong> supports specifying modules with <strong>type definitions</strong> with <strong>opaque</strong>, <strong>product/record</strong> and <strong>sum</strong> types. Additionally, type <strong>class definitions</strong> are supported as well as type <strong>class rule definitions</strong> using the 'instance clause' and 'derive' syntax.</li>
<li>Refer to the standard LambdaBuffers library <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/lbf-base">lbf-base</a> to get a sense of what the language looks like.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A compiler tool that outputs the interpreted configuration.
<ul>
<li>The Compiler is exposed via an <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-proto/compiler.proto">Google Protobuffers based API</a>. The Codegen shares the same API types and is exposed in a similar fashion. The Frontend communicates with these components via the API.</li>
<li>The API documentation is made available via <a href="https://mlabs-haskell.github.io/lambda-buffers/compiler-api.html">LambdaBuffers Github Pages</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Codegen module that takes in the interpreted configuration and outputs a Haskell+PlutusTx (was Plutarch) Cabal project containing all the types and necessary type class wiring.
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell</a>.</li>
<li>The auto-generated Haskell files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers</a>.</li>
<li>Codegen module outputs Haskell type definitions, and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Eq.html#t:Eq">Prelude.Eq</a> and <a href="https://github.com/input-output-hk/plutus/blob/848ec58de981a144226ee203c46144c0f3213f26/plutus-tx/src/PlutusTx/IsData/Class.hs#L34">PlutusTx.ToData</a> type class implementations automatically.</li>
<li>Plutarch Codegen module is suspended for the current milestone (as communicated with the Catalyst team). Plutarch is a Haskell EDSL for writing Plutus (UPLC) programs, and can be considered a completely separate backend/target language.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Codegen module that takes in the interpreted configuration and outputs a Purescript+CTL Spago project containing all the types and necessary wiring.
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Purescript">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Purescript</a>.</li>
<li>The auto-generated Purescript files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers</a>.</li>
<li>Codegen module outputs Purescript type definitions and <a href="https://pursuit.purescript.org/packages/purescript-prelude/3.1.0/docs/Data.Eq#t:Eq">Prelude.Eq</a>
and <a href="https://github.com/Plutonomicon/cardano-transaction-lib/blob/b565f4b1ec877c671ec4ffc13b1b89dbe498bceb/src/Internal/ToData.purs#L73">Ctl.Internal.ToData</a> type class implementations.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-1"><a class="header" href="#acceptance-criteria-1">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The generated Haskell+Plutarch Cabal project can successfully be built.</li>
<li><input disabled="" type="checkbox" checked=""/>
The generated Purescript+CTL Spago project can successfully be built.</li>
<li><input disabled="" type="checkbox" checked=""/>
All the above codegen modules are reviewed and made available in the project repository.</li>
</ul>
<h2 id="evidence-of-milestone-completion-1"><a class="header" href="#evidence-of-milestone-completion-1">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Project repository is equipped with continuous integration tooling.
<ul>
<li>The repository has been consistently built with <a href="https://hercules-ci.com/">HerculesCI</a> since the beginning.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Completed and reviewed Haskell+Plutarch codegen module is made available in the project repository and the CI builds it successfully.
<ul>
<li>The auto-generated Haskell files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers</a>.</li>
<li>Additionally, the auto generated Haskell files used during the demo can be found in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/plutustx-env/autogen/LambdaBuffers">experimental/plutustx-env/autogen/LambdaBuffers</a>.</li>
<li>Codegen module outputs Haskell type definitions, and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Eq.html#t:Eq">Prelude.Eq</a> and <a href="https://github.com/input-output-hk/plutus/blob/848ec58de981a144226ee203c46144c0f3213f26/plutus-tx/src/PlutusTx/IsData/Class.hs#L34">PlutusTx.ToData</a> type class implementations automatically.</li>
<li>Plutarch Codegen module is suspended for the current milestone (as communicated with the Catalyst team). Plutarch is a Haskell EDSL for writing Plutus (UPLC) programs, and can be considered a completely separate backend/target language.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Completed and reviewed Purescript+CTL codegen module is made available in the project repository and the CI builds it successfully.
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Purescript">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Purescript</a>.</li>
<li>The auto-generated Purescript files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers</a>.</li>
<li>Additionally, the auto generated Purescript files used during the demo can be found in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/ctl-env/autogen/LambdaBuffers">experimental/ctl-env/autogen/LambdaBuffers</a>.</li>
<li>Codegen module outputs Purescript type definitions and <a href="https://pursuit.purescript.org/packages/purescript-prelude/3.1.0/docs/Data.Eq#t:Eq">Prelude.Eq</a> and
<a href="https://github.com/Plutonomicon/cardano-transaction-lib/blob/b565f4b1ec877c671ec4ffc13b1b89dbe498bceb/src/Internal/ToData.purs#L73">Ctl.Internal.ToData</a> type class implementations.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Compiler is able to output a valid module with types from a schema in Haskell+Plutarch.
<ul>
<li>The auto-generated Haskell files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Compiler is able to output a valid module with types from a schema in PureScript.
<ul>
<li>The auto-generated Purescript files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers</a>.</li>
</ul>
</li>
</ul>
<h2 id="demo-recordings"><a class="header" href="#demo-recordings">Demo recordings</a></h2>
<ul>
<li>Introduction, working with the LambdaBuffers CLI tools and Frontend overview.
<ul>
<li><a href="https://www.youtube.com/watch?v=KnznwIdkFLM">https://www.youtube.com/watch?v=KnznwIdkFLM</a></li>
</ul>
</li>
<li>Codegen into Haskell
<ul>
<li><a href="https://www.youtube.com/watch?v=WhZU66fcnig">https://www.youtube.com/watch?v=WhZU66fcnig</a></li>
</ul>
</li>
<li>Codegen into Purescript
<ul>
<li><a href="https://www.youtube.com/watch?v=tXnjt5h7D9w">https://www.youtube.com/watch?v=tXnjt5h7D9w</a></li>
</ul>
</li>
</ul>
<p>Demo files:</p>
<ul>
<li>LambdaBuffers <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/plutustx-env/api/Citizen.lbf">Citizen.lbf</a> module.</li>
<li>Purescript demo files <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/ctl-env/autogen/LambdaBuffers">ctl-env</a>.</li>
<li>Haskell demo files <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/plutustx-env">plutustx-env</a>.</li>
</ul>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/16dTxgGsxHvcMe5aCgFPDYEJKgX_VQiNAcwhp2RyA48o/edit#gid=1672366179">Catalyst project sheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-3-testing-and-documentation"><a class="header" href="#catalyst-milestone-3-testing-and-documentation">Catalyst milestone 3: Testing and documentation</a></h1>
<h2 id="outputs-2"><a class="header" href="#outputs-2">Outputs</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A test suite checking for correct mapping from schema data types to PlutusData encodings against a known-good corpus of such mappings (golden tests).</p>
<ul>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus">lbt-plutus</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">Purescript</a> backends. They leverage both golden unit testing approach and randomized property based testing to assert the essential properties of the LambdaBuffers Plutus package:
<ul>
<li><code>Plutus.V1.PlutusData</code> derivation tests
<ul>
<li>Golden unit tests: <code>forall (golden : Days.Day.*.pd.json): (toJson . toPlutusData . fromPlutusData . fromJson) golden == golden</code></li>
<li>Property tests: <code>forall (x : Foo.*): (fromPlutusData . toPlutusData) x == x</code></li>
</ul>
</li>
<li><code>Plutus.V1.PlutusData</code> instance tests
<ul>
<li>Golden unit tests: <code>forall (golden : *.pd.json): (toJson . toPlutusData . fromPlutusData . fromJson) golden == golden</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A test suite checking for roundtrip compatibility between codegened target environments.</p>
<ul>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus">lbt-plutus</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">Purescript</a> backends.</li>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude">lbt-prelude</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">Purescript</a> backends.</li>
<li>Both include golden unit tests that provide assurances that these backends implement the LambdaBuffers packages in a mutually compatible manner.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A modular and contract-based test suite architecture streamlining codegen testing compliance for any of the supported typeclasses.</p>
<ul>
<li>A testing strategy was devised and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites">implemented</a> where each supported backend must implement the <code>lbt</code> (ie. a LambdaBuffers test suite) for the corresponding LambdaBuffers package. A package is a collection of LambdaBuffers schemas and their associated runtime libraries.</li>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-prelude">runtimes/haskell/lbr-prelude</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-prelude">runtimes/purescript/lbr-prelude</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">testsuites/lbt-prelude/lbt-prelude-haskell</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">testsuites/lbt-prelude/lbt-prelude-purescript</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-plutus">runtimes/haskell/lbr-plutus</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-plutus">runtimes/purescript/lbr-plutus</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">testsuites/lbt-plutus/lbt-plutus-haskell</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">testsuites/lbt-plutus/lbt-plutus-purescript</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A document mapping the schema data types and typeclasses to their corresponding code-generated variants in the target environments.</p>
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-2"><a class="header" href="#acceptance-criteria-2">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The test suites are passing for the Haskell+PlutusTx codegen module.
<ul>
<li>CI targets:
<ul>
<li>checks.x86_64-linux."check-lbt-prelude-haskell:test:tests"</li>
<li>checks.x86_64-linux."check-lbt-plutus-haskell:test:tests"</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The test suites are passing for the Purescript+CTL codegen module.
<ul>
<li>CI targets:
<ul>
<li>checks.x86_64-linux."purescript:lbt-plutus:check"</li>
<li>checks.x86_64-linux."purescript:lbt-prelude:check"</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The “Mappings” document is made available in the project repository.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-2"><a class="header" href="#evidence-of-milestone-completion-2">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed test suite implementation for Haskell+PlutusTx codegen module is made available in the project repository.
<ul>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-prelude">runtimes/haskell/lbr-prelude</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">testsuites/lbt-prelude/lbt-prelude-haskell</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-plutus">runtimes/haskell/lbr-plutus</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">testsuites/lbt-plutus/lbt-plutus-haskell</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed test suite implementation for Purescript+CTL codegen module is made available in the project repository.
<ul>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-prelude">runtimes/purescript/lbr-prelude</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">testsuites/lbt-prelude/lbt-prelude-purescript</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-plutus">runtimes/purescript/lbr-plutus</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">testsuites/lbt-plutus/lbt-plutus-purescript</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The “Mappings” document is made available in the project repository.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Robust Test cases to catch edge conditions are added against a wide variety of schemas, and output in all codegen backends.
<ul>
<li>Implemented as part of <code>lbf</code> (LambdaBuffers Frontend) test suite.</li>
</ul>
</li>
</ul>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/16dTxgGsxHvcMe5aCgFPDYEJKgX_VQiNAcwhp2RyA48o/edit#gid=1672366179">Catalyst project sheet</a></li>
</ul>
<h2 id="documentation-strategy"><a class="header" href="#documentation-strategy">Documentation strategy</a></h2>
<p>Each typeclass receives a Specification document that closely explains the required semantics for LB types (sum/products/records).</p>
<p>Each backend receives a User documentation that elaborates on how the generated code is used.</p>
<h2 id="testing-strategy"><a class="header" href="#testing-strategy">Testing strategy</a></h2>
<p>LambdaBuffers works with typeclasses, such as Eq, PlutusData and JSON. When a LB type has been declared with support for any of such typeclass, values of said types need to be handled in exactly the same manner as elaborated in the Specification for a given Typeclass in ALL support target language environments.</p>
<p>Concretely, if a type <code>Foo</code> has been declared with support for <code>JSON</code>, and <code>toJson</code> and <code>fromJson</code> methods have been generated for target languages, they have to be in correspondence.</p>
<pre><code class="language-lbf">module Foo

import Prelude (Json)

sum Foo = Bar Integer | Baz Text

deriving Json Foo
</code></pre>
<p>In Haskell and Purescript values of <code>Foo</code> would be <code>Bar 1</code> and <code>Baz "baz"</code>, and their respective JSON mappings would be <code>{"constructor" : "Bar", "product" : [1]}</code> and <code>{"constructor" : "Baz", "product" : ["baz"]}</code>.</p>
<h3 id="testing-encoding-typeclasses-from--to-goldens"><a class="header" href="#testing-encoding-typeclasses-from--to-goldens">Testing encoding typeclasses: <code>from . to</code> goldens</a></h3>
<p>For each typeclass, we maintain a set of <code>golden' files of known good/bad that lift into the target language with</code>from<code>and write it back with</code>to` into a separate file. Then we provide an assertion that these files are semantically 'equal' (for example JSON spaces don't matter and such).</p>
<p>Example test:</p>
<ul>
<li>test/foo/Foo.lbf</li>
<li>test/foo/json/bar.1.json</li>
<li>test/foo/json/bar.2.json</li>
<li>test/foo/json/baz.1.json</li>
<li>test/foo/json/baz.2.json</li>
<li>test/foo/json/haskell/bar.1.json</li>
<li>test/foo/json/haskell/bar.2.json</li>
<li>test/foo/json/haskell/baz.1.json</li>
<li>test/foo/json/haskell/baz.2.json</li>
<li>test/foo/json/purescript/bar.1.json</li>
<li>test/foo/json/purescript/bar.2.json</li>
<li>test/foo/json/purescript/baz.1.json</li>
<li>test/foo/json/purescript/baz.2.json</li>
<li>test/foo/plutusdata/bar.1.json</li>
<li>test/foo/plutusdata/bar.2.json</li>
<li>test/foo/plutusdata/baz.1.json</li>
<li>test/foo/plutusdata/baz.2.json</li>
<li>test/foo/plutusdata/haskell/bar.1.json</li>
<li>test/foo/plutusdata/haskell/bar.2.json</li>
<li>test/foo/plutusdata/haskell/baz.1.json</li>
<li>test/foo/plutusdata/haskell/baz.2.json</li>
<li>test/foo/plutusdata/purescript/bar.1.json</li>
<li>test/foo/plutusdata/purescript/bar.2.json</li>
<li>test/foo/plutusdata/purescript/baz.1.json</li>
<li>test/foo/plutusdata/purescript/baz.2.json</li>
</ul>
<h3 id="testing-equality-typeclasses-symmetry-and-transitivity"><a class="header" href="#testing-equality-typeclasses-symmetry-and-transitivity">Testing equality typeclasses: symmetry and transitivity</a></h3>
<ul>
<li><code>sym :: (a :~: b) -&gt; b :~: a</code></li>
<li><code>trans :: (a :~: b) -&gt; (b :~: c) -&gt; a :~: c</code></li>
</ul>
<p>This could be done with goldens and randomized testing. However, <code>goldens</code> approach assumes a correct marshaling procedure while the <code>randomized</code> assumes generators. Perhaps having both makes sense.</p>
<h2 id="todo-provide-time-estimates"><a class="header" href="#todo-provide-time-estimates">TODO (provide time estimates)</a></h2>
<ol start="0">
<li>Define the version 1 of <code>Prelude</code> and <code>Plutus</code> LBF libraries which MUST be supported</li>
<li>Support the Json typeclass
<ol>
<li>Codegen</li>
<li>Runtime support</li>
</ol>
</li>
<li>Support the Plutarch backend</li>
<li>Document typeclasses
<ol>
<li>Eq</li>
<li>PlutusData</li>
<li>Json</li>
</ol>
</li>
<li>Document backends
<ol>
<li>Sum/Product/Record type construction and deconstruction (Haskell, Purescript, Plutarch)</li>
<li>Eq/Json/PlutusData typeclass use (Haskell, Purescript, Plutarch minus Json)</li>
</ol>
</li>
<li>Devise <code>goldens</code>
<ol>
<li>Eq</li>
<li>PlutusData</li>
<li>Json</li>
</ol>
</li>
<li>Implement the test suite
<ol>
<li>Provide assertions</li>
<li>Hook to the CI</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-3-testing-and-documentation-1"><a class="header" href="#catalyst-milestone-3-testing-and-documentation-1">Catalyst milestone 3: Testing and documentation</a></h1>
<h2 id="outputs-3"><a class="header" href="#outputs-3">Outputs</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A test suite checking for correct mapping from schema data types to PlutusData encodings against a known-good corpus of such mappings (golden tests).</p>
<ul>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus">lbt-plutus</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">Purescript</a> backends. They leverage both golden unit testing approach and randomized property based testing to assert the essential properties of the LambdaBuffers Plutus package:
<ul>
<li><code>Plutus.V1.PlutusData</code> derivation tests
<ul>
<li>Golden unit tests: <code>forall (golden : Days.Day.*.pd.json): (toJson . toPlutusData . fromPlutusData . fromJson) golden == golden</code></li>
<li>Property tests: <code>forall (x : Foo.*): (fromPlutusData . toPlutusData) x == x</code></li>
</ul>
</li>
<li><code>Plutus.V1.PlutusData</code> instance tests
<ul>
<li>Golden unit tests: <code>forall (golden : *.pd.json): (toJson . toPlutusData . fromPlutusData . fromJson) golden == golden</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A test suite checking for roundtrip compatibility between codegened target environments.</p>
<ul>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus">lbt-plutus</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">Purescript</a> backends.</li>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude">lbt-prelude</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">Purescript</a> backends.</li>
<li>Both include golden unit tests that provide assurances that these backends implement the LambdaBuffers packages in a mutually compatible manner.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A modular and contract-based test suite architecture streamlining codegen testing compliance for any of the supported typeclasses.</p>
<ul>
<li>A testing strategy was devised and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites">implemented</a> where each supported backend must implement the <code>lbt</code> (ie. a LambdaBuffers test suite) for the corresponding LambdaBuffers package. A package is a collection of LambdaBuffers schemas and their associated runtime libraries.</li>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-prelude">runtimes/haskell/lbr-prelude</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-prelude">runtimes/purescript/lbr-prelude</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">testsuites/lbt-prelude/lbt-prelude-haskell</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">testsuites/lbt-prelude/lbt-prelude-purescript</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-plutus">runtimes/haskell/lbr-plutus</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-plutus">runtimes/purescript/lbr-plutus</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">testsuites/lbt-plutus/lbt-plutus-haskell</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">testsuites/lbt-plutus/lbt-plutus-purescript</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A document mapping the schema data types and typeclasses to their corresponding code-generated variants in the target environments.</p>
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-3"><a class="header" href="#acceptance-criteria-3">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The test suites are passing for the Haskell+PlutusTx codegen module.
<ul>
<li>CI targets:
<ul>
<li>checks.x86_64-linux."check-lbt-prelude-haskell:test:tests"</li>
<li>checks.x86_64-linux."check-lbt-plutus-haskell:test:tests"</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The test suites are passing for the Purescript+CTL codegen module.
<ul>
<li>CI targets:
<ul>
<li>checks.x86_64-linux."purescript:lbt-plutus:check"</li>
<li>checks.x86_64-linux."purescript:lbt-prelude:check"</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The “Mappings” document is made available in the project repository.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-3"><a class="header" href="#evidence-of-milestone-completion-3">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed test suite implementation for Haskell+PlutusTx codegen module is made available in the project repository.
<ul>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-prelude">runtimes/haskell/lbr-prelude</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">testsuites/lbt-prelude/lbt-prelude-haskell</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-plutus">runtimes/haskell/lbr-plutus</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">testsuites/lbt-plutus/lbt-plutus-haskell</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed test suite implementation for Purescript+CTL codegen module is made available in the project repository.
<ul>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-prelude">runtimes/purescript/lbr-prelude</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">testsuites/lbt-prelude/lbt-prelude-purescript</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-plutus">runtimes/purescript/lbr-plutus</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">testsuites/lbt-plutus/lbt-plutus-purescript</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The “Mappings” document is made available in the project repository.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Robust Test cases to catch edge conditions are added against a wide variety of schemas, and output in all codegen backends.
<ul>
<li>Implemented as part of <code>lbf</code> (LambdaBuffers Frontend) test suite.</li>
</ul>
</li>
</ul>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/16dTxgGsxHvcMe5aCgFPDYEJKgX_VQiNAcwhp2RyA48o/edit#gid=1672366179">Catalyst project sheet</a></li>
</ul>
<h2 id="documentation-strategy-1"><a class="header" href="#documentation-strategy-1">Documentation strategy</a></h2>
<p>Each typeclass receives a Specification document that closely explains the required semantics for LB types (sum/products/records).</p>
<p>Each backend receives a User documentation that elaborates on how the generated code is used.</p>
<h2 id="testing-strategy-1"><a class="header" href="#testing-strategy-1">Testing strategy</a></h2>
<p>LambdaBuffers works with typeclasses, such as Eq, PlutusData and JSON. When a LB type has been declared with support for any of such typeclass, values of said types need to be handled in exactly the same manner as elaborated in the Specification for a given Typeclass in ALL support target language environments.</p>
<p>Concretely, if a type <code>Foo</code> has been declared with support for <code>JSON</code>, and <code>toJson</code> and <code>fromJson</code> methods have been generated for target languages, they have to be in correspondence.</p>
<pre><code class="language-lbf">module Foo

import Prelude (Json)

sum Foo = Bar Integer | Baz Text

deriving Json Foo
</code></pre>
<p>In Haskell and Purescript values of <code>Foo</code> would be <code>Bar 1</code> and <code>Baz "baz"</code>, and their respective JSON mappings would be <code>{"constructor" : "Bar", "product" : [1]}</code> and <code>{"constructor" : "Baz", "product" : ["baz"]}</code>.</p>
<h3 id="testing-encoding-typeclasses-from--to-goldens-1"><a class="header" href="#testing-encoding-typeclasses-from--to-goldens-1">Testing encoding typeclasses: <code>from . to</code> goldens</a></h3>
<p>For each typeclass, we maintain a set of <code>golden' files of known good/bad that lift into the target language with</code>from<code>and write it back with</code>to` into a separate file. Then we provide an assertion that these files are semantically 'equal' (for example JSON spaces don't matter and such).</p>
<p>Example test:</p>
<ul>
<li>test/foo/Foo.lbf</li>
<li>test/foo/json/bar.1.json</li>
<li>test/foo/json/bar.2.json</li>
<li>test/foo/json/baz.1.json</li>
<li>test/foo/json/baz.2.json</li>
<li>test/foo/json/haskell/bar.1.json</li>
<li>test/foo/json/haskell/bar.2.json</li>
<li>test/foo/json/haskell/baz.1.json</li>
<li>test/foo/json/haskell/baz.2.json</li>
<li>test/foo/json/purescript/bar.1.json</li>
<li>test/foo/json/purescript/bar.2.json</li>
<li>test/foo/json/purescript/baz.1.json</li>
<li>test/foo/json/purescript/baz.2.json</li>
<li>test/foo/plutusdata/bar.1.json</li>
<li>test/foo/plutusdata/bar.2.json</li>
<li>test/foo/plutusdata/baz.1.json</li>
<li>test/foo/plutusdata/baz.2.json</li>
<li>test/foo/plutusdata/haskell/bar.1.json</li>
<li>test/foo/plutusdata/haskell/bar.2.json</li>
<li>test/foo/plutusdata/haskell/baz.1.json</li>
<li>test/foo/plutusdata/haskell/baz.2.json</li>
<li>test/foo/plutusdata/purescript/bar.1.json</li>
<li>test/foo/plutusdata/purescript/bar.2.json</li>
<li>test/foo/plutusdata/purescript/baz.1.json</li>
<li>test/foo/plutusdata/purescript/baz.2.json</li>
</ul>
<h3 id="testing-equality-typeclasses-symmetry-and-transitivity-1"><a class="header" href="#testing-equality-typeclasses-symmetry-and-transitivity-1">Testing equality typeclasses: symmetry and transitivity</a></h3>
<ul>
<li><code>sym :: (a :~: b) -&gt; b :~: a</code></li>
<li><code>trans :: (a :~: b) -&gt; (b :~: c) -&gt; a :~: c</code></li>
</ul>
<p>This could be done with goldens and randomized testing. However, <code>goldens</code> approach assumes a correct marshaling procedure while the <code>randomized</code> assumes generators. Perhaps having both makes sense.</p>
<h2 id="todo-provide-time-estimates-1"><a class="header" href="#todo-provide-time-estimates-1">TODO (provide time estimates)</a></h2>
<ol start="0">
<li>Define the version 1 of <code>Prelude</code> and <code>Plutus</code> LBF libraries which MUST be supported</li>
<li>Support the Json typeclass
<ol>
<li>Codegen</li>
<li>Runtime support</li>
</ol>
</li>
<li>Support the Plutarch backend</li>
<li>Document typeclasses
<ol>
<li>Eq</li>
<li>PlutusData</li>
<li>Json</li>
</ol>
</li>
<li>Document backends
<ol>
<li>Sum/Product/Record type construction and deconstruction (Haskell, Purescript, Plutarch)</li>
<li>Eq/Json/PlutusData typeclass use (Haskell, Purescript, Plutarch minus Json)</li>
</ol>
</li>
<li>Devise <code>goldens</code>
<ol>
<li>Eq</li>
<li>PlutusData</li>
<li>Json</li>
</ol>
</li>
<li>Implement the test suite
<ol>
<li>Provide assertions</li>
<li>Hook to the CI</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-10-reports"><a class="header" href="#catalyst-10-reports">Catalyst 10 reports</a></h1>
<ul>
<li><a href="catalyst10-reports/milestone-1.html">Milestone 1: Rust support</a></li>
<li><a href="catalyst10-reports/milestone-2.html">Milestone 2: Javascript/Typescript support</a></li>
<li><a href="catalyst10-reports/milestone-3.html">Milestone 3: Aiken integration research and development</a></li>
<li><a href="catalyst10-reports/milestone-4.html">Milestone 4: Separate PlutusTx backend and improvements to existing LambdaBuffers facilities</a></li>
<li><a href="catalyst10-reports/milestone-5.html">Final Milestone: Project scaffold for Rust, JavaScript and Haskell</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-1-rust-support"><a class="header" href="#catalyst-milestone-1-rust-support">Catalyst milestone 1: Rust support</a></h1>
<h2 id="outputs-4"><a class="header" href="#outputs-4">Outputs</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
A LambdaBuffers code generation module that outputs type definitions and derived implementations in the Rust programming language given a LambdaBuffers schema.
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Rust">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Rust</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Rust library that implements the LambdaBuffers Prelude runtime. This module would include standardised JSON encoding and equality implementations for all declared type class instances in the schema.
<ul>
<li>A Prelude library for Rust was implemented together with a separate library for Json trait instance derive macros. These can be found here:
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/runtimes/rust/lbr-prelude">runtimes/rust/lbr-prelude</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/runtimes/rust/lbr-prelude-derive">runtimes/rust/lbr-prelude-derive</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Rust test suite that assures the manually implemented and automatically generated implementations are consistent with the predefined LambdaBuffers Prelude golden data set of JSON files and perform correct implementation derivation.
<ul>
<li>A test suite was implemented with automatically generated Rust types and trait implementations for Prelude types, it can be found here: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-prelude/lbt-prelude-rust">testsuites/lbt-prelude/lbt-prelude-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Rust library that implements the LambdaBuffers Plutus runtime. This module would include standardised PlutusData encoding implementations for all declared type class instances in the Plutus schema.
<ul>
<li>A standalone library was implemented (still in active development) with Plutus ledger types. LambdaBuffers runtime functionality is included in this library: <a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust/tree/23eb5df1be03e5983865867f74a2933b7063414d">plutus-ledger-api-rust</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Rust test suite that assures the manually implemented and automatically generated implementations are consistent with the predefined LambdaBuffers Plutus golden data set of PlutusData encoded files and perform correct implementation derivation.
<ul>
<li>A test suite was implemented with automatically generated Rust types and trait implementations for Plutus types, it can be found here: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-plutus/lbt-plutus-rust">testsuites/lbt-plutus/lbt-plutus-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Nix devops modules (Nix API) for streamlining the LambdaBuffers code generation pipeline to Rust.
<ul>
<li>New flake modules were implemented to easily generate Rust crates from LambdaBuffers:
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-rust.nix">lbf-rust</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-prelude-rust.nix">lbf-prelude-rust</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-plutus-rust.nix">lbf-plutus-rust</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Documentation on LambdaBuffers usage patterns for Rust.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/rust.html">A new page was created for the Rust use case</a></li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-4"><a class="header" href="#acceptance-criteria-4">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
LambdaBuffers schemas that are based on the LambdaBuffers Prelude module can be used in Rust projects to specify application types.
<ul>
<li>Test libraries for Prelude demonstrate how Rust code for LambdaBuffers Prelude is generated to Rust and used in a library: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-prelude/lbt-prelude-rust">testsuites/lbt-prelude/lbt-prelude-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
LambdaBuffers schemas that are based on the LambdaBuffers Plutus module can be used in Rust projects to specify application types.
<ul>
<li>Test libraries for Plutus demonstrate how Rust code for LambdaBuffers Plutus is generated to Rust and used in a library: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-plutus/lbt-plutus-rust">testsuites/lbt-plutus/lbt-plutus-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The documentation and devops tooling is available to facilitate easy adoption.
<ul>
<li>Similarly to other languages supported by LambdaBuffers, a Rust flake is implemented. The testing libraries also serve as an example, to understand how to use these Nix utilities:
<a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-plutus/lbt-plutus-rust/build.nix">testsuites/lbt-plutus/lbt-plutus-rust/build.nix</a></li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-4"><a class="header" href="#evidence-of-milestone-completion-4">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Prelude runtime library is available for the Rust programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/runtimes/rust/lbr-prelude">runtimes/rust/lbr-prelude</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/runtimes/rust/lbr-prelude-derive">runtimes/rust/lbr-prelude-derive</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Plutus runtime library is available for the Rust programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust/tree/23eb5df1be03e5983865867f74a2933b7063414d">plutus-ledger-api-rust</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Prelude test suite is available and is passing in CI for the Rust programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-prelude/lbt-prelude-rust">testsuites/lbt-prelude/lbt-prelude-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Plutus test suite is available and is passing in CI for the Rust programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-plutus/lbt-plutus-rust">testsuites/lbt-plutus/lbt-plutus-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed Nix API for LambdaBuffers Rust support is available.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-rust.nix">lbf-rust</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-prelude-rust.nix">lbf-prelude-rust</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-plutus-rust.nix">lbf-plutus-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers for Rust documentation is available.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/rust.html">Rust documentation</a></li>
</ul>
</li>
</ul>
<h2 id="demo-files"><a class="header" href="#demo-files">Demo files</a></h2>
<ul>
<li>Demo project: <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-rust">lambda-buffers-for-cardano</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-2-javascripttypescript-support"><a class="header" href="#catalyst-milestone-2-javascripttypescript-support">Catalyst milestone 2: Javascript/Typescript support</a></h1>
<p>While the milestone technically requires Javascript support, we implemented <a href="https://www.typescriptlang.org/">Typescript</a> support which is a <a href="https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#a-typed-superset-of-javascript">typed superset of Javascript</a>. This was done to better interpolate with existing Javascript/Typescript libraries on Cardano such as <a href="https://github.com/spacebudz/lucid">lucid</a>, <a href="https://github.com/input-output-hk/cardano-js-sdk">cardano-js-sdk</a>, <a href="https://www.npmjs.com/package/@emurgo/cardano-serialization-lib-nodejs">cardano-serialization-lib</a>, etc. With Typescript support, we get Javascript support for free as the compilation from Typescript to Javascript is a well established practise.</p>
<h2 id="outputs-5"><a class="header" href="#outputs-5">Outputs</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A LambdaBuffers code generation module that outputs type constructors and derived implementations in the Javascript programming language given a LambdaBuffers schema.</p>
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/2e2ed98f4df7f207ec3cf131adf5b47b202e248f/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Typescript">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Typescript</a>.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A Javascript library that implements the LambdaBuffers Prelude runtime.
This module would include standardised JSON encoding and equality
implementations for all declared type class instances in the schema.</p>
<ul>
<li>A standalone Prelude library for Typescript was implemented together with its runtime for LambdaBuffers. These can be found here:
<ul>
<li><a href="https://github.com/mlabs-haskell/prelude-typescript">prelude-typescript</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/343a1a900f42dcf5b1c1a7e330eafb07c280908b/runtimes/typescript/lbr-prelude">runtimes/typescript/lbr-prelude</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A Javascript test suite that assures the manually implemented and automatically generated implementations are consistent with the predefined LambdaBuffers Prelude golden data set of JSON files and perform correct implementation derivation.</p>
<ul>
<li>A test suite ensuring that the manually implemented and automatically generated implementations can be found here: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/50bfbc4a182275d42be978b5a251530bab84f4aa/testsuites/lbt-prelude/lbt-prelude-typescript">testsuites/lbt-prelude/lbt-prelude-typescript</a>.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A Javascript library that implements the LambdaBuffers Plutus runtime. This module would include standardised PlutusData encoding implementations for all declared type class instances in the Plutus schema.</p>
<ul>
<li>A standalone Plutus library for Typescript was implemented together with its runtime for LambdaBuffers. These can be found here:
<ul>
<li><a href="https://github.com/mlabs-haskell/plutus-ledger-api-typescript">plutus-ledger-api-typescript</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/dc5ee6797d1230661d6bb3dfa658eddeadd7cb60/runtimes/typescript/lbr-plutus">runtimes/typescript/lbr-plutus</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A Javascript test suite that assures the manually implemented and automatically generated implementations are consistent with the predefined LambdaBuffers Plutus golden data set of PlutusData encoded files and perform correct implementation derivation.</p>
<ul>
<li>A test suite ensuring that the manually implemented and automatically generated implementations can be found here: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/50bfbc4a182275d42be978b5a251530bab84f4aa/testsuites/lbt-plutus/lbt-plutus-typescript">testsuites/lbt-plutus/lbt-plutus-typescript</a></li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Nix devops modules (Nix API) for streamlining the LambdaBuffers code generation pipeline to Javascript.</p>
<ul>
<li>New flake modules were implemented to easily generate NPM packages from LambdaBuffers
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/f59bdb78d06fa677567d053eddb3d1fe46250fd8/extras/lbf-nix/lbf-typescript.nix">lbf-typescript</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/f59bdb78d06fa677567d053eddb3d1fe46250fd8/extras/lbf-nix/lbf-prelude-typescript.nix">lbf-prelude-typescript</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/f59bdb78d06fa677567d053eddb3d1fe46250fd8/extras/lbf-nix/lbf-plutus-typescript.nix">lbf-plutus-typescript</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Documentation on LambdaBuffers usage patterns for Javascript.</p>
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/typescript.html">A new page was created for the TypeScript use case</a></li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-5"><a class="header" href="#acceptance-criteria-5">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
LambdaBuffers schemas that are based on the LambdaBuffers Prelude module can be used in Javascript projects to specify application types.
<ul>
<li>Test libraries for Prelude demonstrate how TypeScript code for the LambdaBuffers Prelude is generated to TypeScript and used in a library: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/50bfbc4a182275d42be978b5a251530bab84f4aa/testsuites/lbt-prelude/lbt-prelude-typescript">testsuites/lbt-prelude/lbt-prelude-typescript</a></li>
<li>Moreover, there is a <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/1d806a1710aab625ea520c596a72338c5bde578d/docs/typescript-prelude">docs/typescript-prelude</a> sample project which also demonstrates this.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
LambdaBuffers schemas that are based on the LambdaBuffers Plutus module can be used in Javascript projects to specify application types.
<ul>
<li>Test libraries for Plutus demonstrate how TypeScript code for the LambdaBuffers Prelude is generated to TypeScript and used in a library: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/50bfbc4a182275d42be978b5a251530bab84f4aa/testsuites/lbt-plutus/lbt-plutus-typescript">testsuites/lbt-plutus/lbt-plutus-typescript</a></li>
<li>Moreover, there is a <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/1d806a1710aab625ea520c596a72338c5bde578d/docs/typescript-plutus">docs/typescript-plutus</a> sample project which also demonstrates this.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The documentation and devops tooling is available to facilitate easy adoption.
<ul>
<li>Similarly to other languages supported by LambdaBuffers, a <a href="https://github.com/mlabs-haskell/flake-lang.nix/tree/5bb4fdf556a2f2f23717c654c186f13f28b9c277/flake-lang/typescript">TypeScript flake</a> is implemented along with its documentation.
The testing libraries also serve as an example to understand how to use the Nix utilities:
<a href="https://github.com/mlabs-haskell/lambda-buffers/blob/4c6304cf3a3a0c08bbb46e94532a293fdea513e9/testsuites/lbt-plutus/lbt-plutus-typescript/build.nix">testsuites/lbt-plutus/lbt-plutus-typescript/build.nix</a>.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-5"><a class="header" href="#evidence-of-milestone-completion-5">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Prelude runtime library is available for the Javascript programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/343a1a900f42dcf5b1c1a7e330eafb07c280908b/runtimes/typescript/lbr-prelude">runtimes/typescript/lbr-prelude</a></li>
<li><a href="https://github.com/mlabs-haskell/prelude-typescript">prelude-typescript</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Plutus runtime library is available for the Javascript programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/dc5ee6797d1230661d6bb3dfa658eddeadd7cb60/runtimes/typescript/lbr-plutus">runtimes/typescript/lbr-plutus</a></li>
<li><a href="https://github.com/mlabs-haskell/plutus-ledger-api-typescript">plutus-ledger-api-typescript</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Prelude test suite is available and is passing in CI for the Javascript programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/50bfbc4a182275d42be978b5a251530bab84f4aa/testsuites/lbt-prelude/lbt-prelude-typescript">testsuites/lbt-prelude/lbt-prelude-typescript</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Plutus test suite is available and is passing in CI for the Javascript programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/50bfbc4a182275d42be978b5a251530bab84f4aa/testsuites/lbt-plutus/lbt-plutus-typescript">testsuites/lbf-plutus/lbt-plutus-typescript</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed Nix API for LambdaBuffers Javascript support is available.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/f59bdb78d06fa677567d053eddb3d1fe46250fd8/extras/lbf-nix/lbf-typescript.nix">lbf-typescript</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/f59bdb78d06fa677567d053eddb3d1fe46250fd8/extras/lbf-nix/lbf-prelude-typescript.nix">lbf-prelude-typescript</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/f59bdb78d06fa677567d053eddb3d1fe46250fd8/extras/lbf-nix/lbf-plutus-typescript.nix">lbf-plutus-typescript</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The  completed and reviewed LambdaBuffers for Javascript documentation is available.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/typescript.html">TypeScript documentation</a> at <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/ecb7e0d115aafd5238ee4a24d340d55a440741ac/docs/typescript.md">docs/typescript.md</a></li>
</ul>
</li>
</ul>
<h2 id="demo-files-1"><a class="header" href="#demo-files-1">Demo files</a></h2>
<ul>
<li>Demo project: <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-typescript">lambda-buffers-for-cardano</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-3-aiken-integration-research-and-development"><a class="header" href="#catalyst-milestone-3-aiken-integration-research-and-development">Catalyst milestone 3: Aiken integration research and development</a></h1>
<h2 id="outputs-6"><a class="header" href="#outputs-6">Outputs</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Document describing Aiken integration and how PlutusData encodings can be provided by the Lambda Buffers toolkit.
NOTE: We cannot ignore the fact that the outcome of the research done in Milestone 3 could point to incompatibilities that make an Aiken integration with Lambda Buffers infeasible. Should that be the case, an in-depth technical explanation of the limitations will be provided.
<ul>
<li>The document can be found <a href="catalyst10-reports/../aiken-integration.html">here</a>.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-6"><a class="header" href="#acceptance-criteria-6">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The generated document describes all the technical components relevant to the integration of Aiken with Lambda Buffers, showing a good understanding of them and how they would be relevant to the intended integration.
<ul>
<li>The document discusses relevant technical components of Aiken integration with Lambda Buffers.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The generated document describes a clear technical path to integrate Aiken with Lambda buffers and, in addition or alternatively, an in-depth analysis of any limitations found.
<ul>
<li>The document discusses limitations of Aiken and its incompatibilities with Lambda Buffers along with workarounds when possible.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-6"><a class="header" href="#evidence-of-milestone-completion-6">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed "Lambda Buffers for Aiken - PlutusData encoding implementation provider" documentation is available.
<ul>
<li>Methods to workaround the incompatibilities of Aiken and Lambda Buffers where possible are provided in the document.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Alternatively, if Aiken integration proves to be infeasible:</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed documentation describing the Aiken limitations and their impact is available.
<ul>
<li>The discussion of the limitations and whether they are worthwhile are also included in the document.</li>
</ul>
</li>
</ul>
<h2 id="demo-files-2"><a class="header" href="#demo-files-2">Demo files</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The document <em><a href="catalyst10-reports/../aiken-integration.html">Aiken Research Document</a></em> addresses these outputs.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-4-separate-plutustx-backend-and-improvements-to-existing-lambdabuffers-facilities"><a class="header" href="#catalyst-milestone-4-separate-plutustx-backend-and-improvements-to-existing-lambdabuffers-facilities">Catalyst milestone 4: Separate PlutusTx backend and improvements to existing LambdaBuffers facilities</a></h1>
<h2 id="outputs-7"><a class="header" href="#outputs-7">Outputs</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A separate code generator for Haskell and PlutusTx</p>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A separate LambdaBuffers code generation module that outputs type definitions and derived implementations for Haskell's Prelude and PlutusTx's Prelude (or equivalent LambdaBuffers' Preludes) given a LambdaBuffers schema.</p>
<ul>
<li>
<p>The common files for code generation of both Haskell's Prelude and PlutusTx's Prelude can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell">here</a></p>
</li>
<li>
<p>The Haskell code generator implementation can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell.hs">here</a></p>
</li>
<li>
<p>The PlutusTx code generator implementation can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/src/LambdaBuffers/Codegen/PlutusTx.hs">here</a></p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A Haskell test suite that assures the manually implemented and automatically generated implementations are consistent with the predefined LambdaBuffers Prelude golden data set of JSON files and perform correct implementation derivation.</p>
<ul>
<li>The Haskell test suite can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/testsuites/lbt-prelude/lbt-prelude-haskell">here</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Nix devops modules (Nix API) for streamlining the LambdaBuffers code generation pipeline to either Haskell's Prelude or PlutusTx's Prelude.</p>
<ul>
<li>
<p>A Nix API for streamlining LambdaBuffers code generation Haskell's Prelude can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/extras/lbf-nix/build.nix#L17">here</a></p>
</li>
<li>
<p>The Nix API for streamlining LambdaBuffers code generation PlutusTx's Prelude can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/extras/lbf-nix/build.nix#L22">here</a>
or PlutusTx's Prelude can be found</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Documentation on LambdaBuffers usage patterns for Haskell's Prelude and PlutusTx's Prelude</p>
<ul>
<li>
<p>Documentation for Haskell's Prelude can be found <a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">here</a>.</p>
</li>
<li>
<p>Documentation for PlutusTx's Prelude can be found <a href="https://mlabs-haskell.github.io/lambda-buffers/plutustx.html">here</a>.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A complete Plutus .lbf schema file to include all Plutus Ledger API types with backend support for Rust, TypeScript, and PureScript.</p>
<ul>
<li>
<p>The <code>.lbf</code> schema file for V1 Plutus Ledger API can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/libs/lbf-plutus/Plutus/V1.lbf">here</a></p>
</li>
<li>
<p>The <code>.lbf</code> schema file for V2 Plutus Ledger API can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/libs/lbf-plutus/Plutus/V2.lbf">here</a></p>
</li>
<li>
<p>Rust backend support is given by the JSON file <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/data/rust-plutus-pla.json">here</a> where the types are provided by <a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust">this package</a>.</p>
</li>
<li>
<p>TypeScript backend support is given by the JSON file <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/data/typescript-plutus.json">here</a> where the types are provided by <a href="https://github.com/mlabs-haskell/plutus-ledger-api-typescript">this package</a></p>
</li>
<li>
<p>PureScript backend support is given by the JSON file <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/data/purescript-plutus-ctl.json">here</a> where the types are provided by <a href="https://github.com/Plutonomicon/cardano-transaction-lib">this package</a></p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
An extended integration test suite to verify that the manually implemented and automatically implemented instances of the updated LambdaBuffers' Plutus .lbf schema file are consistent across all backends.</p>
<ul>
<li>The extended integration test suite to verify that the manually implemented and automatically implemented instances of the updated LambdaBuffers' PlutusTx .lbf schema file are consistent across all backends can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/testsuites/lbt-plutus">here</a>.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A versioning scheme for the LambdaBuffers git repository using git tags that follow semantic versioning.</p>
<ul>
<li>
<p>A versioning scheme for the git repository using git tags that follows semantic versioning is given in the <a href="https://github.com/mlabs-haskell/lambda-buffers/releases">Releases page</a></p>
</li>
<li>
<p>Documentation for how the versioning scheme interplays with the monorepo setup is described in the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a></p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Optimized Nix build times.</p>
<ul>
<li>
<p>This was fixed in <a href="https://github.com/mlabs-haskell/lambda-buffers/pull/233">#233</a>.
It's well known that (in the version of Nix used with LambdaBuffers) <a href="https://github.com/NixOS/nix/issues/6626">large <code>flake.lock</code> files are a detriment to performance</a>.
So prior of #233, in e.g. <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/9ae3705f3f1a5c2506c7f86c8d5643c38d79e849">9ae3705f3f1a5c2506c7f86c8d5643c38d79e849</a>, we see that</p>
<pre><code class="language-bash">$ git checkout 9ae3705f3f1a5c2506c7f86c8d5643c38d79e849
$ time nix flake lock

real    0m27.437s
user    0m27.331s
sys     0m0.116s

$ wc -l flake.lock
44552 flake.lock
</code></pre>
<p>it takes almost 28 seconds to execute the <code>nix flake lock</code> command due to the almost 45000 lines large <code>flake.lock</code> file.</p>
<p>After the merge of #233, in e.g. <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/401f8a920a557c71440795174da199a1e128c4f9">401f8a920a557c71440795174da199a1e128c4f9</a>, we see significantly improved Nix performance</p>
<pre><code class="language-bash">$ git checkout 401f8a920a557c71440795174da199a1e128c4f9
$ time nix flake lock

real    0m1.423s
user    0m1.348s
sys     0m0.067s

$ wc -l flake.lock
11585 flake.lock
</code></pre>
<p>where it now takes only about 1.5 seconds to execute the <code>nix flake lock</code> command due to the significantly reduced <code>flake.lock</code> file size of being just under 12000 lines.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Error messages that follow the GNU error message format.</p>
<ul>
<li>This was implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers/pull/147">#147</a> and PR <a href="https://github.com/mlabs-haskell/lambda-buffers/pull/249">#249</a>. See below for examples of following the GNU error message format.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-7"><a class="header" href="#acceptance-criteria-7">Acceptance Criteria</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
An executable and Nix tooling to translate LambdaBuffers modules to Haskell projects to specify application types.</p>
<ul>
<li>
<p>An executable to translate LambdaBuffers modules to Haskell projects is given in the Nix attribute <code>lbf-prelude-to-haskell</code> defined <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-frontend/build.nix#L73-L86">here</a></p>
</li>
<li>
<p>Convenient Nix tooling to translate LambdaBuffers modules to Haskell projects is given in the Nix function <code>lbfPreludeHaskell</code> defined here <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/extras/lbf-nix/build.nix#L17">here</a></p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
An executable and Nix tooling to translate LambdaBuffers modules to PlutusTx projects to specify application types.</p>
<ul>
<li>
<p>An executable to translate LambdaBuffers modules to PlutusTx projects is given in the Nix attribute <code>lbf-plutus-to-plutustx</code> defined <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-frontend/build.nix#L124-L140">here</a></p>
</li>
<li>
<p>Convenient Nix tooling to translate LambdaBuffers modules to PlutusTx projects is given in the Nix function <code>lbfPlutusTx</code> defined here <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/extras/lbf-nix/build.nix#L22">here</a></p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
An updated LambdaBuffers Plutus schema for the complete Plutus Ledger API types.</p>
<ul>
<li>The updated LambdaBuffers Plutus schema for the complete Plutus Ledger API types can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/libs/lbf-plutus/Plutus">here</a></li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The documentation and devops tooling is available to facilitate easy adoption.</p>
<ul>
<li>
<p>The entire project's documentation can be found in the documentation website <a href="https://mlabs-haskell.github.io/lambda-buffers/">here</a></p>
</li>
<li>
<p>Devops tooling can be found in the form of Nix functions for conveniently creating Haskell or PlutusTx projects found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/extras/lbf-nix/build.nix#L14-L52">here</a>.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Git tags for official releases of LambdaBuffers.</p>
<ul>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/releases">releases page</a> contains git tags for official releases of LambdaBuffers.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-7"><a class="header" href="#evidence-of-milestone-completion-7">Evidence of Milestone Completion</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers code generator for Haskell's Prelude.</p>
<ul>
<li>
<p>The completed common files for code generation of both Haskell's Prelude and PlutusTx's Prelude can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell">here</a></p>
</li>
<li>
<p>The Haskell code generator implementation can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell.hs">here</a></p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers code generator for PlutusTx's Prelude.</p>
<ul>
<li>
<p>The completed common files for code generation of both Haskell's Prelude and PlutusTx's Prelude can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell">here</a></p>
</li>
<li>
<p>The PlutusTx code generator implementation can be found <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/2e2ff70f155ebcbac07b817f365f1220c24dfdf0/lambda-buffers-codegen/src/LambdaBuffers/Codegen/PlutusTx.hs">here</a></p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Benchmarks of the before and after optimized Nix build times.</p>
<ul>
<li>This was fixed in <a href="https://github.com/mlabs-haskell/lambda-buffers/pull/233">#233</a>, see above for benchmarks.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Demonstrations (in the form of screenshots or simply text) of error messages following the GNU error message format.</p>
<ul>
<li>We can see the following error messages follow the GNU error message format</li>
</ul>
<pre><code class="language-shell">$ lbf-prelude-to-haskell DoesNotExist.lbf
DoesNotExist.lbf: error: the provided module file DoesNotExist.lbf doesn't exist

$ cat TEST.lbf
module TEST

import Prelude (Eq, Json, Maybe, Either, List, Integer)

derive Eq What

$ lbf-prelude-to-haskell TEST.lbf
TEST.lbf:5.11-5.15: error: [module TEST] type What not found in the module's scope Either Integer List Maybe Prelude.Either Prelude.Integer Prelude.List Prelude.Maybe

$ cat ANOTHERTEST.lbf
module ANOTHERTEST

import Prelude (Eq, Json, Maybe, Either, List, Integer)

prod What = (Integer
derive Eq What

$ lbf-prelude-to-haskell ANOTHERTEST.lbf
ANOTHERTEST.lbf:6.7: error:
unexpected keyword
expecting s-expression
</code></pre>
</li>
</ul>
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<ul>
<li><a href="https://milestones.projectcatalyst.io/projects/1000122/milestones/4">Project Catalyst Milestone 4</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-5-final-project-scaffold-for-rust-javascript-and-haskell"><a class="header" href="#catalyst-milestone-5-final-project-scaffold-for-rust-javascript-and-haskell">Catalyst milestone 5 (FINAL): Project scaffold for Rust, JavaScript and Haskell</a></h1>
<h2 id="outputs-8"><a class="header" href="#outputs-8">Outputs</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A documented project scaffold that demonstrates the end-to-end use of LambdaBuffers with Rust, JavaScript, Haskell and PlutusTx language ecosystems.</p>
<ul>
<li>
<p>A project scaffold that demonstrates end-to-end use of LambdaBuffers with Rust can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-rust">here</a>.</p>
</li>
<li>
<p>A project scaffold that demonstrates end-to-end use of LambdaBuffers with JavaScript (TypeScript) can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-typescript">here</a>.</p>
</li>
<li>
<p>A project scaffold that demonstrates end-to-end use of LambdaBuffers with Haskell to create transactions can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-haskell">here</a>.</p>
</li>
<li>
<p>A project scaffold that demonstrates end-to-end use of LambdaBuffers with Haskell for onchain scripts using Plutarch can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/validation/demo-plutarch">here</a>.</p>
</li>
<li>
<p>A project scaffold that demonstrates end-to-end use of LambdaBuffers with PlutusTx for onchain scripts can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/validation/demo-plutustx">here</a>.</p>
</li>
<li>
<p>The LambdaBuffers schema used in all the aforementioned projects can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/api">here</a>.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Demonstrate how to use LambdaBuffers to manage and exchange JSON-based configuration between different language ecosystems supported by LambdaBuffers.</p>
<ul>
<li>
<p>The JSON-based configuration defined with LambdaBuffers is over <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/api/Demo/Config.lbf">here</a>.</p>
</li>
<li>
<p>The Rust transaction building project uses such JSON-based configuration over <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/transactions/demo-rust/src/main.rs">here</a>.</p>
</li>
<li>
<p>The JavaScript (TypeScript) transaction building project uses such JSON-based configuration in its testsuite <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/transactions/demo-typescript/src/tests/demo-test.ts">here</a>.</p>
</li>
<li>
<p>The Haskell project uses such JSON-based configuration over <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/transactions/demo-haskell/src/Demo/Config.hs">here</a>.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
More importantly, demonstrates how to use LambdaBuffers to specify and exchange Plutus Datum between Plutus scripting languages and transaction-building frameworks.</p>
<ul>
<li>
<p>A specification for Plutus Datum using LambdaBuffers is given <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/api/Demo/Plutus.lbf">here</a> where we see its usage in Plutus scripting languages and transaction-building frameworks in the following files:</p>
<ul>
<li>
<p>With the PlutusTx Plutus scripting language, we see it deserializes the <code>EqDatum</code> in the <code>eqValidator</code> defined <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/validation/demo-plutustx/src/Demo/Validation.hs">here</a>.</p>
</li>
<li>
<p>With the Plutarch Plutus scripting language, we see it deserializes the <code>EqDatum</code> in the <code>eqValidator</code> defined <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/validation/demo-plutarch/src/Demo/Validation.hs">here</a>.</p>
</li>
<li>
<p>With Rust, we can see it uses an <code>EqDatum</code> to build a transaction over <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/transactions/demo-rust/src/lib.rs">here</a>.</p>
</li>
<li>
<p>With TypeScript, we can see it uses an <code>EqDatum</code> to build a transaction over <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/transactions/demo-typescript/src/lib/index.ts">here</a>.</p>
</li>
<li>
<p>With Haskell, we can see it uses an <code>EqDatum</code> to build a transaction over <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/transactions/demo-haskell/src/Demo/Process.hs">here</a>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A fully tested and documented LambdaBuffers support for Rust, JavaScript, Haskell and PlutusTx language ecosystems.</p>
<ul>
<li>
<p>A full example project with LambdaBuffers complete with automated tests for Rust can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-rust">here</a>.</p>
</li>
<li>
<p>A full example project with LambdaBuffers complete with automated tests for JavaScript (TypeScript) can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-typescript">here</a>.</p>
</li>
<li>
<p>A full example project with LambdaBuffers complete with automated tests for Haskell (using Rust's tx-village library) can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-haskell">here</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-tx-village">here</a>.</p>
</li>
<li>
<p>A full example project with LambdaBuffers for creating validators with PlutusTx can be found <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/validation/demo-plutustx">here</a>.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A documented scaffold project that serves to demonstrate how to use LambdaBuffers with the newly supported languages for easy adoption.</p>
<ul>
<li>
<p>A scaffold project that serves to demonstrate how to use LambdaBuffers with the newly supported languages for easy adoption are given in the previous bullet point.</p>
</li>
<li>
<p>The <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/README.md"><code>README.md</code></a> serves as documentation for the scaffold projects which demonstrate how LambdaBuffers may be used with such languages.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Final close-out report.</p>
<ul>
<li>This document is the close-out report.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Final closeout video.</p>
<ul>
<li>Final closeout video can be found <a href="https://youtu.be/0NyBALSAin0">here</a>.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-8"><a class="header" href="#acceptance-criteria-8">Acceptance Criteria</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A LambdaBuffers scaffold repository is made available that demonstrates a working end-to-end use of LambdaBuffers with Rust, JavaScript, Haskell and PlutusTx language ecosystems.</p>
<ul>
<li>A LambdaBuffers scaffold repository that demonstrates a working end-to-end use of LambdaBuffers with Rust, JavaScript (TypeScript), Haskell, and PlutusTx is provided <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/">here</a>.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The scaffold uses LambdaBuffers to specify JSON configuration.</p>
<ul>
<li>The JSON-based configuration defined with LambdaBuffers is over <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/api/Demo/Config.lbf">here</a>.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The scaffold uses LambdaBuffers to specify Plutus Datum.</p>
<ul>
<li>The scaffold uses LambdaBuffers to specify Plutus Datum <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/blob/main/api/Demo/Plutus.lbf">here</a>.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Final closeout video is publicly available.</p>
<ul>
<li>Final closeout video that is publicly available can be found <a href="https://youtu.be/0NyBALSAin0">here</a>.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-8"><a class="header" href="#evidence-of-milestone-completion-8">Evidence of Milestone Completion</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange JSON based configuration between Rust, JavaScript, Haskell and PlutusTx language ecosystems.</p>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange JSON based configuration in Rust was implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/12">#12</a>.</p>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange JSON based configuration in JavaScript (TypeScript) was implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/18">#18</a>.</p>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange JSON based configuration in Haskell was implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/27">#27</a>.</p>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange JSON based configuration in PlutusTx was originally implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/1">#1</a> and more recently updated in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/25">#25</a>.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange Plutus Datums between Rust, JavaScript, Haskell and PlutusTx language ecosystems.</p>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange Plutus Datums configuration in Rust was implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/12">#12</a>.</p>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange Plutus Datums configuration in JavaScript (TypeScript) was implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/18">#18</a>.</p>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange Plutus Datums configuration in Haskell was implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/27">#27</a>.</p>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers scaffold project that uses LambdaBuffers to specify and exchange Plutus Datums configuration in PlutusTx was originally implemented in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/1">#1</a> and more recently updated in PR <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/pull/25">#25</a>.</p>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
We will record a video demonstrating the LambdaBuffers toolkit, how LambdaBuffers schemas are written and checked, and how code is generated from them in the newly supported programming languages.</p>
<ul>
<li>A video demonstrating the LambdaBuffers toolkit, how LambdaBuffers schemas are written and checked, and how code is generated from them in the newly supported programming languages can be found <a href="https://youtu.be/0NyBALSAin0">here</a>.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
We will publish a fully documented scaffold project that demonstrates how LambdaBuffers is used in Cardano dApp projects.</p>
<ul>
<li>The fully documented scaffold project that demonstrates how LambdaBuffers is used in Cardano dApp projects is in the <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/">lambda-buffers-for-cardano</a> repository.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
Link to final closeout video.</p>
<ul>
<li>Final closeout video can be found <a href="https://youtu.be/0NyBALSAin0">here</a>.</li>
</ul>
</li>
</ul>
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<ul>
<li><a href="https://milestones.projectcatalyst.io/projects/1000122/milestones/5">Project Catalyst Final Milestone</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-13-reports"><a class="header" href="#catalyst-13-reports">Catalyst 13 reports</a></h1>
<ul>
<li><a href="catalyst13-reports/milestone-1.html">Milestone 1: LambdaBuffers Conway support</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-1-lambdabuffers-conway-support"><a class="header" href="#catalyst-milestone-1-lambdabuffers-conway-support">Catalyst milestone 1: LambdaBuffers Conway support</a></h1>
<h2 id="outputs-9"><a class="header" href="#outputs-9">Outputs</a></h2>
<p>Implementation in repository:</p>
<ol>
<li>Implementing codegen for all modules (Haskell, Plutarch, PlutusTx, Rust, TypeScript, PureScript) for
all the new <a href="https://github.com/IntersectMBO/plutus/tree/master/plutus-ledger-api/src/PlutusLedgerApi/V3">Plutus Ledger types</a>.
This includes the new governance-related types, delegation types, and updated transaction types.</li>
<li>Create new golden tests for the above types, for all language modules. For instance, we will have a
set of files consisting of known-good JSON-serialized instances, and our testsuite will check that
our implementation outputs these serialized values upon execution as expected. Although an exhaustive
list of tests is not possible here, there are many Plutus types updated or new in V3 our library will
support such as Vote, Voter, TxOutRef, TxInInfo, TxCert, etc and various concrete instantiations of
each type to test - e.g., a VoteNo Vote, a VoteYes Vote, and so on.</li>
<li>Create new roundtrip tests for Eq, Json and PlutusData type classes (where applicable) that will
verify our type class instances serialise and deserialize without corruption, loss of information,
etc by converting values to JSON and back, PlutusData and back, and verifying equality withstands.</li>
<li>Implement new Plutus V3 types in plutus-ledger-api-rust and plutus-ledger-api-typescript</li>
<li>Documentation explaining the updates accomplished towards LambdaBuffers Conways support</li>
</ol>
<h2 id="acceptance-criteria-9"><a class="header" href="#acceptance-criteria-9">Acceptance Criteria</a></h2>
<ol>
<li>
<p>All Plutus V3 types are implemented correctly and LambdaBuffers now supports codegen for all the
supported language modules for these types:</p>
<ul>
<li>Both the Plutus Ledger APIs and codegen configurations are implemented
ensuring execution outputs are as intended</li>
</ul>
</li>
<li>
<p>All Plutus V3 types are covered by the golden tests ensuring execution outputs are as intended</p>
<ul>
<li>All languages use the same set of golden files to test against</li>
</ul>
</li>
<li>
<p>All Plutus V3 have roundtrip tests for Eq, Json and PlutusData type classes (where applicable)</p>
<ul>
<li>All languages have roundtrip tests (where applicable) to tests Json and PlutusData serialization</li>
</ul>
</li>
<li>
<p>The output is suitable for Plutus V3 Types such as Voter, Delegatee and GovernanceActionID etc.</p>
<ul>
<li>All new Plutus V3 types have been implemented in the supporting libraries</li>
</ul>
</li>
<li>
<p>Documentation will cover new type support across Lambda buffer supported languages and will
appear on <a href="https://mlabs-haskell.github.io/lambda-buffers/">https://mlabs-haskell.github.io/lambda-buffers</a> in the Catalyst Milestone F13 reporting.</p>
<ul>
<li>Documentation of the newly implemented Plutus V3 types were auto-generated</li>
</ul>
</li>
</ol>
<h2 id="evidence-of-milestone-completion-9"><a class="header" href="#evidence-of-milestone-completion-9">Evidence of Milestone Completion</a></h2>
<ul>
<li>
<p>Proof of Achievement 1: Codegen implementation will be added to the github.com/mlabs-haskell/lambda-buffers repository and a link will be provided.</p>
<ul>
<li>Codegen configuration files for all languages are augmented with the new Plutus V3 types, pointing the opaque types to their respective type declarations in libraries.
Users of the LambdaBuffers library can now use V3 types in their schemas, and generate code for all the supported languages:
<ul>
<li>Haskell (with Haskell Prelude) PlutusTx codegen config: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/lambda-buffers-codegen/data/haskell-plutus-plutustx.json">lambda-buffers-codegen/data/haskell-plutus-plutustx.json</a></li>
<li>Plutarch codegen config: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/lambda-buffers-codegen/data/plutarch-plutus.json">lambda-buffers-codegen/data/plutarch-plutus.json</a></li>
<li>PlutusTx (with Plutus Prelude) codegen config: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/lambda-buffers-codegen/data/plutustx-plutus.json">lambda-buffers-codegen/data/plutustx-plutus.json</a></li>
<li>Rust codegen config: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/lambda-buffers-codegen/data/rust-plutus-pla.json">lambda-buffers-codegen/data/rust-plutus-pla.json</a></li>
<li>TypeScript codegen config: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/lambda-buffers-codegen/data/typescript-plutus.json">lambda-buffers-codegen/data/typescript-plutus.json</a></li>
<li>PureScript CTL codegen config: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/lambda-buffers-codegen/data/purescript-plutus-ctl.json">lambda-buffers-codegen/data/purescript-plutus-ctl.json</a>
(some types are not supported by CTL itself, so naturally these are marked as NotImplemented in the configuration file)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Proof of Achievement 2: Rust plutus-ledger-api types and golden tests will be implemented in
<a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust">https://github.com/mlabs-haskell/plutus-ledger-api-rust</a> and a link will be provided.</p>
<ul>
<li>Golden tests for added types can be found here:
<ul>
<li>Haskell: Golden files are generated by this module and all the other language modules are reading these. All data types have golden files for Json and PlutusData serialisation. Added data types:
PlutusV3.TxOutRef, PlutusV3.ColdCommitteeCredential, PlutusV3.HotCommitteeCredential, PlutusV3.DRepCredential, PlutusV3.DRep, PlutusV3.Delegatee, PlutusV1.Lovelace, PlutusV3.TxCert, PlutusV3.Voter,
PlutusV3.Vote, PlutusV3.GovernanceActionId, PlutusV3.Committee, PlutusV3.Constitution, PlutusV3.ProtocolVersion, PlutusV3.ChangedParameters, PlutusV3.GovernanceAction, PlutusV3.ProposalProcedure,
PlutusV3.ScriptPurpose, PlutusV3.ScriptInfo, PlutusV3.TxInInfo, PlutusV3.TxInfo, PlutusV3.ScriptContext
<ul>
<li>Golden data: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-haskell/src/Test/LambdaBuffers/Plutus/Golden.hs">testsuites/lbt-plutus/lbt-plutus-haskell/src/Test/LambdaBuffers/Plutus/Golden.hs</a></li>
<li>PlutusData tests: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-haskell/test/Test/LambdaBuffers/Runtime/Plutus/PlutusData.hs">testsuites/lbt-plutus/lbt-plutus-haskell/test/Test/LambdaBuffers/Runtime/Plutus/PlutusData.hs</a></li>
<li>Json tests: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-haskell/test/Test/LambdaBuffers/Runtime/Plutus/Json.hs">testsuites/lbt-plutus/lbt-plutus-haskell/test/Test/LambdaBuffers/Runtime/Plutus/Json.hs</a></li>
<li><a href="catalyst13-reports/ci-logs/szpr3fx8yk3bpl76yrc7gxndx24w97i3-lbt-plutus-haskell-test-tests-0.1.0.0-check.drv.log">CI test logs</a></li>
</ul>
</li>
<li>Plutarch: Files are read, deserialised to Plutarch and serialised back again to verify correctness. Only PlutusData serialisation is tested as Plutarch doesn't handle Json.
<ul>
<li>PlutusData tests: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-plutarch/test/Test/LambdaBuffers/Runtime/Plutarch/PlutusData.hs">testsuites/lbt-plutus/lbt-plutus-plutarch/test/Test/LambdaBuffers/Runtime/Plutarch/PlutusData.hs</a></li>
<li><a href="catalyst13-reports/ci-logs/4n52lchdrnkmc73l10mgvv9j04ykkq9v-lbt-plutus-plutarch-test-tests-0.1.0.0-check.drv.log">CI test logs</a></li>
</ul>
</li>
<li>PlutusTx: Files are read, deserialised to PlutusData and applied to Plutus Scripts. In these Plutus Scripts, we also do roundtrip tests, deserialising and serialising the data to ensure compatibility.
Only PlutusData serialisation is tested as PlutusTx doesn't handle Json.
<ul>
<li>Plutus Scripts: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-plutustx/test/Test/LambdaBuffers/Runtime/PlutusTx/PlutusTx.hs">testsuites/lbt-plutus/lbt-plutus-plutustx/test/Test/LambdaBuffers/Runtime/PlutusTx/PlutusTx.hs</a></li>
<li>PlutusData tests: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-plutustx/test/Test/LambdaBuffers/Runtime/PlutusTx/PlutusData.hs">testsuites/lbt-plutus/lbt-plutus-plutustx/test/Test/LambdaBuffers/Runtime/PlutusTx/PlutusData.hs</a></li>
<li><a href="catalyst13-reports/ci-logs/crnl10qhhrzw8hixzgjs7w6z5ckwy28j-lbt-plutus-plutustx-test-tests-0.1.0.0-check.drv.log">CI test logs</a></li>
</ul>
</li>
<li>Rust: Equivalent Rust golden data is implemented and compared with the ones generated by the Haskell module. Both Json and PlutusData serialisations are tested.
<ul>
<li>Golden data: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-rust/tests/goldens.rs">testsuites/lbt-plutus/lbt-plutus-rust/tests/goldens.rs</a></li>
<li>PlutusData and Json tests: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-rust/tests/main.rs">testsuites/lbt-plutus/lbt-plutus-rust/tests/main.rs</a></li>
<li><a href="catalyst13-reports/ci-logs/lvrm5lf8rzlg06sahbd9j4sdh7axa99j-lbt-plutus-nextest-0.1.0.drv.log">CI test logs</a></li>
</ul>
</li>
<li>TypeScript: Equivalent TypesScript golden data is implemented and compared with the ones generated by the Haskell module. Both Json and PlutusData serialisations are tested.
<ul>
<li>Golden data: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-typescript/src/Goldens.ts">testsuites/lbt-plutus/lbt-plutus-typescript/src/Goldens.ts</a></li>
<li>PlutusData tests: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-typescript/src/PlutusData-test.ts">testsuites/lbt-plutus/lbt-plutus-typescript/src/PlutusData-test.ts</a></li>
<li>Json tests: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-typescript/src/Json-test.ts">testsuites/lbt-plutus/lbt-plutus-typescript/src/Json-test.ts</a></li>
<li><a href="catalyst13-reports/ci-logs/xi4npf8jnag34a7kmblg8ilgmidvsqa9-lbt-plutus-typescript.drv.log">CI test logs</a></li>
</ul>
</li>
<li>PureScript: Unfortunately the PureScript ledger API only partially supports V3 types. Furthermore, it does not have Json and PlutusData instances consistently,
thus golden testing was out of scope</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Proof of Achievement 3: Plutus V3 roundtrip tests located at <a href="https://github.com/mlabs-haskell/lambda-buffers">https://github.com/mlabs-haskell/lambda-buffers</a> repo and a link will be provided.</p>
<ul>
<li>Roundtrip tests were implemented and can be found here:
<ul>
<li>Haskell
<ul>
<li>PlutusData: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-haskell/test/Test/LambdaBuffers/Runtime/Plutus/PlutusData.hs">https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-haskell/test/Test/LambdaBuffers/Runtime/Plutus/PlutusData.hs</a></li>
<li>Json: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-haskell/test/Test/LambdaBuffers/Runtime/Plutus/Json.hs">https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-haskell/test/Test/LambdaBuffers/Runtime/Plutus/Json.hs</a></li>
</ul>
</li>
<li>Plutarch: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-plutarch/test/Test/LambdaBuffers/Runtime/Plutarch/PlutusData.hs">testsuites/lbt-plutus/lbt-plutus-plutarch/test/Test/LambdaBuffers/Runtime/Plutarch/PlutusData.hs</a></li>
<li>PlutusTx: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-plutustx/test/Test/LambdaBuffers/Runtime/PlutusTx/PlutusTx.hs">testsuites/lbt-plutus/lbt-plutus-plutustx/test/Test/LambdaBuffers/Runtime/PlutusTx/PlutusTx.hs</a></li>
<li>Rust
<ul>
<li>PlutusData and Json: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-rust/tests/main.rs">testsuites/lbt-plutus/lbt-plutus-rust/tests/main.rs</a></li>
<li>Property based tests for PlutusData: <a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust/blob/v3.0.2/plutus-ledger-api/tests/plutus_data.rs">https://github.com/mlabs-haskell/plutus-ledger-api-rust/blob/v3.0.2/plutus-ledger-api/tests/plutus_data.rs</a></li>
<li>Property based tests for Json: <a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust/blob/v3.0.2/plutus-ledger-api/tests/lbf.rs">https://github.com/mlabs-haskell/plutus-ledger-api-rust/blob/v3.0.2/plutus-ledger-api/tests/lbf.rs</a></li>
</ul>
</li>
<li>TypeScript
<ul>
<li>PlutusData: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-typescript/src/PlutusData-test.ts">testsuites/lbt-plutus/lbt-plutus-typescript/src/PlutusData-test.ts</a></li>
<li>Json: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/testsuites/lbt-plutus/lbt-plutus-typescript/src/Json-test.ts">testsuites/lbt-plutus/lbt-plutus-typescript/src/Json-test.ts</a></li>
<li>Property based tests for PlutusData and Json: <a href="https://github.com/mlabs-haskell/plutus-ledger-api-typescript/blob/v3.2.1/src/Tests/V3">https://github.com/mlabs-haskell/plutus-ledger-api-typescript/blob/v1.2.1/src/Tests/V3</a></li>
</ul>
</li>
<li>PureScript: Unfortunately the PureScript ledger API only partially supports V3 types. Furthermore, it does not have Json and PlutusData instances consistently,
thus roundtrip testing was out of scope</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Proof of Achievement 4: Plutus V3 types located at <a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust">https://github.com/mlabs-haskell/plutus-ledger-api-rust</a>
<a href="https://github.com/mlabs-haskell/plutus-ledger-api-typescript">https://github.com/mlabs-haskell/plutus-ledger-api-typescript</a> and links provided.</p>
<ul>
<li>Plutus_Ledger API Rust implementation was implemented here: <a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust/tree/v3.0.2/plutus-ledger-api/src/v3">mlabs-haskell/plutus-ledger-api-rust v3.0.2</a></li>
<li>Plutus_Ledger API TypeScript implementation was implemented here: <a href="https://github.com/mlabs-haskell/plutus-ledger-api-typescript/tree/v1.2.1/src/Lib/V3">mlabs-haskell/plutus-ledger-api-typescript v1.2.1</a></li>
</ul>
</li>
<li>
<p>Proof of Achievement 5: Page addressing the new Documentation on types for Catalyst Fund 13 at <a href="https://mlabs-haskell.github.io/lambda-buffers">https://mlabs-haskell.github.io/lambda-buffers</a></p>
<ul>
<li>Documentation of plutus-ledger-api-rust V3 types is located here: <a href="https://mlabs-haskell.github.io/plutus-ledger-api-rust/plutus_ledger_api/v3">https://mlabs-haskell.github.io/plutus-ledger-api-rust/plutus_ledger_api/v3</a></li>
<li>Documentation of plutus-ledger-api-typescript V3 types is located here: <a href="https://mlabs-haskell.github.io/plutus-ledger-api-typescript/modules/plutus_ledger_api_V3_js.html">https://mlabs-haskell.github.io/plutus-ledger-api-typescript/modules/plutus_ledger_api_V3_js</a></li>
<li>Conway compatibility report <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/docs/catalyst13-reports/milestone-1.md">docs/catalyst13-reports/milestone-1.md</a></li>
<li>Updated <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano">lambda-buffers-for-cardano</a> repository and documentation</li>
<li>Updated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/v2.0.0/CHANGELOG.md">Changelog</a></li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
