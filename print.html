<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lambda Buffers documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="using-lambdabuffers.html"><strong aria-hidden="true">2.</strong> Using LambdaBuffers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell.html"><strong aria-hidden="true">2.1.</strong> LambdaBuffers to Haskell</a></li><li class="chapter-item expanded "><a href="purescript.html"><strong aria-hidden="true">2.2.</strong> LambdaBuffers to Purescript</a></li><li class="chapter-item expanded "><a href="plutarch.html"><strong aria-hidden="true">2.3.</strong> LambdaBuffers to Plutarch</a></li><li class="chapter-item expanded "><a href="rust.html"><strong aria-hidden="true">2.4.</strong> LambdaBuffers to Rust</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">3.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="design.html"><strong aria-hidden="true">4.</strong> Design</a></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">5.</strong> API</a></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">6.</strong> LambdaBuffers Frontend (.lbf) syntax</a></li><li class="chapter-item expanded "><a href="compiler.html"><strong aria-hidden="true">7.</strong> Compiler</a></li><li class="chapter-item expanded "><a href="codegen.html"><strong aria-hidden="true">8.</strong> Codegen</a></li><li class="chapter-item expanded "><a href="command-line-interface.html"><strong aria-hidden="true">9.</strong> Command line interface</a></li><li class="chapter-item expanded "><a href="comparison-matrix.html"><strong aria-hidden="true">10.</strong> Comparison matrix</a></li><li class="chapter-item expanded "><a href="catalyst-reports.html"><strong aria-hidden="true">11.</strong> Catalyst reports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="catalyst09-reports/index.html"><strong aria-hidden="true">11.1.</strong> Catalyst 9 reports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="catalyst09-reports/milestone-1.html"><strong aria-hidden="true">11.1.1.</strong> Milestone 1: Research</a></li><li class="chapter-item expanded "><a href="catalyst09-reports/milestone-2.html"><strong aria-hidden="true">11.1.2.</strong> Milestone 2: End to end proof of concept</a></li><li class="chapter-item expanded "><a href="catalyst09-reports/milestone-3.html"><strong aria-hidden="true">11.1.3.</strong> Milestone 3: Testing and documentation</a></li><li class="chapter-item expanded "><a href="catalyst09-reports/milestone-3.html"><strong aria-hidden="true">11.1.4.</strong> Milestone 4: Project adoption</a></li></ol></li><li class="chapter-item expanded "><a href="catalyst10-reports/index.html"><strong aria-hidden="true">11.2.</strong> Catalyst 10 reports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="catalyst10-reports/milestone-1.html"><strong aria-hidden="true">11.2.1.</strong> Milestone 1: Rust support</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lambda Buffers documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lambda-buffers-introduction"><a class="header" href="#lambda-buffers-introduction">Lambda Buffers introduction</a></h1>
<p><img src="./images/lambda-buffers-banner.png" alt="LambdaBuffers banner" /></p>
<p><em>LambdaBuffers</em> is a schema language (similar to ProtoBuffers, ADL, ASN.1, JSON
Schema, etc.) and associated code generation toolkit. The goal of this project
is to provide developers tools to define algebraic data types in a
language-agnostic format such that shared data types can be declared in one
place while maintaining compatibility across a plethora of supported languages.</p>
<p>Users may refer to the <a href="./comparison-matrix.html">comparison matrix</a> for an
in-depth comparison of LambdaBuffers' features against the feature-set of other
popular schema-languages.</p>
<p>At a glance, you may wish to choose LambdaBuffers instead of one of its
competitors if your project requires:</p>
<ol>
<li>
<p><em>Parameterized Data Types</em> (aka. type functions): Unlike ProtoBuffers or
JSON Schema, LambdaBuffers allows users to define algebraic data types which
take type variable arguments. If your project's domain is most accurately
represented by parameterized data types, LambdaBuffers may be a good choice
for your needs.</p>
</li>
<li>
<p><em>Opaque Types</em>: Almost every competing schema language provides users a
fixed set of builtin or primitive types, which are handled in a special
manner by the code generation and cannot be extended. LambdaBuffers, by
contrast, allows users to add their own builtin types and extend the
existing code generation framework to handle those builtins in a manner
intended by the users. There are no <em>special</em> primitive types in
LambdaBuffers; a user-defined primitive type is defined in exactly the same
way (i.e. as an <code>opaque</code> type) as a LambdaBuffers "builtin".</p>
</li>
<li>
<p><em>Typeclass Support</em>: While nearly every schema language supports generating
type definitions in supported target languages, to our knowledge no schema
language supports generating commonly used functions that operate on those
types. Unlike other schema languages, LambdaBuffers supports code generation
for <em>typeclass instances</em> (or the equivalent in languages that lack support
for typeclasses) to reduce the amount of boilerplate required to
productively make use of the generated types. While LambdaBuffers is still a
work-in-progress, we expect that, upon completion, an extensive test suite
will provide a high degree of assurance that the instances/methods generated
by the LambdaBuffers code generator behave identically.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-lambdabuffers"><a class="header" href="#using-lambdabuffers">Using LambdaBuffers</a></h1>
<p>LambdaBuffers heavily relies on Nix to orchestrate code generation and dependency management.
If you don't have Nix installed with flakes enabled, please refer to the
<a href="getting-started.html">Getting Started</a> guide.</p>
<p>To set up a project with LambdaBuffers and multi-language stack, refer to our demo project at <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano">lambda-for-cardano</a>.</p>
<p>To see, how LambdaBuffers code is transpiled into other languages, see:</p>
<ul>
<li><a href="haskell.html">LambdaBuffers to Haskell</a></li>
<li><a href="purescript.html">LambdaBuffers to Purescript</a></li>
<li><a href="plutarch.html">LambdaBuffers to Plutarch</a></li>
<li><a href="rust.html">LambdaBuffers to Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-to-haskell"><a class="header" href="#lambdabuffers-to-haskell">LambdaBuffers to Haskell</a></h1>
<p>Let's take a look at how LambdaBuffers modules map into Haskell modules and how
LambdaBuffers type definitions map into Haskell type definitions.</p>
<p>We'll use the <code>lbf-prelude-to-haskell</code> CLI tool which is just a convenient wrapper over
the raw <code>lbf</code> CLI. We can get this tool by either loading the LambdaBuffers Nix
environment that comes packaged with all the CLI tools:</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf&lt;tab&gt;
lbf                        lbf-plutus-to-purescript   lbf-prelude-to-purescript
lbf-plutus-to-haskell      lbf-prelude-to-haskell
</code></pre>
<p>Or we can simply just refer directly to the <code>lbf-prelude-to-haskell</code> CLI by <code>nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-haskell</code>.</p>
<p>In this chapter, we're going to use the latter option.</p>
<p>Let's now use <code>lbf-prelude-to-haskell</code> to process the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/examples/Document.lbf">Document.lbf</a> schema.</p>
<pre><code class="language-purescript">module Document

-- Importing types
import Prelude (Text, List, Set, Bytes)

-- Author
sum Author = Ivan | Jovan | Savo

-- Reviewer
sum Reviewer = Bob | Alice

-- Document
record Document a = {
  author : Author,
  reviewers : Set Reviewer,
  content : Chapter a
 }

-- Chapter
record Chapter a = {
  content : a,
  subChapters : List (Chapter a)
 }

-- Some actual content
sum RichContent = Image Bytes | Gif Bytes | Text Text

-- Rich document
prod RichDocument = (Document RichContent)
</code></pre>
<pre><code class="language-shell">$ nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-haskell -- Document.lbf
$ find autogen/
autogen/
autogen/LambdaBuffers
autogen/LambdaBuffers/Document.hs
autogen/build.json
</code></pre>
<p>As we can see the <code>autogen</code> directory has been created that contains the generated Haskell modules.
Note the <code>autogen/build.json</code> file as it contains all the necessary Hackage dependencies the generated module needs in order to be properly compiled by GHC.</p>
<p>The outputted Haskell module in <code>autogen/LambdaBuffers/Document.hs</code>:</p>
<pre><code class="language-haskell">module LambdaBuffers.Document (Author(..)
                              , Chapter(..)
                              , Document(..)
                              , Reviewer(..)
                              , RichContent(..)
                              , RichDocument(..)) where

import qualified LambdaBuffers.Prelude
import qualified Prelude


data Author = Author'Ivan  | Author'Jovan  | Author'Savo  deriving Prelude.Show

data Chapter a = Chapter { chapter'content :: a
                         , chapter'subChapters :: LambdaBuffers.Prelude.List (Chapter a)} deriving Prelude.Show

data Document a = Document { document'author :: Author
                           , document'reviewers :: LambdaBuffers.Prelude.Set Reviewer
                           , document'content :: Chapter a} deriving Prelude.Show

data Reviewer = Reviewer'Bob  | Reviewer'Alice  deriving Prelude.Show

data RichContent = RichContent'Image LambdaBuffers.Prelude.Bytes
                    | RichContent'Gif LambdaBuffers.Prelude.Bytes
                    | RichContent'Text LambdaBuffers.Prelude.Text deriving Prelude.Show

newtype RichDocument = RichDocument (Document RichContent) deriving Prelude.Show
</code></pre>
<p>We can compile the code with the following commands.
Note the dev shell <code>dev-prelude-haskell</code> as it includes the <code>LambdaBuffers.Prelude</code> dependency.</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#dev-prelude-haskell
$ ghc autogen/LambdaBuffers/Document.hs
[1 of 1] Compiling LambdaBuffers.Document ( autogen/LambdaBuffers/Document.hs, autogen/LambdaBuffers/Document.o )
</code></pre>
<h2 id="sum-types"><a class="header" href="#sum-types">Sum types</a></h2>
<p>The types <code>Author</code>, <code>Reviewer</code>, and <code>RichContent</code> have been declared as sum types in the LambdaBuffers schema using the <code>sum</code> keyword.</p>
<p>As we can see, nothing too surprising here, all the <code>sum</code> types become <code>data</code>
in Haskell.</p>
<p>The only thing to notice is that the type name was prepended with <code>'</code> (single
quote) to the defined constructor names as to make sure they are unique.</p>
<h2 id="product-types"><a class="header" href="#product-types">Product types</a></h2>
<p>The type <code>RichDocument</code> have been declared as a product type in the
LambdaBuffers schema using the <code>prod</code> keyword.</p>
<p>They become Haskell <code>newtype</code> if they have a single type in their body, otherwise they are <code>data</code>.</p>
<p>Note that the constructor has the same name as the type.</p>
<h2 id="record-types"><a class="header" href="#record-types">Record types</a></h2>
<p>The types <code>Document</code> and <code>Chapter</code> have been declared as record types in the
LambdaBuffers schema using the <code>record</code> keyword.</p>
<p>Like with product types, they become Haskell <code>newtype</code> if they have a single
type in their body, otherwise they are <code>data</code>.</p>
<p>Also like with product types, the constructor has the same name as the type.</p>
<p>The field names, similar to sum constructor names, are prepended with the
lowercased name of the type with a single quote (<code>'</code>) to maintain uniqueness.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-to-purescript"><a class="header" href="#lambdabuffers-to-purescript">LambdaBuffers to Purescript</a></h1>
<p>Let's take a look at how LambdaBuffers modules map into Purescript modules and how
LambdaBuffers type definitions map into Purescript type definitions.</p>
<p>We'll use the <code>lbf-prelude-to-purescript</code> CLI tool which is just a convenient wrapper over
the raw <code>lbf</code> CLI. We can get this tool by either loading the LambdaBuffers Nix
environment that comes packaged with all the CLI tools:</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf&lt;tab&gt;
lbf                        lbf-plutus-to-purescript   lbf-prelude-to-purescript
lbf-plutus-to-haskell      lbf-prelude-to-haskell
</code></pre>
<p>Or we can simply just refer directly to the <code>lbf-prelude-to-purescript</code> CLI by <code>nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-purescript</code>.</p>
<p>In this chapter, we're going to use the latter option.</p>
<p>Let's now use <code>lbf-prelude-to-purescript</code> to process the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/examples/Document.lbf">Document.lbf</a> schema</p>
<pre><code class="language-purescript">module Document

-- Importing types
import Prelude (Text, List, Set, Bytes)

-- Author
sum Author = Ivan | Jovan | Savo

-- Reviewer
sum Reviewer = Bob | Alice

-- Document
record Document a = {
  author : Author,
  reviewers : Set Reviewer,
  content : Chapter a
 }

-- Chapter
record Chapter a = {
  content : a,
  subChapters : List (Chapter a)
 }

-- Some actual content
sum RichContent = Image Bytes | Gif Bytes | Text Text

-- Rich document
prod RichDocument = (Document RichContent)
</code></pre>
<pre><code class="language-shell">$ nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-purescript -- Document.lbf
$ find autogen/
autogen/
autogen/build.json
autogen/LambdaBuffers
autogen/LambdaBuffers/Document.purs
</code></pre>
<p>As we can see the <code>autogen</code> directory has been created that contains the generated Purescript modules.
Note the <code>autogen/build.json</code> file as it contains all the necessary dependencies the generated module needs in order to be properly compiled by <code>purs</code> compiler.</p>
<p>The outputted Purescript module in <code>autogen/LambdaBuffers/Document.hs</code>:</p>
<pre><code class="language-purescript">module LambdaBuffers.Document (Author(..)
                              , Chapter(..)
                              , Document(..)
                              , Reviewer(..)
                              , RichContent(..)
                              , RichDocument(..)) where

import LambdaBuffers.Prelude as LambdaBuffers.Prelude
import Data.Generic.Rep as Data.Generic.Rep
import Data.Newtype as Data.Newtype
import Data.Show as Data.Show
import Data.Show.Generic as Data.Show.Generic


data Author = Author'Ivan  | Author'Jovan  | Author'Savo 
derive instance Data.Generic.Rep.Generic Author _
instance Data.Show.Show Author where
  show = Data.Show.Generic.genericShow

newtype Chapter a = Chapter { content :: a
                            , subChapters :: LambdaBuffers.Prelude.List (Chapter a)}
derive instance Data.Newtype.Newtype (Chapter a) _
derive instance Data.Generic.Rep.Generic (Chapter a) _
instance (Data.Show.Show a) =&gt; Data.Show.Show (Chapter a) where
  show = Data.Show.Generic.genericShow

newtype Document a = Document { author :: Author
                              , reviewers :: LambdaBuffers.Prelude.Set Reviewer
                              , content :: Chapter a}
derive instance Data.Newtype.Newtype (Document a) _
derive instance Data.Generic.Rep.Generic (Document a) _
instance (Data.Show.Show a) =&gt; Data.Show.Show (Document a) where
  show = Data.Show.Generic.genericShow

data Reviewer = Reviewer'Bob  | Reviewer'Alice 
derive instance Data.Generic.Rep.Generic Reviewer _
instance Data.Show.Show Reviewer where
  show = Data.Show.Generic.genericShow

data RichContent = RichContent'Image LambdaBuffers.Prelude.Bytes
                    | RichContent'Gif LambdaBuffers.Prelude.Bytes
                    | RichContent'Text LambdaBuffers.Prelude.Text
derive instance Data.Generic.Rep.Generic RichContent _
instance Data.Show.Show RichContent where
  show = Data.Show.Generic.genericShow

newtype RichDocument = RichDocument (Document RichContent)
derive instance Data.Newtype.Newtype RichDocument _
derive instance Data.Generic.Rep.Generic RichDocument _
instance Data.Show.Show RichDocument where
  show = Data.Show.Generic.genericShow
</code></pre>
<h2 id="sum-types-1"><a class="header" href="#sum-types-1">Sum types</a></h2>
<p>The types <code>Author</code>, <code>Reviewer</code>, and <code>RichContent</code> have been declared as sum types in the LambdaBuffers schema using the <code>sum</code> keyword.</p>
<p>As we can see, nothing too surprising here, all the <code>sum</code> types become <code>data</code>
in Purescript.</p>
<p>The only thing to notice is that the type name was prepended with <code>'</code> (single
quote) to the defined constructor names as to make sure they are unique.</p>
<h2 id="product-types-1"><a class="header" href="#product-types-1">Product types</a></h2>
<p>The type <code>RichDocument</code> have been declared as a product type in the
LambdaBuffers schema using the <code>prod</code> keyword.</p>
<p>They become Purescript <code>newtype</code> if they have a single type in their body, otherwise they are <code>data</code>.</p>
<p>Note that the constructor has the same name as the type.</p>
<h2 id="record-types-1"><a class="header" href="#record-types-1">Record types</a></h2>
<p>The types <code>Document</code> and <code>Chapter</code> have been declared as record types in the
LambdaBuffers schema using the <code>record</code> keyword.</p>
<p>They always become Purescript <code>newtype</code>, and wrapped within is a Purescript
record type with the fields named exactly like they are named in the
LambdaBuffers source module.</p>
<p>Also like with product types, the constructor has the same name as the type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-for-plutarch"><a class="header" href="#lambdabuffers-for-plutarch">LambdaBuffers for Plutarch</a></h1>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus">Plutarch</a> is a typed eDSL in Haskell for writing efficient Plutus Core validators.</p>
<p>LambdaBuffers creates Plutarch type definitions and associated Plutarch type class implementations for <a href="plutarch.html#plutustype">PlutusType</a>, <a href="plutarch.html#pisdata">PIsData</a> and <a href="plutarch.html#pshow">PShow</a> classes.</p>
<p>Additionally, when instructed by a LambdaBuffers <code>derive</code> statement type class implementations for <a href="plutarch.html#peq">PEq</a> and <a href="plutarch.html#ptryfrom">PTryFrom</a> are also printed.</p>
<p>A small example:</p>
<pre><code class="language-shell">❯ nix develop github:mlabs-haskell/lambda-buffers#dev-plutarch
❯ cat &gt; Example.lbf
module Example

import Prelude
import Plutus.V1 (PlutusData, AssetClass)

record Example a = {
  foo : AssetClass,
  bar : a
  }

derive Eq (Example a)
derive Json (Example a)
derive PlutusData (Example a)

❯ lbf-plutus-to-plutarch Example.lbf
[lbf][INFO] Compilation OK
[lbf][INFO] Codegen OK

❯ find autogen/
autogen/
autogen/build.json
autogen/LambdaBuffers
autogen/LambdaBuffers/Example
autogen/LambdaBuffers/Example/Plutarch.hs
</code></pre>
<p>For a full example see <a href="plutarch.html#example">Example</a>.</p>
<h2 id="lambdabuffers-modules"><a class="header" href="#lambdabuffers-modules">LambdaBuffers modules</a></h2>
<p>Writing .lbf schemas with API types intended for Plutarch backend will typically use the following LambdaBuffers schema modules:</p>
<ol>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude/Prelude.lbf">Prelude</a>,</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V1.lbf">Plutus.V1</a>,</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V2.lbf">Plutus.V2</a>.</li>
</ol>
<p>Take a look at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/api/Example.lbf">Example.lbf</a> schema as an example.</p>
<h2 id="haskell-libraries"><a class="header" href="#haskell-libraries">Haskell libraries</a></h2>
<p>The necessary LambdaBuffers runtime libraries a typical Plutarch project needs when working with LambdaBuffers:</p>
<ol>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/runtimes/haskell/lbr-plutarch">lbr-plutarch</a> a Haskell runtime library necessary for working with <code>lbf-xyz</code> libraries.</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude">lbf-prelude-plutarch</a> that contains the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude">LambdaBuffers Prelude</a> schema library generated by LambdaBuffers.</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">lbf-plutus-plutarch</a> that contains the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">LambdaBuffers Plutus</a> schema library generated by LambdaBuffers.</li>
</ol>
<p>Of course, additional imports for Plutarch libraries are also necessary <a href="https://github.com/Plutonomicon/plutarch-plutus">plutarch</a> and optionally <a href="https://github.com/Plutonomicon/plutarch-plutus/tree/master/plutarch-extra">plutarch-extra</a>.</p>
<p>For a full example see <a href="plutarch.html#example">Example</a>.</p>
<h3 id="inspecting-the-generated-output"><a class="header" href="#inspecting-the-generated-output">Inspecting the generated output</a></h3>
<p>You can inspect the generated libraries using Nix:</p>
<pre><code class="language-shell">❯ nix build .#lbf-prelude-plutarch
❯ find result/autogen/
result/autogen/
result/autogen/LambdaBuffers
result/autogen/LambdaBuffers/Prelude
result/autogen/LambdaBuffers/Prelude/Plutarch.hs

❯ nix build .#lbf-plutus-plutarch
❯ find result/autogen/
result/autogen/
result/autogen/LambdaBuffers
result/autogen/LambdaBuffers/Plutus
result/autogen/LambdaBuffers/Plutus/V2
result/autogen/LambdaBuffers/Plutus/V2/Plutarch.hs
result/autogen/LambdaBuffers/Plutus/V1
result/autogen/LambdaBuffers/Plutus/V1/Plutarch.hs
</code></pre>
<h2 id="haskell-modules"><a class="header" href="#haskell-modules">Haskell modules</a></h2>
<p>The set of imports a Plutarch program using LambdaBuffers would typically need is the following:</p>
<pre><code class="language-haskell">import LambdaBuffers.Plutus.V1.Plutarch ()
import LambdaBuffers.Plutus.V2.Plutarch ()
import LambdaBuffers.Prelude.Plutarch ()
import LambdaBuffers.Runtime.Plutarch ()
import Plutarch ()
import Plutarch.Prelude ()
import Plutarch.Api.V1 ()
import Plutarch.Api.V2 ()
</code></pre>
<ol>
<li>LambdaBuffers.Plutus.V1.Plutarch is a module generated from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V1.lbf">Plutus.V1</a> LambdaBuffers schema and provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">lbf-plutus-plutarch</a> runtime library.</li>
<li>LambdaBuffers.Plutus.V2.Plutarch is a module generated from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus/Plutus/V2.lbf">Plutus.V2</a> LambdaBuffers schema and provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">lbf-plutus-plutarch</a> runtime library.</li>
<li>LambdaBuffers.Prelude.Plutarch is a module generated from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude/Prelude.lbf">Prelude</a> LambdaBuffers schema and provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude">lbf-prelude-plutarch</a> runtime library.</li>
<li>LambdaBuffers.Runtime.Plutarch is a module provided by the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/runtimes/haskell/lbr-plutarch">lbr-plutarch</a> runtime library.</li>
</ol>
<blockquote>
<p>Generated Plutarch module for a LambdaBuffers schema <code>Foo/Bar.lbf</code> (ie. <code>Foo.Bar</code>) is stored at <code>Foo/Bar/Plutarch.hs</code></p>
</blockquote>
<h2 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h2>
<p>Plutarch backend doesn't support recursive type definitions unfortunately (see #131).</p>
<p>The following will not work:</p>
<pre><code class="language-lbf">module ModuleWithRecursiveType

import Prelude (Eq)
import Plutus.V1 (PlutusData)

sum List a = Cons a (List a) | Nil
derive Eq (List a)
derive PlutusData (List a)
</code></pre>
<p>Additionally, LambdaBuffers record types are mapped to Plutarch product types:</p>
<pre><code class="language-lbf">module ModuleWithARecordType

import Prelude (Eq, Integer, Bool)
import Plutus.V1 (PlutusData)

record Foo = {
  bar: Integer,
  baz: Bool
  }
derive Eq Foo
derive PlutusData Foo
</code></pre>
<p>Essentially, the record definitions are 'degraded' into product types such that the order of product fields is the order of record fields as they are defined at source.</p>
<p>For example the <code>Foo</code> record defined above would have no difference in Plutarch if it was defined as product <code>Foo</code> below:</p>
<pre><code class="language-lbf">prod Foo = Integer Bool
</code></pre>
<p>The Plutarch backend doesn't support the use of <code>Char</code>, <code>Text</code>, <code>Bytes</code> (there's a Plutus.V1.Bytes), <code>Set</code> and <code>Map</code> (there's a Plutus.V1.Map) from <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude/Prelude.lbf">LambdaBuffers Prelude</a> module.</p>
<h2 id="plutarch"><a class="header" href="#plutarch">Plutarch</a></h2>
<h3 id="type-definition-mapping"><a class="header" href="#type-definition-mapping">Type definition mapping</a></h3>
<p>Plutarch backend supports all types from the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-plutus">LambdaBuffers Plutus</a> schema library, as to enable full featured Plutus script development.</p>
<p>Additionally, it also supports some types from the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/libs/lbf-prelude">LambdaBuffers Prelude</a> schema library, namely <code>Bool</code>, <code>Integer</code>, <code>Maybe</code>, <code>Either</code> and <code>List</code>.</p>
<pre><code class="language-lbf">module Foo

sum Sum = Some a | Nothing

record Record a = {
  foo : Bytes,
  bar: a
}

prod Product a = Bytes a
</code></pre>
<p>translates into Plutarch equivalent:</p>
<pre><code class="language-haskell">module LambdaBuffers.Foo.Plutarch (Sum(..), Record(..), Product(..)) where

import qualified LambdaBuffers.Plutus.V1.Plutarch
import qualified LambdaBuffers.Prelude.Plutarch
import qualified LambdaBuffers.Runtime.Plutarch
import qualified Plutarch
import qualified Plutarch.Bool
import qualified Plutarch.Builtin
import qualified Plutarch.Internal.PlutusType
import qualified Plutarch.Prelude
import qualified Plutarch.Show
import qualified Plutarch.TryFrom
import qualified Plutarch.Unsafe

data Sum (a :: PType) (s :: Plutarch.S) = Sum'Some (Plutarch.Term s (Plutarch.Builtin.PAsData LambdaBuffers.Plutus.V1.Plutarch.Bytes)) (Plutarch.Term s (Plutarch.Builtin.PAsData PAsData))
                                  | Sum'Nothing
  deriving stock GHC.Generics.Generic
  deriving anyclass Plutarch.Show.PShow

data Record (a :: PType) (s :: Plutarch.S) = Record (Plutarch.Term s (Plutarch.Builtin.PAsData LambdaBuffers.Plutus.V1.Plutarch.Bytes)) (Plutarch.Term s (Plutarch.Builtin.PAsData PAsData))
  deriving stock GHC.Generics.Generic
  deriving anyclass Plutarch.Show.PShow

data Product (a :: PType) (s :: Plutarch.S) = Product (Plutarch.Term s (Plutarch.Builtin.PAsData LambdaBuffers.Plutus.V1.Plutarch.Bytes)) (Plutarch.Term s (Plutarch.Builtin.PAsData PAsData))
  deriving stock GHC.Generics.Generic
  deriving anyclass Plutarch.Show.PShow
</code></pre>
<h3 id="type-class-implementations"><a class="header" href="#type-class-implementations">Type class implementations</a></h3>
<p>Plutarch has a couple of fundamental type classes essential to its operations namely, <code>PlutusType</code>, <code>PIsData</code>, <code>PTryFrom</code> and <code>PEq</code>.</p>
<h4 id="plutustype"><a class="header" href="#plutustype">PlutusType</a></h4>
<p>Printing an implementation for this class for a particular type is governed by <code>derive Plutus.V1.PlutusData &lt;type&gt;</code> statements in .lbf schemas.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/Internal/PlutusType.hs#L56">PlutusType</a> serves to (de)construct Plutarch eDSL terms from Haskell 'native' terms.</p>
<pre><code class="language-haskell">class PlutusType (a :: PType) where
  type PInner a :: PType
  pcon' :: forall s. a s -&gt; Term s (PInner a)
  pmatch' :: forall s b. Term s (PInner a) -&gt; (a s -&gt; Term s b) -&gt; Term s b
</code></pre>
<p>Additionally, Plutarch enables specifying terms to have different 'value' representation, like Scott encoded terms or PlutusData encoded terms.
This is what the <code>PInner</code> type family is used to specify.
LambdaBuffers only cares about <code>PlutusData</code> encoded terms since we're using it to specify Plutus datum structures.</p>
<p>The task is to generate a <code>pcon'</code> implementation such that we can construct Plutarch <code>Term</code>s that have some <code>PInner</code> representation of type <code>PData</code>, from Haskell 'native' values.
The <code>pcon'</code> implementation must match the LB Plutus PlutusData encoding class standard, and so we'll use the same 'to Plutus data' specification to generate <code>pcon'</code> implementations.</p>
<p>Constructing is always only one part of the story, there's also deconstruction that is captured by the <code>pmatch'</code> method.
This method serves to 'pattern match' on a value that was already constructed using <code>pcon'</code> and dispatch said value to a provided continuation function.
It's important to note that there's a subtle but important distinction to be made between the <code>ptryFrom</code> and <code>pmatch'</code> methods.
<code>pmatch'</code> assumes that the value it receives is indeed correct, as it was constructed using the <code>pcon'</code> method.
This means that <code>pmatch'</code> should never error, and if it does that means the implementation is wrong.
<code>ptryFrom</code> is different, as it takes some <code>PData</code> and tries to parse it into a <code>PType</code>, but can fail.</p>
<p>However, in LambdaBuffers, both of these methods follow the exact same logical pattern, and they correspond and can be generated using the <code>from Plutus data</code> specification.</p>
<h4 id="ptryfrom"><a class="header" href="#ptryfrom">PTryFrom</a></h4>
<p>Printing an implementation for this class for a particular type is governed by <code>derive Plutus.V1.PlutusData &lt;type&gt;</code> statements in .lbf schemas.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/TryFrom.hs#L73">PTryFrom</a> serves specify how <code>PData</code> is 'parsed' into a Plutarch type.
N
It's generally used to convert between Plutarch types, but that's a fairly general use case, and we generally use this class in a very narrow form to specify how <code>PData</code> is 'parsed' into a Plutarch type.</p>
<pre><code class="language-haskell">class PSubtype a b =&gt; PTryFrom (a :: PType) (b :: PType) where
  type PTryFromExcess a b :: PType
  type PTryFromExcess a b = PTryFromExcess a (PInner b)
  ptryFrom' :: forall s r. Term s a -&gt; ((Term s b, Reduce (PTryFromExcess a b s)) -&gt; Term s r) -&gt; Term s r
  default ptryFrom' :: forall s r. (PTryFrom a (PInner b), PTryFromExcess a b ~ PTryFromExcess a (PInner b)) =&gt; Term s a -&gt; ((Term s b, Reduce (PTryFromExcess a b s)) -&gt; Term s r) -&gt; Term s r
  ptryFrom' opq f = ptryFrom @(PInner b) @a opq \(inn, exc) -&gt; f (punsafeCoerce inn, exc)
</code></pre>
<p>There's some additionally features exhibited by this type class, most noteworthy is the <code>PTryFromExcess</code> type family that enables us specify the part of the structure that wasn't parsed and is left unexamined.
It's a form of optimization that becomes very important if you have a very complex data type such as <code>ScriptContext</code> from the <code>plutus-ledger-api</code>.</p>
<p>Apparently, a good intuition pump for this 'excess' business is that of a <a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">zipper</a>.
We focus on a certain part of a data structure, only ever providing links to other parts that are left un-examined.</p>
<p>LambdaBuffers doesn't use this feature and sets the <code>PTryFromExcess</code> to a unit type, signaling that nothing is left unexamined.</p>
<h4 id="pisdata"><a class="header" href="#pisdata">PIsData</a></h4>
<p>Printing an implementation for this class for a particular type is governed by <code>derive Plutus.V1.PlutusData &lt;type&gt;</code> statements in .lbf schemas.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/Builtin.hs#L354">PIsData</a> serves to track 'is it Plutus data encoded?' with types.</p>
<pre><code class="language-haskell">newtype PAsData (a :: PType) (s :: S) = PAsData (Term s a)

class PIsData a where
  pfromDataImpl :: Term s (PAsData a) -&gt; Term s a
  default pfromDataImpl :: PIsData (PInner a) =&gt; Term s (PAsData a) -&gt; Term s a
  pfromDataImpl x = punsafeDowncast $ pfromDataImpl (punsafeCoerce x :: Term _ (PAsData (PInner a)))

  pdataImpl :: Term s a -&gt; Term s PData
  default pdataImpl :: PIsData (PInner a) =&gt; Term s a -&gt; Term s PData
  pdataImpl x = pdataImpl $ pto x
</code></pre>
<pre><code class="language-haskell">instance PIsData FooTrivial where
  pdataImpl = punsafeCoerce
  pfromDataImpl = punsafeCoerce

instance PEq FooTrivial where
  (#==) = \l r -&gt; pdata l #== pdata r
</code></pre>
<blockquote>
<p>Due to generated types having a <code>PAsData</code> attached to them, be ready to use <code>pdata</code> and <code>pfromData</code> to switch between forms.</p>
</blockquote>
<h4 id="peq"><a class="header" href="#peq">PEq</a></h4>
<p>Printing an implementation for this class for a particular type is governed by <code>derive Prelude.Eq &lt;type&gt;</code> statements in .lbf schemas.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/Bool.hs#L74">PEq</a> serves to track provide equality checks to Plutarch types.</p>
<pre><code class="language-haskell">class PEq t where
  (#==) :: Term s t -&gt; Term s t -&gt; Term s PBool
  default (#==) ::
    (PGeneric t, PlutusType t, All2 PEq (PCode t)) =&gt;
    Term s t -&gt;
    Term s t -&gt;
    Term s PBool
  a #== b = gpeq # a # b

infix 4 #==
</code></pre>
<blockquote>
<p>We don't generate an implementation from the LambdaBuffers 'equality spec', rather we delegate the equality check to the underlying 'PData' representations that all generated types have for performance.</p>
</blockquote>
<h4 id="pshow"><a class="header" href="#pshow">PShow</a></h4>
<p>All generated types have a PShow instance derived using the internal Plutarch deriving mechanism.</p>
<p><a href="https://github.com/Plutonomicon/plutarch-plutus/blob/c14ad83479706566fe22e7b7b50b696043326c8f/Plutarch/Show.hs#L52">PShow</a> serves to stringify Plutarch types which is very useful during debugging.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let work through the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch">Plutarch example</a> available in the repo.</p>
<p>First, please check the <a href="getting-started.html">Getting started</a> guide on how to prepare to work with the repo and setup Nix.</p>
<p>Let's see what we have here:</p>
<pre><code class="language-shell">lambda-buffers/docs/plutarch ❯ find
.
./build.nix
./cabal.project
./hie.yaml
./plutarch-example.cabal
./app
./app/Example.hs
./api
./api/Example.lbf
./.envrc
</code></pre>
<p>The salient bits we should focus on are:</p>
<ol>
<li>The LambdaBuffers .lbf schema in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/api/Example.lbf">./api/Example.lbf</a> that describes the API types used by our little program,</li>
<li>The Haskell Plutarch program in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/app/Example.hs">./app/Example.hs</a> that works with the API types.</li>
</ol>
<p>To inspect the generated library:</p>
<pre><code class="language-shell">lambda-buffers/docs/plutarch ❯ nix build .#lbf-plutarch-example-api
lambda-buffers/docs/plutarch ❯ find autogen/
autogen/
autogen/build.json
autogen/LambdaBuffers
autogen/LambdaBuffers/Example
autogen/LambdaBuffers/Example/Plutarch.hs
</code></pre>
<blockquote>
<p>The name of the generated library <code>lbf-plutarch-example-api</code> is set in the ./plutarch/build.nix Nix build file.</p>
</blockquote>
<p>However, it's not expected for users to need to do this. If you have any issue please reach out.</p>
<p>Inspecting the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/plutarch-example.cabal">Cabal file</a> shows the standard runtime libraries we need:</p>
<pre><code class="language-shell">lambda-buffers/docs/plutarch ❯ cabal info .
* plutarch-example-0.1.0.0 (program)
    Synopsis:      LambdaBuffers Plutarch example
    Versions available: [ Not available from server ]
    Versions installed: [ Unknown ]
    Homepage:      [ Not specified ]
    Bug reports:   [ Not specified ]
    License:       NONE
    Author:        Drazen Popovic
    Maintainer:    bladyjoker@gmail.com
    Source repo:   [ Not specified ]
    Executables:   plutarch-example
    Flags:         dev
    Dependencies:  base &gt;=4.16, lbf-plutarch-example-api, lbf-plutus-plutarch,
                   lbf-prelude-plutarch, lbr-plutarch, plutarch, plutarch-extra,
                   text &gt;=1.2
    Cached:        Yes
</code></pre>
<p>Run the program:</p>
<pre><code class="language-shell">lambda-buffers/docs/plutarch ❯ cabal run
"Friends, peace and love!!!"
</code></pre>
<p>Take a look at the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/plutarch/app/Example.hs">Example.hs</a> to see how generated types are used, namely how they are constructed with <code>pcon</code> and deconstructed with <code>pmatch</code> (or <code>pmatchC</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-to-rust"><a class="header" href="#lambdabuffers-to-rust">LambdaBuffers to Rust</a></h1>
<p>Let's take a look at how LambdaBuffers modules map into Rust modules and how
LambdaBuffers type definitions map into Rust type definitions.</p>
<p>We'll use the <code>lbf-prelude-to-rust</code> CLI tool which is just a convenient wrapper over
the raw <code>lbf</code> CLI. We can get this tool by either loading the LambdaBuffers Nix
environment that comes packaged with all the CLI tools:</p>
<pre><code class="language-shell">$ nix develop github:mlabs-haskell/lambda-buffers#lb
$ lbf&lt;tab&gt;
lbf                        lbf-plutus-to-purescript   lbf-prelude-to-haskell     lbf-prelude-to-rust
lbf-plutus-to-haskell      lbf-plutus-to-rust         lbf-prelude-to-purescript  
</code></pre>
<p>Or we can simply just refer directly to the <code>lbf-prelude-to-rust</code> CLI by <code>nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-rust</code>.</p>
<p>In this chapter, we're going to use the latter option.</p>
<p>Let's now use <code>lbf-prelude-to-rust</code> to process the <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/main/docs/examples/Document.lbf">Document.lbf</a> schema.</p>
<pre><code class="language-purescript">module Document

-- Importing types
import Prelude (Text, List, Set, Bytes)

-- Author
sum Author = Ivan | Jovan | Savo

-- Reviewer
sum Reviewer = Bob | Alice

-- Document
record Document a = {
  author : Author,
  reviewers : Set Reviewer,
  content : Chapter a
 }

-- Chapter
record Chapter a = {
  content : a,
  subChapters : List (Chapter a)
 }

-- Some actual content
sum RichContent = Image Bytes | Gif Bytes | Text Text

-- Rich document
prod RichDocument = (Document RichContent)
</code></pre>
<pre><code class="language-shell">$ nix run github:mlabs-haskell/lambda-buffers#lbf-prelude-to-rust -- Document.lbf
$ find autogen/
autogen/
autogen/LambdaBuffers
autogen/LambdaBuffers/Document.hs
autogen/build.json
</code></pre>
<p>As we can see the <code>autogen</code> directory has been created that contains the generated Rust modules.
Note the <code>autogen/build.json</code> file as it contains all the necessary Cargo dependencies the generated module needs in order to be properly compiled by Rust.</p>
<p>The outputted Rust module in <code>autogen/document.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_implicit_prelude]
#![allow(warnings)]
<span class="boring">fn main() {
</span>extern crate lbf_prelude;
extern crate std;


#[derive(std::fmt::Debug, std::clone::Clone)]
pub enum Author{Ivan, Jovan, Savo}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub struct Chapter&lt;A&gt;{pub content: A,
                     pub sub_chapters: std::boxed::Box&lt;lbf_prelude::prelude::List&lt;Chapter&lt;A&gt;&gt;&gt;}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub struct Document&lt;A&gt;{pub author: Author,
                      pub reviewers: lbf_prelude::prelude::Set&lt;Reviewer&gt;,
                      pub content: Chapter&lt;A&gt;}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub enum Reviewer{Bob, Alice}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub enum RichContent{Image(lbf_prelude::prelude::Bytes),
                    Gif(lbf_prelude::prelude::Bytes),
                    Text(lbf_prelude::prelude::Text)}

#[derive(std::fmt::Debug, std::clone::Clone)]
pub struct RichDocument(pub Document&lt;RichContent&gt;);

<span class="boring">}</span></code></pre></pre>
<h2 id="sum-types-2"><a class="header" href="#sum-types-2">Sum types</a></h2>
<p>The types <code>Author</code>, <code>Reviewer</code>, and <code>RichContent</code> have been declared as sum types in the LambdaBuffers schema using the <code>sum</code> keyword.</p>
<p>As we can see, nothing too surprising here, all the <code>sum</code> types become <code>enum</code>
in Rust.</p>
<h2 id="product-types-2"><a class="header" href="#product-types-2">Product types</a></h2>
<p>The type <code>RichDocument</code> have been declared as a product type in the
LambdaBuffers schema using the <code>prod</code> keyword.</p>
<p>They become Rust tuple <code>struct</code> (or named tuple)</p>
<h2 id="record-types-2"><a class="header" href="#record-types-2">Record types</a></h2>
<p>The types <code>Document</code> and <code>Chapter</code> have been declared as record types in the
LambdaBuffers schema using the <code>record</code> keyword.</p>
<p>Like with product types, they become Rust <code>struct</code> with named fields.</p>
<p>All types and their fields are public, allowing to manipulate them without accessors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="installing-nix"><a class="header" href="#installing-nix">Installing Nix</a></h2>
<p>This repository relies heavily on the <a href="https://nixos.org/download.html">Nix Package
Manager</a> for both development and package
distribution.</p>
<p>To install run the following command:</p>
<pre><code class="language-sh">sh &lt;(curl -L https://nixos.org/nix/install) --daemon
</code></pre>
<p>and follow the instructions.</p>
<pre><code class="language-sh">$ nix --version
nix (Nix) 2.8.0
</code></pre>
<blockquote>
<p>NOTE: The repository should work with Nix version greater or equal to 2.8.0.</p>
</blockquote>
<p>Make sure to enable <a href="https://nixos.wiki/wiki/Flakes#Enable_flakes">Nix Flakes</a>
and IFD by editing either <code>~/.config/nix/nix.conf</code> or <code>/etc/nix/nix.conf</code> on
your machine and add the following configuration entries:</p>
<pre><code class="language-yaml">experimental-features = nix-command flakes
allow-import-from-derivation = true
</code></pre>
<p>Optionally, to improve build speed, it is possible to set up a binary caches
maintained by IOHK and Plutonomicon by setting additional configuration entries:</p>
<pre><code class="language-yaml">substituters = https://cache.nixos.org https://iohk.cachix.org https://cache.iog.io https://public-plutonomicon.cachix.org
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= iohk.cachix.org-1:DpRUyj7h7V830dp/i6Nti+NEO2/nhblbov/8MW7Rqoo= public-plutonomicon.cachix.org-1:3AKJMhCLn32gri1drGuaZmFrmnue+KkKrhhubQk/CWc=
</code></pre>
<h2 id="building-and-development"><a class="header" href="#building-and-development">Building and development</a></h2>
<p>To facilitate seamlessly moving between directories and associated Nix
development shells we use <a href="https://direnv.net">direnv</a> and
<a href="https://github.com/nix-community/nix-direnv">nix-direnv</a>:</p>
<p>To install both using <code>nixpkgs</code>:</p>
<pre><code class="language-sh">nix profile install nixpkgs#direnv
nix profile install nixpkgs#nix-direnv
</code></pre>
<p>Your shell and editors should pick up on the <code>.envrc</code> files in different
directories and prepare the environment accordingly.  Use <code>direnv allow</code> to
enable the direnv environment and <code>direnv reload</code> to reload it when necessary.</p>
<p>Additionally, throughout the repository one can use:</p>
<pre><code class="language-sh">$ pre-commit run --all
cabal-fmt............................................(no files to check)Skipped
fourmolu.................................................................Passed
hlint....................................................................Passed
markdownlint.............................................................Passed
nix-linter...............................................................Passed
nixpkgs-fmt..............................................................Passed
shellcheck...........................................(no files to check)Skipped
typos....................................................................Passed
</code></pre>
<p>To run all the code quality tooling specified in the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/pre-commit.nix">pre-commit-check config file</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-design"><a class="header" href="#lambdabuffers-design">LambdaBuffers Design</a></h1>
<p>The goal of the LambdaBuffers project is to enable software developers to
specify their application types in a common format that can be conveniently
shared and their values effectively communicated across language barriers.</p>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>Software projects that span multiple language environments often interact in a
sub-optimal manner. Significant effort is spent in making application messages
declared in one language environment available to other language environments.</p>
<p>This burden is particularly onerous in manually written and managed
serialization/encoding code which is used to communicate application values
in the context of networking, configuration and databases.</p>
<p>Ensuring compatibility, consistency and correctness of application messages is a
difficult, tedious and error prone process that often results in unwarranted
costs to the business and unsustainable technical debt.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ol>
<li>Expressive types,</li>
<li>Expressive semantics annotation,</li>
<li>Extensible to new types,</li>
<li>Extensible to new semantics,</li>
<li>Universally consistent semantics,</li>
<li>Modular API architecture.</li>
</ol>
<h3 id="expressive-types"><a class="header" href="#expressive-types">Expressive Types</a></h3>
<p>Application types that users can define should be expressive enough to
facilitate type driven domain modeling and to express application
programming interfaces.</p>
<p>Taking inspiration from existing type systems, LambdaBuffers supports <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic
data types</a> that facilitate
elegant type composition. Such types are well studied and widely used in
functional programming languages such as Haskell.</p>
<p>LambdaBuffers supports first class sum, product and record types. Types can be
parameterized, effectively enabling generic types. LambdaBuffers also supports
recursive type definitions, which allow users to succinctly define elegant and
expressive data structures.</p>
<h3 id="expressive-semantics-annotation"><a class="header" href="#expressive-semantics-annotation">Expressive Semantics Annotation</a></h3>
<p>Enabling users to manage the <em>semantics</em> associated with their types is
essential for adapting LambdaBuffers to a variety of different domains and use
cases.</p>
<p>While most existing schema systems only facilitate type declarations in a
variety of languages, LambdaBuffers takes a further step and provides users with
the capability to manage the <em>semantics</em> of the types defined in schemata by
indicating which basic operations and functions a type ought to support.</p>
<p>For example, suppose a user would like some types to support certain encoding
(e.g. JSON or CBOR). In order to support a particular encoding, functions that
serialize and deserialize the types are needed in the target language(s).
Another example: Users may wish to declare that certain types are numeric - i.e.
that values of these types can be added, subtracted or multiplied in a given
target language. Most types could be declared to support an equality relation,
which requires a function that can check values for equality in the target
language(s).</p>
<p>In order to provide users the capability to manage the <em>semantics</em> of the types
they define, LambdaBuffers supports <a href="https://en.wikipedia.org/wiki/Type_class">type
classes</a>, also known as <em>type
constraints</em>. Type classes are a well-established mechanism for supporting ad
hoc polymorphism, backed by a large amount of academic research and widely used
in functional programming languages such as Haskell, PureScript, and (albeit
under a different name) Rust.</p>
<p>One essential difference between LambdaBuffers type classes and type classes as
implemented in Haskell/PureScript/Rust is that LambdaBuffers does not allow
users to declare the implementation of type class instances. Instead, users
declare <em>instance clauses</em> for their types which signify the <em>semantics</em> (i.e.
functions, methods) they wish to be generated in the target language. All
implementation are generated uniformly as elaborated in the specification
document for a given type class.</p>
<p>For each new type class declared, code generation tooling must be updated to
handle the new type class.</p>
<h3 id="extensible-to-new-types"><a class="header" href="#extensible-to-new-types">Extensible to New Types</a></h3>
<p>Enabling users to introduce new <em>built-in</em> types allows LambdaBuffers to be
adapted in many different domains and use cases.</p>
<p>These types have special treatment <em>under the hood</em> and are generally mapped onto
existing types and their value representations in the targeted language
environments. For example, a primitive <code>Int</code> type in the LambdaBuffers schema
language may be mapped to <code>Int</code> in Haskell and <code>i32</code> in Rust. Primitive
parameterized types are also possible: A primitive <code>Maybe</code> type might be mapped
to <code>Maybe</code> in Haskell and to <code>Option&lt;_&gt;</code> in Rust.</p>
<p>LambdaBuffers supports <a href="https://en.wikipedia.org/wiki/Opaque_data_type">opaque
types</a> to provide users with the
power to define their own primitive or builtin types.</p>
<p>Example opaque types include various integer types, sequence types, text types,
sets, maps and other semantically richer data types. Generally, such types are
already well-defined and widely used in various language environments and come
equipped with rich libraries that work with them. Redefining them <em>ab ovo</em> would
be counterproductive as users would have to re-implement and reinvent the rich
support for such types.</p>
<h3 id="extensible-to-new-semantics"><a class="header" href="#extensible-to-new-semantics">Extensible to New Semantics</a></h3>
<p>Enabling users to introduce new <em>type semantics</em> facilitates LambdaBuffers to be
adapted in many different domains and use cases.</p>
<p>In LambdaBuffers, introducing new <em>type semantics</em> works by first declaring a
<em>type class</em>, which is simply the name of the class bundled with any
super-classes (should they exist). Next, specification document that elaborates
how instances are to be generated for members of the class must be created,
taking care to ensure that instances are always generated uniformly. Finally, a
code generation module for the class must be written that implements compliant
code generation for different target languages.</p>
<p>Concretely, serialization has special treatment in most technologies in this
space, however in LambdaBuffers, this is just a new type class.</p>
<p>For each new type class, deliberate effort must be invested to support
that 'semantics' in different target language environments in a compliant manner.
(Because type class instances are generated uniformly relative to the
structure of the original type, in accordance with a set of deriving rules
provided in the code generation implementation, the amount of boilerplate
required to implement a new class is substantially reduced if not
entirely eliminated.)</p>
<p>The LambdaBuffers team will officially support a certain set of type classes and
provide code generation modules for a set of officially supported language
environments. However, modular design will hopefully facilitate community
contributions in a sustainable fashion.</p>
<h3 id="universally-consistent-semantics"><a class="header" href="#universally-consistent-semantics">Universally Consistent Semantics</a></h3>
<p>The types specified by users must be handled in a compatible manner across
language environments. This is a critical requirement that underpins this
project.</p>
<p>If two values of a LambdaBuffers type are considered as 'equal' in one language
environment, they should be considered equal in all others. In a similar
fashion, if LambdaBuffers type has a declared JSON serialization semantics,
values encoded as JSON in one language environment have to have the same
encoding performed in all other language environments.</p>
<p>LambdaBuffers does not provide a way to formally verify consistency across languages,
however, a comprehensive test suite will be developed to ensure that new code
generation modules are indeed implemented correctly.</p>
<h3 id="modular-api-architecture"><a class="header" href="#modular-api-architecture">Modular API Architecture</a></h3>
<p>LambdaBuffers establishes three separate components of the architecture, namely
<em>Frontend</em>, <em>Compiler</em> and <em>Codegen</em>*.</p>
<p><em>Frontend</em> is a user facing component that features a way to input, specify or
otherwise construct application types. <em>Frontend</em> also orchestrates the overall
work that includes the <em>Compiler</em> and <em>Codegen</em>, invoking each of these
components as required by different workflows the <em>Frontend</em> supports.
LambdaBuffers officially supports a <em>Frontend</em> component implementation that
features a text based language for specifying LambdaBuffers types. However,
because of the modular API architecture approach, a <em>Frontend</em> can be
implemented in any language and in any fashion as long as they are able to
interface with the <em>Compiler</em> and <em>Codegen</em> components.</p>
<p>The <em>Compiler</em> is a key component that is made available via the <em>Compiler
Input</em> specified via <a href="https://protobuf.dev/">Google Protocol Buffers</a>. It
performs all the necessary checks to ensure that the naming, type definitions
and their declared semantics are indeed valid.</p>
<p>The <em>Codegen</em> component consumes the <em>Compiler Output</em> that contains all the
information necessary to perform valid and robust code generation. <em>Frontend</em>
communicates with the <em>Codegen</em> to understand its <em>Capabilities</em>, enabling each
<em>Codegen</em> module to gradually build up support for desired opaque types and
declared semantics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocol-documentation"><a class="header" href="#protocol-documentation">Protocol Documentation</a></h1>
<p><a name="top"></a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li>
<p><a href="api.html#lang-proto">lang.proto</a></p>
<ul>
<li>
<p><a href="api.html#lambdabuffers-ClassConstraint">ClassConstraint</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ClassDef">ClassDef</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ClassName">ClassName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ConstrName">ConstrName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Constraint">Constraint</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Derive">Derive</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-FieldName">FieldName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-InstanceClause">InstanceClause</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Kind">Kind</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Kind-KindArrow">Kind.KindArrow</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Module">Module</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-ModuleNamePart">ModuleNamePart</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Opaque">Opaque</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Product">Product</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Record">Record</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Record-Field">Record.Field</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-SourcePosition">SourcePosition</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Sum">Sum</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Sum-Constructor">Sum.Constructor</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Ty">Ty</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyAbs">TyAbs</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyApp">TyApp</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyArg">TyArg</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyBody">TyBody</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyClassRef">TyClassRef</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyClassRef-Foreign">TyClassRef.Foreign</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyClassRef-Local">TyClassRef.Local</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyDef">TyDef</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyName">TyName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyRef">TyRef</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyRef-Foreign">TyRef.Foreign</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyRef-Local">TyRef.Local</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-TyVar">TyVar</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Tys">Tys</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-VarName">VarName</a></p>
</li>
<li>
<p><a href="api.html#lambdabuffers-Kind-KindRef">Kind.KindRef</a></p>
</li>
</ul>
</li>
<li>
<p><a href="api.html#compiler-proto">compiler.proto</a></p>
<ul>
<li><a href="api.html#lambdabuffers-compiler-Error">Error</a></li>
<li><a href="api.html#lambdabuffers-compiler-Input">Input</a></li>
<li><a href="api.html#lambdabuffers-compiler-InternalError">InternalError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError">KindCheckError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-CyclicKindError">KindCheckError.CyclicKindError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-InconsistentTypeError">KindCheckError.InconsistentTypeError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-UnboundTyRefError">KindCheckError.UnboundTyRefError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-UnboundTyVarError">KindCheckError.UnboundTyVarError</a></li>
<li><a href="api.html#lambdabuffers-compiler-KindCheckError-UnificationError">KindCheckError.UnificationError</a></li>
<li><a href="api.html#lambdabuffers-compiler-NamingError">NamingError</a></li>
<li><a href="api.html#lambdabuffers-compiler-Output">Output</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError">ProtoParseError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleClassDefError">ProtoParseError.MultipleClassDefError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleConstructorError">ProtoParseError.MultipleConstructorError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleFieldError">ProtoParseError.MultipleFieldError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleImportError">ProtoParseError.MultipleImportError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleModuleError">ProtoParseError.MultipleModuleError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleTyArgError">ProtoParseError.MultipleTyArgError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleTyDefError">ProtoParseError.MultipleTyDefError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-OneOfNotSetError">ProtoParseError.OneOfNotSetError</a></li>
<li><a href="api.html#lambdabuffers-compiler-ProtoParseError-UnknownEnumError">ProtoParseError.UnknownEnumError</a></li>
<li><a href="api.html#lambdabuffers-compiler-Result">Result</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError">TyClassCheckError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError">TyClassCheckError.DeriveOpaqueError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError">TyClassCheckError.ImportNotFoundError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-MissingRuleError">TyClassCheckError.MissingRuleError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError">TyClassCheckError.OverlappingRulesError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead">TyClassCheckError.OverlappingRulesError.QHead</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError">TyClassCheckError.SuperclassCycleError</a></li>
<li><a href="api.html#lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError">TyClassCheckError.UnboundClassRefError</a></li>
</ul>
</li>
<li>
<p><a href="api.html#codegen-proto">codegen.proto</a></p>
<ul>
<li><a href="api.html#lambdabuffers-codegen-Error">Error</a></li>
<li><a href="api.html#lambdabuffers-codegen-Input">Input</a></li>
<li><a href="api.html#lambdabuffers-codegen-InternalError">InternalError</a></li>
<li><a href="api.html#lambdabuffers-codegen-Output">Output</a></li>
<li><a href="api.html#lambdabuffers-codegen-Result">Result</a></li>
<li><a href="api.html#lambdabuffers-codegen-UnsupportedClassError">UnsupportedClassError</a></li>
<li><a href="api.html#lambdabuffers-codegen-UnsupportedOpaqueError">UnsupportedOpaqueError</a></li>
</ul>
</li>
<li>
<p><a href="api.html#scalar-value-types">Scalar Value Types</a></p>
</li>
</ul>
<p><a name="lang-proto"></a></p>
<p align="right"><a href="api.html#top">Top</a></p>
<h2 id="langproto"><a class="header" href="#langproto">lang.proto</a></h2>
<p><a name="lambdabuffers-ClassConstraint"></a></p>
<h3 id="classconstraint"><a class="header" href="#classconstraint">ClassConstraint</a></h3>
<p>Class constraints</p>
<p>A special constraint type denoting the constraints that occur on the rhs of
class definitions. Only used to specify super class constraints in a
<code>ClassDef</code>.</p>
<p>Not to be confused with <code>Constraint</code> which denote type class rules.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef">TyClassRef</a></td><td></td><td>Type class reference.</td></tr>
<tr><td>args</td><td><a href="api.html#lambdabuffers-TyVar">TyVar</a></td><td>repeated</td><td>Type variables quantified over <code>ClassDef</code> arguments.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ClassDef"></a></p>
<h3 id="classdef"><a class="header" href="#classdef">ClassDef</a></h3>
<p>Type class definition</p>
<p>LambdaBuffers use type classes to talk about the various 'meanings' or
'semantics' we want to associate with the types in LambdaBuffers schemata.</p>
<p>For instance, most types can have <code>Eq</code> semantics, meaning they can be
compared for equality. Other can have <code>Ord</code> semantics, meaning they can be
ordered.</p>
<p>Using type classes and instance declarations, much like in Haskell, users can
specify the 'meaning' of each type they declare. For example, serialization
in LambdaBuffers is just another type class, it's treated the same as any
other type class. Concretely, if we wish to provide JSON serialization for
LambdaBuffers types, we declare such a type class and provide desired
semantic rules:</p>
<pre><code class="language-lbf">module Foo

class JSON a

sum Foo a b = Bar a | Baz b

derive JSON (Foo a b)
</code></pre>
<p>Note that for each type class introduced, the Codegen machinery must be
updated to support said type class. In other words, it doesn't come for free
and for each new type class, a Codegen support must be implemented for any
<code>InstanceClause</code> declared by the user. Once all the <code>InstanceClause</code>s have an
implementation provided, all the <code>Derive</code>d implementation come for free.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Type class name.</td></tr>
<tr><td>class_args</td><td><a href="api.html#lambdabuffers-TyArg">TyArg</a></td><td>repeated</td><td>Type class arguments. Class with no arguments is a trivial class. Compiler MAY report an error. TODO(bladyjoker): MultipleClassArgError.</td></tr>
<tr><td>supers</td><td><a href="api.html#lambdabuffers-ClassConstraint">ClassConstraint</a></td><td>repeated</td><td>Superclass constraints.</td></tr>
<tr><td>documentation</td><td><a href="api.html#string">string</a></td><td></td><td>Documentation elaborating on the type class.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ClassName"></a></p>
<h3 id="classname"><a class="header" href="#classname">ClassName</a></h3>
<p>Type class name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ConstrName"></a></p>
<h3 id="constrname"><a class="header" href="#constrname">ConstrName</a></h3>
<p>Sum type constructor name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Constraint"></a></p>
<h3 id="constraint"><a class="header" href="#constraint">Constraint</a></h3>
<p>Constraint term</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef">TyClassRef</a></td><td></td><td>Name of the type class.</td></tr>
<tr><td>args</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Constraint arguments. Constraint with no arguments is a trivial constraint. Compiler MAY report an error.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Derive"></a></p>
<h3 id="derive"><a class="header" href="#derive">Derive</a></h3>
<p>Derive statement</p>
<p>Derive statements enable user to specify 'semantic' rules for their types much
like <code>InstanceClause</code>s do. However, the Codegen will be able to derive an
implementation for any such constraint.</p>
<pre><code class="language-lbf">module Prelude

class Eq a

sum Maybe a = Just a | Nothing

derive Eq (Maybe a)
</code></pre>
<p>The rule installed for the derive statement is:</p>
<pre><code class="language-prolog">eq(maybe(A)) :- eq(just(A) | Nothing).
</code></pre>
<p>The rule relates the desired <code>Ty</code> term to its (lambda calculus)
'evaluated' form.</p>
<p>&gt; Currently, there's only support for deriving type class rules and
implementations for <code>Ty</code> terms of <code>Kind.KIND_REF_TYPE</code>. That means,
type classes like Ord and Eq...</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constraint</td><td><a href="api.html#lambdabuffers-Constraint">Constraint</a></td><td></td><td>Constraint to derive.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-FieldName"></a></p>
<h3 id="fieldname"><a class="header" href="#fieldname">FieldName</a></h3>
<p>Record type field name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [a-z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-InstanceClause"></a></p>
<h3 id="instanceclause"><a class="header" href="#instanceclause">InstanceClause</a></h3>
<p>Instance clause</p>
<p>Instance clauses enable users to specify ad-hoc 'semantic' rules for their
types. Each such instance must be supported explicitly in the Codegen by
providing runtime implementations.</p>
<p>This rule form is used when declaring 'opaque' implementations on <code>Opaque</code>
types.</p>
<pre><code class="language-lbf">module Prelude

class Eq a

opaque Maybe a

instance Eq a =&amp;gt; Eq (Maybe a)
</code></pre>
<p>The rule installed for the clause is:</p>
<pre><code class="language-prolog">eq(maybe(A)) :- eq(A).
</code></pre>
<p>The instance clause is verbatim added to the rule set.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>head</td><td><a href="api.html#lambdabuffers-Constraint">Constraint</a></td><td></td><td>Head of the clause that holds only when the <code>body</code> holds. Type variables introduced in the head of the rule become available in the scope of the body of the rule.</td></tr>
<tr><td>constraints</td><td><a href="api.html#lambdabuffers-Constraint">Constraint</a></td><td>repeated</td><td>Instance (rule) body, conjunction of constraints.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind"></a></p>
<h3 id="kind"><a class="header" href="#kind">Kind</a></h3>
<p>Kinds</p>
<p>A type of a type is called a 'kind'.
In Lambda Buffers, all type terms, namely TyArg, TyVar, TyRef, TyApp and TyAbs,
are either of kind <code>Type</code> or <code>Type -&amp;gt; Type</code> and <code>Type -&amp;gt; Type -&amp;gt; Type</code>
etc.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>kind_ref</td><td><a href="api.html#lambdabuffers-Kind-KindRef">Kind.KindRef</a></td><td></td><td></td></tr>
<tr><td>kind_arrow</td><td><a href="api.html#lambdabuffers-Kind-KindArrow">Kind.KindArrow</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind-KindArrow"></a></p>
<h3 id="kindkindarrow"><a class="header" href="#kindkindarrow">Kind.KindArrow</a></h3>
<p>A kind arrow.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>left</td><td><a href="api.html#lambdabuffers-Kind">Kind</a></td><td></td><td></td></tr>
<tr><td>right</td><td><a href="api.html#lambdabuffers-Kind">Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Module"></a></p>
<h3 id="module"><a class="header" href="#module">Module</a></h3>
<p>Module</p>
<p>A module encapsulates type, class and instance definitions.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Module name.</td></tr>
<tr><td>type_defs</td><td><a href="api.html#lambdabuffers-TyDef">TyDef</a></td><td>repeated</td><td>Type definitions. Duplicate type definitions MUST be reported with <code>ProtoParseError.MultipleTyDefError</code>.</td></tr>
<tr><td>class_defs</td><td><a href="api.html#lambdabuffers-ClassDef">ClassDef</a></td><td>repeated</td><td>Type class definitions. Duplicate class definitions MUST be reported with <code>ProtoParseError.MultipleClassDefError</code>.</td></tr>
<tr><td>instances</td><td><a href="api.html#lambdabuffers-InstanceClause">InstanceClause</a></td><td>repeated</td><td>Type class instance clauses.</td></tr>
<tr><td>derives</td><td><a href="api.html#lambdabuffers-Derive">Derive</a></td><td>repeated</td><td>Type class derive statements.</td></tr>
<tr><td>imports</td><td><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></td><td>repeated</td><td>Imported modules the Compiler consults when searching for type class rules. TODO(bladyjoker): Rename to ruleImports. Duplicate imports MUST be reported with <code>ProtoParseError.MultipleImportError</code>.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ModuleName"></a></p>
<h3 id="modulename"><a class="header" href="#modulename">ModuleName</a></h3>
<p>Module name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>parts</td><td><a href="api.html#lambdabuffers-ModuleNamePart">ModuleNamePart</a></td><td>repeated</td><td>Parts of the module name denoting a hierarchical namespace.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-ModuleNamePart"></a></p>
<h3 id="modulenamepart"><a class="header" href="#modulenamepart">ModuleNamePart</a></h3>
<p>Module name part</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Opaque"></a></p>
<h3 id="opaque"><a class="header" href="#opaque">Opaque</a></h3>
<p>Opaque type.</p>
<p>A type that has an <code>Opaque</code> body represents a 'built-in' or a 'primitive' type
that's handled by the semantics 'under the hood'. It's called 'opaque' to denote
the fact that the Compiler has no knowledge of its structure, and relies that
the necessary knowledge is implemented elsewhere. The Codegen modules for any
target language have to be able to handle such types specifically and map to
existing value level representations and corresponding types.</p>
<p>Codegen modules would have to implement support for such defined types, for
example:</p>
<ul>
<li>In Python <code>Set a</code> would map to <code>set()</code> from the standard library,</li>
<li>In Haskell <code>Set a</code> would map to <code>containers</code>.Data.Set.Set type.</li>
</ul>
<p>Every <code>Opaque</code> type has to be considered deliberately for each language
environment targeted by Codegen modules.</p>
<p>TODO(bladyjoker): Consider attaching explicit Kind terms to Opaques.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Product"></a></p>
<h3 id="product"><a class="header" href="#product">Product</a></h3>
<p>A product type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>fields</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Fields in a products are types.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Record"></a></p>
<h3 id="record"><a class="header" href="#record">Record</a></h3>
<p>A record type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>fields</td><td><a href="api.html#lambdabuffers-Record-Field">Record.Field</a></td><td>repeated</td><td>Record fields.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Record-Field"></a></p>
<h3 id="recordfield"><a class="header" href="#recordfield">Record.Field</a></h3>
<p>Field in a record type.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>field_name</td><td><a href="api.html#lambdabuffers-FieldName">FieldName</a></td><td></td><td>Record field name.</td></tr>
<tr><td>field_ty</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td></td><td>Field type.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-SourceInfo"></a></p>
<h3 id="sourceinfo"><a class="header" href="#sourceinfo">SourceInfo</a></h3>
<p>Frontend Source information</p>
<p>Frontends are advised to include <em>Source</em> information to denote how their
Source* content maps to the <em>Compiler Input</em>. It's essential when reporting
Compiler* errors back to the Frontend.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>file</td><td><a href="api.html#string">string</a></td><td></td><td>A filename denoting the Source file.</td></tr>
<tr><td>pos_from</td><td><a href="api.html#lambdabuffers-SourcePosition">SourcePosition</a></td><td></td><td>Starting position in Source.</td></tr>
<tr><td>pos_to</td><td><a href="api.html#lambdabuffers-SourcePosition">SourcePosition</a></td><td></td><td>End position in Source.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-SourcePosition"></a></p>
<h3 id="sourceposition"><a class="header" href="#sourceposition">SourcePosition</a></h3>
<p>Position in Source</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>column</td><td><a href="api.html#int32">int32</a></td><td></td><td>Column index in the Source.</td></tr>
<tr><td>row</td><td><a href="api.html#int32">int32</a></td><td></td><td>Row index in the Source.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Sum"></a></p>
<h3 id="sum"><a class="header" href="#sum">Sum</a></h3>
<p>A sum type term.</p>
<p>A type defined as a Sum type is just like a Haskell algebraic data type and
represents a sum of products.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constructors</td><td><a href="api.html#lambdabuffers-Sum-Constructor">Sum.Constructor</a></td><td>repeated</td><td>Sum type constructors. Empty <code>constructors</code> means <code>void</code> and means that the type can't be constructed. Compiler MAY report an error. Duplicate constructors MUST be reported with <code>ProtoParseError.MultipleConstructorError</code>.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Sum-Constructor"></a></p>
<h3 id="sumconstructor"><a class="header" href="#sumconstructor">Sum.Constructor</a></h3>
<p>Constructor of a Sum type is a Product type term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>constr_name</td><td><a href="api.html#lambdabuffers-ConstrName">ConstrName</a></td><td></td><td>Constructor name.</td></tr>
<tr><td>product</td><td><a href="api.html#lambdabuffers-Product">Product</a></td><td></td><td>Product type term.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Ty"></a></p>
<h3 id="ty"><a class="header" href="#ty">Ty</a></h3>
<p>Type term</p>
<p>A type term that occurs in bodies of type definitions (message TyDef):</p>
<pre><code class="language-lbf">sum Maybe a = Just a | Nothing

sum Either a b = Left a | Right b

sum SomeType a = Foo a (Maybe a) | Bar (Either (Maybe a) (SomeType a))
</code></pre>
<p>or in instance declarations:</p>
<pre><code class="language-lbf">instance Eq (Maybe a)

instance Eq (SomeType Int)

instance (Eq (Maybe a), Eq (SomeType a)) Eq (Either (Maybe a) (SomeType a))
</code></pre>
<p>Check out <a href="examples/tys.textproto">examples</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_var</td><td><a href="api.html#lambdabuffers-TyVar">TyVar</a></td><td></td><td>A type variable.</td></tr>
<tr><td>ty_app</td><td><a href="api.html#lambdabuffers-TyApp">TyApp</a></td><td></td><td>A type application.</td></tr>
<tr><td>ty_ref</td><td><a href="api.html#lambdabuffers-TyRef">TyRef</a></td><td></td><td>A type reference.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyAbs"></a></p>
<h3 id="tyabs"><a class="header" href="#tyabs">TyAbs</a></h3>
<p>Type abstraction</p>
<p>A type term that introduces type abstractions (ie. type functions). This
type term can only be introduced in the context of a
[type definition](@ref TyDef).</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_args</td><td><a href="api.html#lambdabuffers-TyArg">TyArg</a></td><td>repeated</td><td>List of type variables. No type arguments means <code>delay</code> or <code>const ty_body</code>, meaning <code>TyAbs [] ty_body = ty_body</code>. Duplicate type arguments MUST be reported with <code>ProtoParseError.MultipleTyArgError</code>.</td></tr>
<tr><td>ty_body</td><td><a href="api.html#lambdabuffers-TyBody">TyBody</a></td><td></td><td>Type body.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyApp"></a></p>
<h3 id="tyapp"><a class="header" href="#tyapp">TyApp</a></h3>
<p>Type application</p>
<p>A type term that applies a type abstraction to a list of arguments.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_func</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td></td><td>Type function. TODO(bladyjoker): Rename to ty_abs?</td></tr>
<tr><td>ty_args</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td>Arguments to apply. No arguments to apply means <code>force</code>, meaning `TyApp ty_func [] = ty_func``</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyArg"></a></p>
<h3 id="tyarg"><a class="header" href="#tyarg">TyArg</a></h3>
<p>Type arguments</p>
<p>Arguments in type abstractions.</p>
<p>Type arguments and therefore type variables have kinds, the Compiler only
accepts <code>Type</code> kinded type arguments ans therefore type variables.</p>
<p>However, to allow for future evolution if ever necessary, we attach the Kind
term to type arguments, even though the Compiler will reject any TyArg that's
not of kind <code>Type</code>.</p>
<p>Note, this effectively means that lambda Buffers doesn't support higher-kinded
types (ie. HKT).</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>arg_name</td><td><a href="api.html#lambdabuffers-VarName">VarName</a></td><td></td><td>Argument name corresponds to variable names.</td></tr>
<tr><td>arg_kind</td><td><a href="api.html#lambdabuffers-Kind">Kind</a></td><td></td><td>Argument kind.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyBody"></a></p>
<h3 id="tybody"><a class="header" href="#tybody">TyBody</a></h3>
<p>Type body.</p>
<p>Lambda Buffers type bodies type terms that can only be specified in the
<code>TyAbs</code> context. It's a built-in type term that can only occur enclosed
within a <code>TyAbs</code> term which introduces <code>TyVar</code>s in the scope of the term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>opaque</td><td><a href="api.html#lambdabuffers-Opaque">Opaque</a></td><td></td><td></td></tr>
<tr><td>sum</td><td><a href="api.html#lambdabuffers-Sum">Sum</a></td><td></td><td></td></tr>
<tr><td>product</td><td><a href="api.html#lambdabuffers-Product">Product</a></td><td></td><td></td></tr>
<tr><td>record</td><td><a href="api.html#lambdabuffers-Record">Record</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef"></a></p>
<h3 id="tyclassref"><a class="header" href="#tyclassref">TyClassRef</a></h3>
<p>Type class references</p>
<p>It is necessary to know whether a type class is defined locally or in a
foreign module when referring to it in a constraint, this allows users (and
requires the frontend) to explicitly communicate that information.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>local_class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef-Local">TyClassRef.Local</a></td><td></td><td></td></tr>
<tr><td>foreign_class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef-Foreign">TyClassRef.Foreign</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef-Foreign"></a></p>
<h3 id="tyclassrefforeign"><a class="header" href="#tyclassrefforeign">TyClassRef.Foreign</a></h3>
<p>Foreign class reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Foreign module class name.</td></tr>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Foreign module name.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyClassRef-Local"></a></p>
<h3 id="tyclassreflocal"><a class="header" href="#tyclassreflocal">TyClassRef.Local</a></h3>
<p>Local type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">ClassName</a></td><td></td><td>Local module class name.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyDef"></a></p>
<h3 id="tydef"><a class="header" href="#tydef">TyDef</a></h3>
<p>Type definition</p>
<p>A type definition consists of a type name and its associated type term.</p>
<p>One way to look at it is that a type definition introduces a named 'type
abstraction' in the module scope. Concretely, <code>Either</code> can be considered a type
lambda of kind <code>Type -&amp;gt; Type -&amp;gt; Type</code>.</p>
<p>In fact, type definitions are the only way to introduce such types.</p>
<p>Once introduced in the module scope, type definitions are referred to using
[TyRef](@ref TyRef) term.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="api.html#lambdabuffers-TyName">TyName</a></td><td></td><td>Type name.</td></tr>
<tr><td>ty_abs</td><td><a href="api.html#lambdabuffers-TyAbs">TyAbs</a></td><td></td><td>Type term.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyName"></a></p>
<h3 id="tyname"><a class="header" href="#tyname">TyName</a></h3>
<p>Type name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [A-Z]+[A-Za-z0-9_]*</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef"></a></p>
<h3 id="tyref"><a class="header" href="#tyref">TyRef</a></h3>
<p>Type reference</p>
<p>A type term that denotes a reference to a type available that's declared
locally or in foreign modules.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>local_ty_ref</td><td><a href="api.html#lambdabuffers-TyRef-Local">TyRef.Local</a></td><td></td><td></td></tr>
<tr><td>foreign_ty_ref</td><td><a href="api.html#lambdabuffers-TyRef-Foreign">TyRef.Foreign</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef-Foreign"></a></p>
<h3 id="tyrefforeign"><a class="header" href="#tyrefforeign">TyRef.Foreign</a></h3>
<p>Foreign type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="api.html#lambdabuffers-TyName">TyName</a></td><td></td><td>Foreign module type name.</td></tr>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">ModuleName</a></td><td></td><td>Foreign module name.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyRef-Local"></a></p>
<h3 id="tyreflocal"><a class="header" href="#tyreflocal">TyRef.Local</a></h3>
<p>Local type reference.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_name</td><td><a href="api.html#lambdabuffers-TyName">TyName</a></td><td></td><td>Local module type name.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-TyVar"></a></p>
<h3 id="tyvar"><a class="header" href="#tyvar">TyVar</a></h3>
<p>Type variable</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>var_name</td><td><a href="api.html#lambdabuffers-VarName">VarName</a></td><td></td><td>Variable name.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Tys"></a></p>
<h3 id="tys"><a class="header" href="#tys">Tys</a></h3>
<p>A list of type terms useful for debugging</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ties</td><td><a href="api.html#lambdabuffers-Ty">Ty</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-VarName"></a></p>
<h3 id="varname"><a class="header" href="#varname">VarName</a></h3>
<p>Type variable name</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="api.html#string">string</a></td><td></td><td>Name ::= [a-z]+</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">SourceInfo</a></td><td></td><td>Source information.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-Kind-KindRef"></a></p>
<h3 id="kindkindref"><a class="header" href="#kindkindref">Kind.KindRef</a></h3>
<p>A built-in kind.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>KIND_REF_UNSPECIFIED</td><td>0</td><td>Unspecified kind SHOULD be inferred by the Compiler.</td></tr>
<tr><td>KIND_REF_TYPE</td><td>1</td><td>A <code>Type</code> kind (also know as <code>*</code> in Haskell) built-in.</td></tr>
</tbody></table>
</div>
<p><a name="compiler-proto"></a></p>
<p align="right"><a href="api.html#top">Top</a></p>
<h2 id="compilerproto"><a class="header" href="#compilerproto">compiler.proto</a></h2>
<p><a name="lambdabuffers-compiler-Error"></a></p>
<h3 id="error"><a class="header" href="#error">Error</a></h3>
<p>Compiler Error</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>proto_parse_errors</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError">ProtoParseError</a></td><td>repeated</td><td>Errors occurred during proto parsing.</td></tr>
<tr><td>naming_errors</td><td><a href="api.html#lambdabuffers-compiler-NamingError">NamingError</a></td><td>repeated</td><td>Errors occurred during naming checking.</td></tr>
<tr><td>kind_check_errors</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError">KindCheckError</a></td><td>repeated</td><td>Errors occurred during kind checking.</td></tr>
<tr><td>ty_class_check_errors</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError">TyClassCheckError</a></td><td>repeated</td><td>Errors occurred during type class checking.</td></tr>
<tr><td>internal_errors</td><td><a href="api.html#lambdabuffers-compiler-InternalError">InternalError</a></td><td>repeated</td><td>Errors internal to the compiler implementation.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Input"></a></p>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<p>Compiler Input</p>
<p>Compiler Input is a fully self contained list of modules, the entire
compilation closure needed by the Compiler to perform its task.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="api.html#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Modules to compile. Duplicate modules MUST be reported with <code>ProtoParseError.MultipleModuleError</code>.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-InternalError"></a></p>
<h3 id="internalerror"><a class="header" href="#internalerror">InternalError</a></h3>
<p>Errors internal to the implementation.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msg</td><td><a href="api.html#string">string</a></td><td></td><td>Error message.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">lambdabuffers.SourceInfo</a></td><td></td><td>Source information if meaningful.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError"></a></p>
<h3 id="kindcheckerror"><a class="header" href="#kindcheckerror">KindCheckError</a></h3>
<p>Kind checking errors.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>unbound_ty_ref_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-UnboundTyRefError">KindCheckError.UnboundTyRefError</a></td><td></td><td></td></tr>
<tr><td>unbound_ty_var_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-UnboundTyVarError">KindCheckError.UnboundTyVarError</a></td><td></td><td></td></tr>
<tr><td>unification_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-UnificationError">KindCheckError.UnificationError</a></td><td></td><td></td></tr>
<tr><td>cyclic_kind_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-CyclicKindError">KindCheckError.CyclicKindError</a></td><td></td><td></td></tr>
<tr><td>inconsistent_type_error</td><td><a href="api.html#lambdabuffers-compiler-KindCheckError-InconsistentTypeError">KindCheckError.InconsistentTypeError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-CyclicKindError"></a></p>
<h3 id="kindcheckerrorcyclickinderror"><a class="header" href="#kindcheckerrorcyclickinderror">KindCheckError.CyclicKindError</a></h3>
<p>A cyclic kind was encountered. Infinite kinds like this are not acceptable,
and we do not support them. We could not construct infinite kind in ty_def.</p>
<p>As the implementation currently stands such an error is (most likely) not
representable - therefore not reachable. Such an error would usually occur
for a term like: λa. a a - in which case the inference would try to unify
two kinds of the form: m and m -&gt; n - because m appears in both terms -
the cyclic unification error would be thrown.</p>
<p>In the case of LambdaBuffers - such an error is not (currently) achievable
as the kind of the variable is given by the context - (i.e. λa : m . a a,
where m is a kind) therefore the unification would fail with Unification
Error. Nevertheless - future features might require it.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-InconsistentTypeError"></a></p>
<h3 id="kindcheckerrorinconsistenttypeerror"><a class="header" href="#kindcheckerrorinconsistenttypeerror">KindCheckError.InconsistentTypeError</a></h3>
<p>The actual_kind differs from the expected_kind.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>actual_kind</td><td><a href="api.html#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
<tr><td>expected_kind</td><td><a href="api.html#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnboundTyRefError"></a></p>
<h3 id="kindcheckerrorunboundtyreferror"><a class="header" href="#kindcheckerrorunboundtyreferror">KindCheckError.UnboundTyRefError</a></h3>
<p>Unbound type reference ty_ref detected in term ty_def.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_ref</td><td><a href="api.html#lambdabuffers-TyRef">lambdabuffers.TyRef</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnboundTyVarError"></a></p>
<h3 id="kindcheckerrorunboundtyvarerror"><a class="header" href="#kindcheckerrorunboundtyvarerror">KindCheckError.UnboundTyVarError</a></h3>
<p>Unbound variable ty_var detected in term ty_def.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_var</td><td><a href="api.html#lambdabuffers-TyVar">lambdabuffers.TyVar</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-KindCheckError-UnificationError"></a></p>
<h3 id="kindcheckerrorunificationerror"><a class="header" href="#kindcheckerrorunificationerror">KindCheckError.UnificationError</a></h3>
<p>In ty_def an error has occurred when trying to unify kind ty_kind_lhs
with ty_kind_rhs.</p>
<p>FIXME(cstml): Add source of constraint to the error such that user can see
where the constraint was generated - therefore where the error precisely
is.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td></td></tr>
<tr><td>ty_kind_lhs</td><td><a href="api.html#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
<tr><td>ty_kind_rhs</td><td><a href="api.html#lambdabuffers-Kind">lambdabuffers.Kind</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-NamingError"></a></p>
<h3 id="namingerror"><a class="header" href="#namingerror">NamingError</a></h3>
<p>Naming error message</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name_err</td><td><a href="api.html#lambdabuffers-ModuleNamePart">lambdabuffers.ModuleNamePart</a></td><td></td><td></td></tr>
<tr><td>ty_name_err</td><td><a href="api.html#lambdabuffers-TyName">lambdabuffers.TyName</a></td><td></td><td></td></tr>
<tr><td>var_name_err</td><td><a href="api.html#lambdabuffers-VarName">lambdabuffers.VarName</a></td><td></td><td></td></tr>
<tr><td>constr_name_err</td><td><a href="api.html#lambdabuffers-ConstrName">lambdabuffers.ConstrName</a></td><td></td><td></td></tr>
<tr><td>field_name_err</td><td><a href="api.html#lambdabuffers-FieldName">lambdabuffers.FieldName</a></td><td></td><td></td></tr>
<tr><td>class_name_err</td><td><a href="api.html#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Output"></a></p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>Output of the Compiler.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>error</td><td><a href="api.html#lambdabuffers-compiler-Error">Error</a></td><td></td><td></td></tr>
<tr><td>result</td><td><a href="api.html#lambdabuffers-compiler-Result">Result</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError"></a></p>
<h3 id="protoparseerror"><a class="header" href="#protoparseerror">ProtoParseError</a></h3>
<p>All errors that occur because of Google Protocol Buffer's inability to
enforce certain invariants.
Some of invariance:</p>
<ul>
<li>using Proto <code>map</code> restricts users to <code>string</code> keys which impacts
API documentation, which is why <code>repeated</code> fields are used throughout,</li>
<li>using Proto 'oneof' means users have to check if such a field is
set or report an error otherwise.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>multiple_module_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleModuleError">ProtoParseError.MultipleModuleError</a></td><td></td><td></td></tr>
<tr><td>multiple_tydef_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleTyDefError">ProtoParseError.MultipleTyDefError</a></td><td></td><td></td></tr>
<tr><td>multiple_classdef_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleClassDefError">ProtoParseError.MultipleClassDefError</a></td><td></td><td></td></tr>
<tr><td>multiple_tyarg_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleTyArgError">ProtoParseError.MultipleTyArgError</a></td><td></td><td></td></tr>
<tr><td>multiple_constructor_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleConstructorError">ProtoParseError.MultipleConstructorError</a></td><td></td><td></td></tr>
<tr><td>multiple_field_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleFieldError">ProtoParseError.MultipleFieldError</a></td><td></td><td></td></tr>
<tr><td>multiple_import_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-MultipleImportError">ProtoParseError.MultipleImportError</a></td><td></td><td></td></tr>
<tr><td>one_of_not_set_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-OneOfNotSetError">ProtoParseError.OneOfNotSetError</a></td><td></td><td></td></tr>
<tr><td>unknown_enum_error</td><td><a href="api.html#lambdabuffers-compiler-ProtoParseError-UnknownEnumError">ProtoParseError.UnknownEnumError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleClassDefError"></a></p>
<h3 id="protoparseerrormultipleclassdeferror"><a class="header" href="#protoparseerrormultipleclassdeferror">ProtoParseError.MultipleClassDefError</a></h3>
<p>Multiple ClassDefs with the same ClassName were found in ModuleName.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>class_defs</td><td><a href="api.html#lambdabuffers-ClassDef">lambdabuffers.ClassDef</a></td><td>repeated</td><td>Conflicting class definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleConstructorError"></a></p>
<h3 id="protoparseerrormultipleconstructorerror"><a class="header" href="#protoparseerrormultipleconstructorerror">ProtoParseError.MultipleConstructorError</a></h3>
<p>Multiple Sum Constructors with the same ConstrName were found in
ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>constructors</td><td><a href="api.html#lambdabuffers-Sum-Constructor">lambdabuffers.Sum.Constructor</a></td><td>repeated</td><td>Conflicting constructors.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleFieldError"></a></p>
<h3 id="protoparseerrormultiplefielderror"><a class="header" href="#protoparseerrormultiplefielderror">ProtoParseError.MultipleFieldError</a></h3>
<p>Multiple Record Fields with the same FieldName were found in
ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>fields</td><td><a href="api.html#lambdabuffers-Record-Field">lambdabuffers.Record.Field</a></td><td>repeated</td><td>Conflicting record fields.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleImportError"></a></p>
<h3 id="protoparseerrormultipleimporterror"><a class="header" href="#protoparseerrormultipleimporterror">ProtoParseError.MultipleImportError</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>imports</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td>repeated</td><td>Conflicting module imports.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleModuleError"></a></p>
<h3 id="protoparseerrormultiplemoduleerror"><a class="header" href="#protoparseerrormultiplemoduleerror">ProtoParseError.MultipleModuleError</a></h3>
<p>Multiple Modules with the same ModuleName were found.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="api.html#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Conflicting type definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleTyArgError"></a></p>
<h3 id="protoparseerrormultipletyargerror"><a class="header" href="#protoparseerrormultipletyargerror">ProtoParseError.MultipleTyArgError</a></h3>
<p>Multiple TyArgs with the same ArgName were found in ModuleName.TyDef.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_def</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td></td><td>Type definition in which the error was found.</td></tr>
<tr><td>ty_args</td><td><a href="api.html#lambdabuffers-TyArg">lambdabuffers.TyArg</a></td><td>repeated</td><td>Conflicting type abstraction arguments.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-MultipleTyDefError"></a></p>
<h3 id="protoparseerrormultipletydeferror"><a class="header" href="#protoparseerrormultipletydeferror">ProtoParseError.MultipleTyDefError</a></h3>
<p>Multiple TyDefs with the same TyName were found in ModuleName.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td>Module in which the error was found.</td></tr>
<tr><td>ty_defs</td><td><a href="api.html#lambdabuffers-TyDef">lambdabuffers.TyDef</a></td><td>repeated</td><td>Conflicting type definitions.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-OneOfNotSetError"></a></p>
<h3 id="protoparseerroroneofnotseterror"><a class="header" href="#protoparseerroroneofnotseterror">ProtoParseError.OneOfNotSetError</a></h3>
<p>Proto <code>oneof</code> field is not set.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>message_name</td><td><a href="api.html#string">string</a></td><td></td><td>Proto message name in which the <code>oneof</code> field is not set.</td></tr>
<tr><td>field_name</td><td><a href="api.html#string">string</a></td><td></td><td>The <code>oneof</code> field that is not set.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-ProtoParseError-UnknownEnumError"></a></p>
<h3 id="protoparseerrorunknownenumerror"><a class="header" href="#protoparseerrorunknownenumerror">ProtoParseError.UnknownEnumError</a></h3>
<p>Proto <code>enum</code> field is unknown.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>enum_name</td><td><a href="api.html#string">string</a></td><td></td><td>Proto <code>enum</code> name.</td></tr>
<tr><td>got_tag</td><td><a href="api.html#string">string</a></td><td></td><td>The unknown tag for the <code>enum</code>.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-Result"></a></p>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<p>Compiler Result ~ a successful Compilation Output.</p>
<p><a name="lambdabuffers-compiler-TyClassCheckError"></a></p>
<h3 id="tyclasscheckerror"><a class="header" href="#tyclasscheckerror">TyClassCheckError</a></h3>
<p>Type class checking errors.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>unbound_class_ref_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError">TyClassCheckError.UnboundClassRefError</a></td><td></td><td></td></tr>
<tr><td>superclass_cycle_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError">TyClassCheckError.SuperclassCycleError</a></td><td></td><td></td></tr>
<tr><td>import_not_found_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError">TyClassCheckError.ImportNotFoundError</a></td><td></td><td></td></tr>
<tr><td>derive_opaque_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError">TyClassCheckError.DeriveOpaqueError</a></td><td></td><td></td></tr>
<tr><td>missing_rule_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-MissingRuleError">TyClassCheckError.MissingRuleError</a></td><td></td><td></td></tr>
<tr><td>overlapping_rules_err</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError">TyClassCheckError.OverlappingRulesError</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-DeriveOpaqueError"></a></p>
<h3 id="tyclasscheckerrorderiveopaqueerror"><a class="header" href="#tyclasscheckerrorderiveopaqueerror">TyClassCheckError.DeriveOpaqueError</a></h3>
<p>In <code>module_name</code> it wasn't possible to solve <code>constraint</code> because a
<code>sub_constraint</code> has been derived on an <code>Opaque</code> type. <code>Opaque</code> type can
only have an <code>InstanceClause</code> declared for them.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-ImportNotFoundError"></a></p>
<h3 id="tyclasscheckerrorimportnotfounderror"><a class="header" href="#tyclasscheckerrorimportnotfounderror">TyClassCheckError.ImportNotFoundError</a></h3>
<p>Import <code>missing</code> wasn't found in <code>module_name</code></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>missing</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-MissingRuleError"></a></p>
<h3 id="tyclasscheckerrormissingruleerror"><a class="header" href="#tyclasscheckerrormissingruleerror">TyClassCheckError.MissingRuleError</a></h3>
<p>In <code>module_name</code> while trying to solve <code>constraint</code> it wasn't possible to
find a rule (<code>Derive</code> or <code>InstanceClause</code>) for <code>sub_constraint</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError"></a></p>
<h3 id="tyclasscheckerroroverlappingruleserror"><a class="header" href="#tyclasscheckerroroverlappingruleserror">TyClassCheckError.OverlappingRulesError</a></h3>
<p>In <code>module_name</code> while trying to solve <code>constraint</code> <code>overlaps</code> (<code>Derive</code>
or <code>InstanceClause</code>) were found that could be used to solve the
<code>sub_constraint</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>sub_constraint</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
<tr><td>overlaps</td><td><a href="api.html#lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead">TyClassCheckError.OverlappingRulesError.QHead</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-OverlappingRulesError-QHead"></a></p>
<h3 id="tyclasscheckerroroverlappingruleserrorqhead"><a class="header" href="#tyclasscheckerroroverlappingruleserrorqhead">TyClassCheckError.OverlappingRulesError.QHead</a></h3>
<p>NOTE(bladyjoker): This should rather be oneof <code>Derive</code> and
<code>InstanceClause</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>head</td><td><a href="api.html#lambdabuffers-Constraint">lambdabuffers.Constraint</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-SuperclassCycleError"></a></p>
<h3 id="tyclasscheckerrorsuperclasscycleerror"><a class="header" href="#tyclasscheckerrorsuperclasscycleerror">TyClassCheckError.SuperclassCycleError</a></h3>
<p>Superclass cycle <code>cycled_class_refs</code> was detected when checking a
class definition for <code>class_name</code> in module <code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
<tr><td>cycled_class_refs</td><td><a href="api.html#lambdabuffers-TyClassRef">lambdabuffers.TyClassRef</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-compiler-TyClassCheckError-UnboundClassRefError"></a></p>
<h3 id="tyclasscheckerrorunboundclassreferror"><a class="header" href="#tyclasscheckerrorunboundclassreferror">TyClassCheckError.UnboundClassRefError</a></h3>
<p>Unbound <code>class_ref</code> detected in <code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_ref</td><td><a href="api.html#lambdabuffers-TyClassRef">lambdabuffers.TyClassRef</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="codegen-proto"></a></p>
<p align="right"><a href="api.html#top">Top</a></p>
<h2 id="codegenproto"><a class="header" href="#codegenproto">codegen.proto</a></h2>
<p><a name="lambdabuffers-codegen-Error"></a></p>
<h3 id="error-1"><a class="header" href="#error-1">Error</a></h3>
<p>Codegen Error</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>internal_errors</td><td><a href="api.html#lambdabuffers-codegen-InternalError">InternalError</a></td><td>repeated</td><td></td></tr>
<tr><td>unsupported_opaque_errors</td><td><a href="api.html#lambdabuffers-codegen-UnsupportedOpaqueError">UnsupportedOpaqueError</a></td><td>repeated</td><td></td></tr>
<tr><td>unsupported_class_errors</td><td><a href="api.html#lambdabuffers-codegen-UnsupportedClassError">UnsupportedClassError</a></td><td>repeated</td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Input"></a></p>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<p>Codegen Input</p>
<p>Codegen Input is a fully self contained list of modules,
that have been checked by the Compiler.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>modules</td><td><a href="api.html#lambdabuffers-Module">lambdabuffers.Module</a></td><td>repeated</td><td>Modules to codegen.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-InternalError"></a></p>
<h3 id="internalerror-1"><a class="header" href="#internalerror-1">InternalError</a></h3>
<p>Errors internal to the implementation.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msg</td><td><a href="api.html#string">string</a></td><td></td><td>Error message.</td></tr>
<tr><td>source_info</td><td><a href="api.html#lambdabuffers-SourceInfo">lambdabuffers.SourceInfo</a></td><td></td><td>Source information if meaningful.</td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Output"></a></p>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<p>Codegen output.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>error</td><td><a href="api.html#lambdabuffers-codegen-Error">Error</a></td><td></td><td></td></tr>
<tr><td>result</td><td><a href="api.html#lambdabuffers-codegen-Result">Result</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-Result"></a></p>
<h3 id="result-1"><a class="header" href="#result-1">Result</a></h3>
<p>Codegen Result ~ a successful Codegen Output.</p>
<p><a name="lambdabuffers-codegen-UnsupportedClassError"></a></p>
<h3 id="unsupportedclasserror"><a class="header" href="#unsupportedclasserror">UnsupportedClassError</a></h3>
<p>Unsupported <code>Class</code> error for a class <code>class_name</code> defined in module
<code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>class_name</td><td><a href="api.html#lambdabuffers-ClassName">lambdabuffers.ClassName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><a name="lambdabuffers-codegen-UnsupportedOpaqueError"></a></p>
<h3 id="unsupportedopaqueerror"><a class="header" href="#unsupportedopaqueerror">UnsupportedOpaqueError</a></h3>
<p>Unsupported <code>Opaque</code> error for a type <code>ty_name</code> defined in module
<code>module_name</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>module_name</td><td><a href="api.html#lambdabuffers-ModuleName">lambdabuffers.ModuleName</a></td><td></td><td></td></tr>
<tr><td>ty_name</td><td><a href="api.html#lambdabuffers-TyName">lambdabuffers.TyName</a></td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="scalar-value-types"><a class="header" href="#scalar-value-types">Scalar Value Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>.proto Type</th><th>Notes</th><th>C++</th><th>Java</th><th>Python</th><th>Go</th><th>C#</th><th>PHP</th><th>Ruby</th></tr></thead><tbody>
<tr><td><a name="double" /> double</td><td></td><td>double</td><td>double</td><td>float</td><td>float64</td><td>double</td><td>float</td><td>Float</td></tr>
<tr><td><a name="float" /> float</td><td></td><td>float</td><td>float</td><td>float</td><td>float32</td><td>float</td><td>float</td><td>Float</td></tr>
<tr><td><a name="int32" /> int32</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="int64" /> int64</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="uint32" /> uint32</td><td>Uses variable-length encoding.</td><td>uint32</td><td>int</td><td>int/long</td><td>uint32</td><td>uint</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="uint64" /> uint64</td><td>Uses variable-length encoding.</td><td>uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>ulong</td><td>integer/string</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sint32" /> sint32</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sint64" /> sint64</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="fixed32" /> fixed32</td><td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td><td>uint32</td><td>int</td><td>int</td><td>uint32</td><td>uint</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="fixed64" /> fixed64</td><td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td><td>uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>ulong</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="sfixed32" /> sfixed32</td><td>Always four bytes.</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>int</td><td>integer</td><td>Bignum or Fixnum (as required)</td></tr>
<tr><td><a name="sfixed64" /> sfixed64</td><td>Always eight bytes.</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>long</td><td>integer/string</td><td>Bignum</td></tr>
<tr><td><a name="bool" /> bool</td><td></td><td>bool</td><td>boolean</td><td>boolean</td><td>bool</td><td>bool</td><td>boolean</td><td>TrueClass/FalseClass</td></tr>
<tr><td><a name="string" /> string</td><td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td><td>string</td><td>String</td><td>str/unicode</td><td>string</td><td>string</td><td>string</td><td>String (UTF-8)</td></tr>
<tr><td><a name="bytes" /> bytes</td><td>May contain any arbitrary sequence of bytes.</td><td>string</td><td>ByteString</td><td>str</td><td>[]byte</td><td>ByteString</td><td>string</td><td>String (ASCII-8BIT)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-frontend-lbf-syntax"><a class="header" href="#lambdabuffers-frontend-lbf-syntax">LambdaBuffers Frontend (.lbf) syntax</a></h1>
<p>The input to the LambdaBuffers Frontend is a text file which contains a module that defines a specification of the types and type class instances you want to generate. This chapter gives the exact syntax of a LambdaBuffers Frontend file, and informally describes meaning of the syntactic constructs.</p>
<p>The name of a LambdaBuffers Frontend file must end with <code>.lbf</code>, and hence may also be referred to as a .lbf file or a .lbf schema.</p>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<p>In the following description of a LambdaBuffers Frontend file's syntax, we use a similar BNF syntax from <a href="https://www.haskell.org/onlinereport/haskell2010/">Section 10.1 of the Haskell Report</a>. So, the following notational conventions are used for presenting syntax.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody>
<tr><td><code>[pattern]</code></td><td>optional</td></tr>
<tr><td><code>{pattern}</code></td><td>zero or more repetitions</td></tr>
<tr><td><code>(pattern)</code></td><td>grouping</td></tr>
<tr><td><code>pat1⎮pat2</code></td><td>choice</td></tr>
<tr><td><code>pat1\pat2</code></td><td>difference -- elements generated by <code>pat1</code> except those generated by <code>pat2</code></td></tr>
<tr><td><code>'terminal'</code></td><td>terminal syntax surrounded by single quotes</td></tr>
</tbody></table>
</div><!-- Apparently, `mdbook`'s markdown can't escape the vertical bar in codeblocks in a table....
     So, we're using code point U+23AE to look like a vertical bar when it really isn't...

| `pat1|pat2`  | choice                                                                      | 
-->
<p>Note that the terminal syntax permits C-style escape sequences e.g. <code>'\n'</code> denotes line feed (newline), and <code>'\r'</code> denotes carriage return.</p>
<p>Productions will be of the form:</p>
<pre><code class="language-text">nonterm -&gt; alt1 | ... | altn
</code></pre>
<h2 id="input-file-representation"><a class="header" href="#input-file-representation">Input file representation</a></h2>
<p>The input file is Unicode text where the encoding is subject to the system locale. We will often use the unqualified term <em>character</em> to refer to a Unicode code point in the input file.</p>
<h2 id="characters"><a class="header" href="#characters">Characters</a></h2>
<p>The following terms are used to denote specific Unicode character categories:</p>
<ul>
<li>
<p><code>upper</code> denotes a Unicode code point categorized as an uppercase letter or titlecase letter (i.e., with General Category value Lt or Lu).</p>
</li>
<li>
<p><code>lower</code> denotes a Unicode code point categorized as a lower-case letter (i.e., with General Category value Ll).</p>
</li>
<li>
<p><code>alphanum</code> denotes either <code>upper</code> or <code>lower</code>; or a Unicode code point categorized as a modifier letter, other letter, decimal digit number, letter number, or other number (i.e., with General Category value Lt, Lu, Ll, Lm, Lo, Nd, Nl or No).</p>
</li>
<li>
<p><code>space</code> denotes a Unicode code point categorized as a separator space (i.e., with General Category value Zs), or any of the control characters <code>'\t'</code>, <code>'\n'</code>, <code>'\r'</code>, <code>'\f'</code>, or <code>'\v'</code>.</p>
</li>
</ul>
<p>Interested readers may find details of Unicode character categories in <a href="https://www.unicode.org/versions/Unicode15.1.0/">Section 4.5 of The Unicode Standard 15.1.0</a>, and the <a href="https://unicode.org/ucd/">Unicode Character Database</a>.</p>
<h2 id="lexical-syntax"><a class="header" href="#lexical-syntax">Lexical syntax</a></h2>
<p>Tokens form the vocabulary of LambdaBuffers Frontend files. The classes of tokens are defined as follows.</p>
<pre><code class="language-text">keyword         -&gt; 'module' | 'sum' | 'prod' | 'record'
                 | 'opaque' | 'class' | 'instance' | 'import' 
                 | 'qualified' | 'as'
modulename      -&gt; uppercamelcase
longmodulename  -&gt; modulealias modulename
typename        -&gt; uppercamelcase
fieldname       -&gt; lowercamelcase\keyword
longtypename    -&gt; modulealias typename
varname         -&gt; lowers\keyword
punctuation     -&gt; '&lt;=' | ',' | '(' | ')' | '{' | '}' 
                 | ':' | ':-' | '=' | '|'
classname       -&gt; uppercamelcase
longclassname   -&gt; modulealias uppercamelcase
</code></pre>
<p>where</p>
<pre><code class="language-text">uppercamelcase -&gt; upper { alphanum }
lowercamelcase -&gt; lower { alphanum }
modulealias    -&gt; { uppercamelcase '.' }
lowers         -&gt; lower { lower }
</code></pre>
<p>Input files are broken into <em>tokens</em> which use the <em>maximal munch</em> rule i.e., at each point, the next token is the longest sequence of characters that form a valid token. <code>space</code>s or line comments are ignored except as it separates tokens that would otherwise combine into a single token.</p>
<h3 id="line-comments"><a class="header" href="#line-comments">Line comments</a></h3>
<p>A <em>line comment</em> starts with the terminal <code>'--'</code> followed by zero or more printable Unicode characters stopping at the first end of line (<code>'\n'</code> or <code>'\r\n'</code>).</p>
<h2 id="syntax-of-lambdabuffers-frontend-files"><a class="header" href="#syntax-of-lambdabuffers-frontend-files">Syntax of LambdaBuffers Frontend files</a></h2>
<p>A LambdaBuffers Frontend file defines a module that is a collection of data types, classes, instance clauses, and derive clauses.</p>
<p>The overall layout of a LambdaBuffers Frontend file is:</p>
<pre><code class="language-text">module -&gt; 'module' longmodulename { import } { statement }
</code></pre>
<p>The file must specify the module's <code>longmodulename</code> where its <code>modulename</code> must match the LambdaBuffers Frontend file's file name not including the <code>.lbf</code> extension.
After, the file may contain a sequence of <code>import</code>s followed by a sequence of <code>statement</code>s.</p>
<h3 id="import"><a class="header" href="#import">Import</a></h3>
<p>Imports bring <em>entities</em> (types and classes) of other modules into scope.</p>
<pre><code class="language-text">import     -&gt; 'import' [ 'qualified' ] longmodulename [ 'as' longmodulename ] [ importspec ]
importspec -&gt; '(' [ { typename ',' } typename [','] ] ')'
</code></pre>
<p>If <code>importspec</code> is omitted, then all entities specified in the module are imported; otherwise only the specified entities are imported.</p>
<h3 id="statement"><a class="header" href="#statement">Statement</a></h3>
<p>Statements define types, classes, instance clauses, and derive clauses.</p>
<pre><code class="language-text">statement -&gt; typedef
           | classdef
           | instanceclause
           | deriveclause
</code></pre>
<h4 id="type-definitions"><a class="header" href="#type-definitions">Type definitions</a></h4>
<p>Types may be either sum types, product types, record types, or opaque types.</p>
<pre><code class="language-text">typedef -&gt; prodtypedef | sumtypedef |  recordtypedef | opaquetypedef
</code></pre>
<h5 id="product-type-definition"><a class="header" href="#product-type-definition">Product type definition</a></h5>
<p>A product type definition defines a new product type.</p>
<pre><code class="language-text">prodtypedef -&gt; 'prod' typename { varname } '=' prod
prod        -&gt; { typeexp }
typeexp     -&gt; varname
             | longtypename
             | '(' prod ')'
</code></pre>
<p>Product type definitions instruct the code generator to generate a product type for the target language.</p>
<h5 id="sum-type-definition"><a class="header" href="#sum-type-definition">Sum type definition</a></h5>
<p>A sum type definition defines a new sum type.</p>
<pre><code class="language-text">sumtypedef     -&gt; 'sum' typename { varname } '=' sum
sum            -&gt; sumconstructor { '|' sumconstructor }
sumconstructor -&gt; typename prod
</code></pre>
<p>Sum type definitions instruct the code generator to generate a sum type for the target language.</p>
<h5 id="record-type-definition"><a class="header" href="#record-type-definition">Record type definition</a></h5>
<p>A record type definition defines a new record type.</p>
<pre><code class="language-text">recordtypedef -&gt; 'record' typename { varname } '=' record
record        -&gt; '{' [ field { ',' field  } ] '}'
field         -&gt; fieldname ':' prod
</code></pre>
<p>Record type definitions instruct the code generator to generate a record type for the target language.</p>
<h5 id="opaque-type-definition"><a class="header" href="#opaque-type-definition">Opaque type definition</a></h5>
<p>An opaque type definition defines a new opaque type.</p>
<pre><code class="language-text">opaquetypedef -&gt; 'opaque' typename { varname }
</code></pre>
<p>Opaque type definitions must map to existing types in the target language and it's up to the Codegen module to determine how that's exactly done.</p>
<h4 id="class-definition"><a class="header" href="#class-definition">Class definition</a></h4>
<p>A class definition introduces a new class.</p>
<pre><code class="language-text">classdef       -&gt; 'class' [ constraintexps '&lt;=' ] classname { varname }
constraintexp  -&gt; classref { varname }
                | '(' constraintexps ')'
constraintexps -&gt; [ constraintexp { ',' constraintexp } ]
</code></pre>
<p>Class definitions communicate with the code generator the implementations that already exist (via instance clauses) or that one would like to generate (via derive clauses).</p>
<h4 id="instance-clause"><a class="header" href="#instance-clause">Instance clause</a></h4>
<p>An instance clause specifies a type is an instance of a class.</p>
<pre><code class="language-text">instanceclause -&gt; 'instance'  constraint [ ':-' constraintexps ]
constraint     -&gt; classref { typeexp }
</code></pre>
<p>Instance clauses do not instruct the code generator to generate code, but instead instructs the compiler (semantic checking) that the target language environment provides type class implementations for the given type (provided that the given <code>constraintexps</code> also have implementations).</p>
<h4 id="derive-clause"><a class="header" href="#derive-clause">Derive clause</a></h4>
<p>Derive clauses instruct the code generator to generate code for a type so that it is an instance of a class.</p>
<pre><code class="language-text">deriveclause -&gt; 'derive' constraint
</code></pre>
<p>Note the code generation of a type for a class is implemented via builtin derivation rules (which developers may extend).</p>
<h3 id="syntax-reference"><a class="header" href="#syntax-reference">Syntax reference</a></h3>
<p>The summarized productions of a LambdaBuffers Frontend file is as follows.</p>
<pre><code class="language-text">module -&gt; 'module' longmodulename { import } { statement }

import     -&gt; 'import' [ 'qualified' ] longmodulename [ 'as' longmodulename ] [ importspec ]
importspec -&gt; '(' [ { typename ',' } typename [','] ] ')'

statement -&gt; typedef
           | classdef
           | instanceclause
           | deriveclause

typedef -&gt; prodtypedef | sumtypedef |  recordtypedef | opaquetypedef

prodtypedef -&gt; 'prod' typename { varname } '=' prod
prod        -&gt; { typeexp }
typeexp     -&gt; varname
             | longtypename
             | '(' prod ')'

sumtypedef     -&gt; 'sum' typename { varname } '=' sum
sum            -&gt; sumconstructor { '|' sumconstructor }
sumconstructor -&gt; typename prod

recordtypedef -&gt; 'record' typename { varname } '=' record
record        -&gt; '{' [ field { ',' field  } ] '}'
field         -&gt; fieldname ':' prod

opaquetypedef -&gt; 'opaque' typename { varname }

classdef       -&gt; 'class' [ constraintexps '&lt;=' ] classname { varname }
constraintexp  -&gt; classref { varname }
                | '(' constraintexps ')'
constraintexps -&gt; [ constraintexp { ',' constraintexp } ]

instanceclause -&gt; 'instance'  constraint [ ':-' constraintexps ]
constraint     -&gt; classref { typeexp }

deriveclause -&gt; 'derive' constraint
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-compiler"><a class="header" href="#lambdabuffers-compiler">LambdaBuffers Compiler</a></h1>
<p>The <em>Compiler</em> component sits between the <em>Frontend</em> component and the code
generation component named <em>Codegen</em>. The purpose of the <em>Compiler</em> is to
perform various checks on the <a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-CompilerInput">Compiler
input</a>
provided by the <em>Frontend</em> ensuring that supplied type, class and instance
clause definitions are valid or otherwise communicate any error conditions
determined during processing.</p>
<p>The end goal of the <em>Compiler</em> is to ensure that the <em>Codegen</em> component is
capable of processing the <em>Compiler Output</em> by providing correct and complete
information.</p>
<h2 id="compiler-interface"><a class="header" href="#compiler-interface">Compiler Interface</a></h2>
<p>The <em>Compiler</em> operates on the <em>Compiler Input</em> message specified in the
<a href="../lambda-buffers-proto/compiler.proto">compiler.proto</a> <a href="https://protobuf.dev/">Google Protocol
Buffers</a> schema - enabling, any <em>Frontend</em> to interface
with the <em>Compiler</em> in a language agnostic manner.</p>
<p>Similarly, the <em>Compiler Output</em> message is also specified in the
<a href="../lambda-buffers-proto/compiler.proto">compiler.proto</a> <a href="https://protobuf.dev/">Google Protocol
Buffers</a> schema that is then consumed by <em>Codegen</em>
modules, able to be written in any programming environment capable of
communicating via <a href="https://protobuf.dev/">Google Protocol Buffers</a>.</p>
<p>Refer to the <a href="../lambda-buffers-proto/compiler-proto.html">Compiler Proto
documentation</a> for more information.</p>
<h2 id="checking-type-definitions"><a class="header" href="#checking-type-definitions">Checking Type Definitions</a></h2>
<p>The first step the Compiler performs is <em>kind checking and inference</em> on <a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-TyDef">type
definitions</a>
provided by the <em>Frontend</em> and otherwise raises <a href="compiler.html#missing-link">kind checking errors</a>.</p>
<p>When successful, the Compiler outputs a <a href="compiler.html#missing-link">Compiler Output</a> that
annotates each <a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-Ty">type
term</a> with
<a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-Kind">kind</a>
information.</p>
<p>In standard <em>type checking</em> terminology LambdaBuffers 'terms' are <a href="https://en.wikipedia.org/wiki/Abstract_data_type">abstract data
type</a> declarations and their
'types' are <em>kinds</em>.</p>
<p>Currently, the <em>Compiler</em> accepts:</p>
<ol>
<li>
<p>type terms of kind <code>Type</code> (such as <code>Int</code> or <code>Bool</code>),</p>
</li>
<li>
<p>type function terms of kind <code>Type → Type</code> (such as <code>Maybe</code> or <code>Either</code> -
though note that type functions are not "first class" in the sense that they
cannot be passed as arguments to other type functions).</p>
</li>
</ol>
<p>There are future plans to expand this to Higher Kinded Types (such as <code>MaybeT</code>,
<code>StateT</code> etc - i.e. types parameterized on type function terms) - subject to
research into <em>Codegen</em> of such types in the target languages.</p>
<p>The <em>Compiler</em> supports recursive types.</p>
<p>All LambdaBuffers <a href="../lambda-buffers-proto/compiler-proto.html#lambdabuffers-compiler-TyArg">type
variables</a>
terms must be monomorphically kinded, with polymorphic kinds defaulting to
monomorphic ones. For example <code>Phantom a = Phantom</code> would resolve to the
monomorphic kind <code>Type → Type</code> rather than the polymorphic kind <code>∀a. a → Type</code>.</p>
<h3 id="kind-checker"><a class="header" href="#kind-checker">Kind Checker</a></h3>
<p>The kind checker is designed around a simply typed lambda calculus type system
with inference via unification (<em>John Alan Robinson's</em> unification algorithm is
being currently used). We've also introduced a <code>let</code> binding rule that allows
later additions to the typing context. The typing rules are the following:</p>
<pre><code class="language-text"> x : σ ∈ Γ
----------- [Variable]
 Γ ⊢ x : σ


      Γ,x:σ ⊢ e:τ
------------------------ [Abstraction]
 Γ ⊢ (λ x:σ. e):(σ → τ)


Γ ⊢ x:(σ → τ)    Γ ⊢ y:σ
------------------------- [Application]
       Γ ⊢ x y : τ


Γ ⊢ e₁:σ    Γ, e₁ : σ ⊢ e₂:τ
----------------------------- [Let]
   Γ ⊢ let x = e₁ in e₂ : τ
</code></pre>
<p>The type checking strategy is as follows:</p>
<ol>
<li>
<p>A context is built from the type definitions. Type variables which are not
annotated with any further kind information are defaulted to be of kind
<code>Type</code>.</p>
</li>
<li>
<p>The RHS of the type terms are converted into their <em>Sums of Products</em>
canonical representation. The variables from the left hand side of the term
are introduced to the right hand side as abstractions.</p>
</li>
<li>
<p>The derivation for each term is built.</p>
</li>
<li>
<p>Then the unification tries to find a solution.</p>
</li>
</ol>
<p>Terms for which unification cannot find a consistent derivation are deemed
incorrect and a kind checking error is thrown. Note that currently all of the
inferred kinds have a restriction to be monomorphic - therefore no free or
universally quantified variables can appear in the final kind signature.</p>
<h2 id="checking-type-cardinality"><a class="header" href="#checking-type-cardinality">Checking Type Cardinality</a></h2>
<p>In addition to <em>kind checking</em>, the Compiler could perform a special check for
types to determine their cardinality. This is especially useful to catch and
report on <em>non inhabited</em> types that users might define.</p>
<p>For example, <code>data F a = F (F a)</code> declares a <em>non-inhabited recursive type</em> that
can't be constructed. LambdaBuffers Compiler <em>SHOULD</em> reject such types as they
can't possibly be constructed and generated typeclass instances would in turn be
ill-defined.</p>
<p>This problem is equivalent to a problem of <a href="https://en.wikipedia.org/wiki/Component_(graph_theory)">calculating graph
components</a>.</p>
<h2 id="normalizing-type-definitions"><a class="header" href="#normalizing-type-definitions">Normalizing Type Definitions</a></h2>
<p>Finally, the compiler should be able to <em>normalize</em> expressions. For example, it
may be possible to define a data type in the schema language in a form similar
to: <code>data G a = G ((Either) ((Maybe) a) Int)</code>, where the bracketing indicates
the order of application within the term. The example term would normalize to
<code>data G a = G (Either (Maybe a) Int)</code> - resulting in a cleaner (and more
performant) code generation.</p>
<h2 id="checking-typeclass-definitions-and-instance-clauses"><a class="header" href="#checking-typeclass-definitions-and-instance-clauses">Checking Typeclass Definitions and Instance Clauses</a></h2>
<p>The <em>Compiler</em> should, if possible, ensure that all instance declarations for
schemata are derivable using hard-coded derivation axioms.</p>
<p>Other schema languages support generating type definitions in many languages
from a single definition in the schema language. One key feature that sets
LambdaBuffers apart from these alternatives is support for
<a href="https://en.wikipedia.org/wiki/Type_class"><em>typeclasses</em></a>, which enable the
generation of <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">ad-hoc polymorphic
functions</a> that operate on
types generated from LambdaBuffers schemata.</p>
<p>The LambdaBuffers schema language doesn't allow users to specify typeclass instance
implementations themselves. Users, instead, will write <em>instance clauses</em> as
part of the schema definition, and the LambdaBuffers code generator will derive
these declared instances when generating code.</p>
<p>Two important consequences of this design decision are:</p>
<ol>
<li>
<p><em>All instances must be derived structurally</em>. As an example, consider the
arbitrary product type <code>data P a b = P a b</code>. The semantics of the generated
instance (i.e. the behavior of the generated code) must be determinable from the
<em>structure of the type</em> - that it is a product - and the instances for its
arguments <code>a</code> and <code>b</code>, and by those features alone. (Since <code>a</code> and <code>b</code> are type
variables here, writing a direct instance for any interesting class is likely
impossible, so LambdaBuffers supports constrained instances such as <code>instance (C a, C b) =&gt; C (P a b)</code>)</p>
</li>
<li>
<p><em>All instances must be uniform across supported languages</em>. Because the
LambdaBuffers <em>Codegen</em> component (and <em>not</em> the user) is responsible for
generating instances, we must ensure that the codegen component is suitably
equipped to generate instances in each language that exhibit behavior which is,
to the greatest extent possible, equivalent to the behavior of generated
instances in any other language. We <em>must</em> have an extensive test quite to
verify uniform behavior of generated instances.</p>
</li>
</ol>
<p>In languages with a typeclass system (Haskell, PureScript) or equivalent (Rust's
Traits), we will utilize the existing system and <em>should</em> (to the extent that
doing so is feasible) utilize existing typeclasses and instances from commonly
used or standard libraries. In languages lacking a type system that is
sufficiently rich to express typeclass relations, we will generate instances
using idiomatic language features. (The details will depend on the particular
language.)</p>
<h2 id="missing-link"><a class="header" href="#missing-link">Missing link</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-codegen"><a class="header" href="#lambdabuffers-codegen">LambdaBuffers Codegen</a></h1>
<p>NOTE: The implementation of the code generation framework is still in early
stages and will likely undergo substantial changes as development
continues. This document serves to outline general principles that any
implementation of the LambdaBuffers code generation framework ought to adhere
to.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ol>
<li>Modular &amp; reusable components</li>
<li>Ergonomic interface</li>
<li>Extensible to new opaque types</li>
<li>Extensible to new type classes</li>
</ol>
<h3 id="modular--reusable-components"><a class="header" href="#modular--reusable-components">Modular &amp; Reusable Components</a></h3>
<p>Because the code generation modules for each target language will almost
certainly constitute the bulk of the final LambdaBuffers codebase, it is
essential that components of the code generation framework be as modular and
reusable as is practicable.</p>
<p>Although each target language has its own distinct syntax and semantics, many
syntactic forms exist in multiple target languages. For example, Haskell and
PureScript both use a comma-separated set enclosed in square brackets
(e.g. <code>[1,2,3]</code>) to represent a <code>List _/[_]</code> value, while Rust uses a similar
form (in conjunction with a macro, e.g. <code>vec![1,2,3]</code>) to represent a
<code>Vector&lt;_&gt;</code> value. To reduce redundant and superfluous code, common syntactic
patterns such at this should be abstracted out into a set of functions that can
be reused across languages.</p>
<h3 id="ergonomic-interface"><a class="header" href="#ergonomic-interface">Ergonomic Interface</a></h3>
<p>While the LambdaBuffers team will support a finite set of specific target
languages, adding support for an additional language should be as painless as
possible (ceteris paribus) to encourage and facilitate open source contributions
by third parties. A basic set of tools which can be used to write code
generation modules for any target language should be developed, and all code
generation modules written by the LambdaBuffers team should employ those tools
(in order to provide a robust set of examples for future contributors, among
other benefits).</p>
<h3 id="extensible-to-new-opaque-types"><a class="header" href="#extensible-to-new-opaque-types">Extensible to New Opaque Types</a></h3>
<p>Users and contributors should be able to easily extend the default set of
supported opaque types to support additional opaque types. In the context of
code generation, this means: Users should have the ability to specify the target
type for a given opaque type in the target language (including the package or
module that contains the target type if the target type is not part of the
language's standard library).</p>
<p>Because type class instances must be derived structurally, and because an opaque
type is by definition a type with no visible internal structure, users should be
provided with an ergonomic interface for noting the presence of a type class
instance for an opaque type's target type in a particular language (if the
instance exists in the standard library), or for referring to the module where
such an instance is located (if the instance is defined in a library or by the
user in one of their own modules).</p>
<h3 id="extensible-to-new-type-classes"><a class="header" href="#extensible-to-new-type-classes">Extensible to New Type Classes</a></h3>
<p>Users and contributors should be able to easily extend the default set of
supported type classes to support additional type classes and facilitate the
derivation of instances for newly defined classes.</p>
<p>In practice, the type class code generation machinery must consist of two
distinct parts: First, a set of deriving rules which correspond to instances
that already exist (in some module or in a language's standard
library/prelude). Second, code generation functions that operate on user-defined
types which satisfy those rules.</p>
<p>Each of these parts should be ergonomic, well-documented, and the implementation
of the default set of supported type classes ought to be thoroughly commented in
order that users have a diverse set of real examples to work from.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdabuffers-command-line-interface"><a class="header" href="#lambdabuffers-command-line-interface">LambdaBuffers Command Line Interface</a></h1>
<p>LambdaBuffers consists of three runtime command line interface components:</p>
<ul>
<li><a href="lambda-buffers-frontend-cli">lambda-buffers-frontend-cli</a></li>
<li><a href="lambda-buffers-compiler-cli">lambda-buffers-compiler-cli</a></li>
<li><a href="todo-link">lambda-buffers-codegen-cli</a></li>
</ul>
<p>The <em>Frontend</em> CLI orchestrates work between the user and the <em>Compiler</em> and
<em>Codegen</em> components.</p>
<p>It's desirable to have both the <em>Compiler</em> CLI and the <em>Codegen</em> CLI subject to
a strict API with a specified set of flags to enable CLI implementation from
various sources. This would be especially helpful with <em>Codegen</em> modules that
bring about support for new targets, opaque types and typeclasses.</p>
<!-- TODO(bladyjoker): Complete this chapter -->
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file -->
<h1 id="comparison-matrix"><a class="header" href="#comparison-matrix">Comparison Matrix</a></h1>
<p>Legend:</p>
<ul>
<li>🟢 Available (grading added in some cases spanning: Bad, Average, Good, Excellent)</li>
<li>🟡 In development</li>
<li>🔵 Potential future feature</li>
<li>🔴 Not currently available</li>
<li>❔ Not clear</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th><strong>Feature</strong></th><th><strong>Proto Buffers</strong></th><th><strong>ADL</strong></th><th><strong>JSON Schema</strong></th><th><strong>Lambda Buffers</strong></th><th><strong>CDDL</strong></th><th><strong>ASN.1</strong></th></tr></thead><tbody>
<tr><td>Sum types</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>🟢</td></tr>
<tr><td>Record types</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td></tr>
<tr><td>Product types</td><td>🔴</td><td>🔴</td><td>🔴</td><td>🟢</td><td>❔</td><td>🔴</td></tr>
<tr><td>Recursive types</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>❔</td></tr>
<tr><td>Parameterized types (generic types)</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>🔴</td></tr>
<tr><td>Type annotations/constraints</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🔵</td><td>🟢</td><td>🟢</td></tr>
<tr><td>Add new builtin types</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Add new type semantics (e.g. different encodings)</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🟢</td></tr>
<tr><td>Manage type semantics (at language level)</td><td>🔴</td><td>🔴</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Codegen support</td><td>🟢 (Excellent)</td><td>🟢 (Average)</td><td>🟢 (Excellent)</td><td>🟡</td><td>🟢 (Bad)</td><td>🟢 (Average)</td></tr>
<tr><td>DevOps tooling - build system integration</td><td>🟢</td><td>🔴</td><td>❔</td><td>🟡</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Documentation tooling</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🔵</td><td>🔴</td><td>❔</td></tr>
<tr><td>Formatting, linting, and development environment tools</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Language checker API</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Codegen API</td><td>🟢</td><td>🟢</td><td>🔴</td><td>🟢</td><td>🔴</td><td>🔴</td></tr>
<tr><td>Language specification</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td><td>🟢</td></tr>
<tr><td>Backwards compatibility strategy</td><td>🟢</td><td>🔴</td><td>🔴</td><td>🔴</td><td>🔴</td><td>🔴</td></tr>
</tbody></table>
</div>
<h2 id="descriptions"><a class="header" href="#descriptions">Descriptions</a></h2>
<h3 id="sum-types-3"><a class="header" href="#sum-types-3">Sum Types</a></h3>
<p>Types of the form <code>Time = Present | Past | Future</code>, which allow a type do be
constructed by one of many variants. Think Rust's <code>enums</code>.</p>
<h3 id="product-types-3"><a class="header" href="#product-types-3">Product Types</a></h3>
<p>Types of the form <code>Person = MkPerson Age Name</code>, where <code>MkPerson</code> is of Kind
<code>Type-&gt;Type-&gt;Type</code>. Product types combine multiple elements into one data type
without tagging the elements.</p>
<h3 id="record-types-3"><a class="header" href="#record-types-3">Record Types</a></h3>
<p>Types of the form <code>Person = MkPerson { age :: Age, name :: Name }</code>. Record types
are similar to <code>structs</code> in most programming languages.</p>
<h3 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h3>
<p>Recursive types are defined by the presence of the LHS type in its RHS
definition. A classic example is:</p>
<pre><code class="language-text">List a = Nil | Cons a (List a)
^^^^^^                 ^^^^^^
</code></pre>
<h3 id="parameterized-types-generics"><a class="header" href="#parameterized-types-generics">Parameterized Types (Generics)</a></h3>
<p>Type functions allow for the introduction of type variables in the LHS definition
of the term - creating a parametrised type definition. The classic example is
<code>Maybe a</code> which is the equivalento of <code>Option &lt;A&gt;</code> in rust:</p>
<pre><code class="language-text">Maybe a = Nothing | Just a
</code></pre>
<p>Using the above type definition we can now define another type that uses <code>Maybe</code>
and instantiates it to use <code>Integer</code></p>
<pre><code class="language-text">Time_Saved_via_LambdaBuffers = Maybe Integer
</code></pre>
<h3 id="type-annotations--constraints"><a class="header" href="#type-annotations--constraints">Type Annotations / Constraints</a></h3>
<p>There exists a system of constraining or further annotating types - enriching
the type's specification.</p>
<h3 id="add-new-built-in-types"><a class="header" href="#add-new-built-in-types">Add New Built-in Types</a></h3>
<p>Refer to <a href="design.html#extensible-to-new-types">design document</a>.</p>
<h3 id="add-new-type-semantics"><a class="header" href="#add-new-type-semantics">Add New Type Semantics</a></h3>
<p>Refer to the <a href="design.html#extensible-to-new-semantics">design document</a>.</p>
<h3 id="manage-type-semantics-at-language-level"><a class="header" href="#manage-type-semantics-at-language-level">Manage Type Semantics (at Language Level)</a></h3>
<p>Refer to the <a href="design.html#expressive-semantics-annotation">design document</a>..</p>
<h3 id="codegen-support"><a class="header" href="#codegen-support">Codegen Support</a></h3>
<p>Codegen support relates to the language being able to generate types for other
programming languages.</p>
<h3 id="devops-tooling---build-system-integration"><a class="header" href="#devops-tooling---build-system-integration">DevOps Tooling - Build System Integration</a></h3>
<p>The framework/language provides a seamless way of integrating with normal build
tools and systems (eg. Bazel, Nix, etc.).</p>
<h3 id="documentation-tooling"><a class="header" href="#documentation-tooling">Documentation Tooling</a></h3>
<p>The language can generate human readable documentation in an easy to share and
view format. For example HTML, or Markdown.</p>
<h3 id="formatting-linting-and-development-environment-tools"><a class="header" href="#formatting-linting-and-development-environment-tools">Formatting, Linting, and Development Environment Tools</a></h3>
<p>Tools that allow formatting, linting, and automating standardisation of the
language specific files.</p>
<h3 id="language-checker-api"><a class="header" href="#language-checker-api">Language Checker API</a></h3>
<p>The language checker component exposes an API to interface with itself in a
language agnostic manner.</p>
<h3 id="codegen-api"><a class="header" href="#codegen-api">Codegen API</a></h3>
<p>The language codegen component exposes an API to interface with itself in a
language agnostic manner.</p>
<h3 id="language-specification"><a class="header" href="#language-specification">Language Specification</a></h3>
<p>There exists a well defined language specification document.</p>
<h3 id="backwards-compatibility-strategy"><a class="header" href="#backwards-compatibility-strategy">Backwards Compatibility Strategy</a></h3>
<p>The language makes certain backwards compatibility guarantees between versions of
the same type definition.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>https://json-schema.org/implementations.html</li>
<li>https://www.rfc-editor.org/rfc/rfc8610</li>
<li>https://github.com/timbod7/adl</li>
<li>https://www.itu.int/en/ITU-T/asn1/Pages/introduction.aspx</li>
<li>https://protobuf.dev/</li>
<li>https://github.com/dcSpark/cddl-codegen</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-reports"><a class="header" href="#catalyst-reports">Catalyst reports</a></h1>
<p>Our project was funded by Catalyst. As a proof of completion, we collected our reports of
finished Catalyst projects here:</p>
<ul>
<li><a href="catalyst09-reports">Catalyst 9 reports</a>
<ul>
<li><a href="catalyst09-reports/milestone-1.html">Milestone 1: Research</a></li>
<li><a href="catalyst09-reports/milestone-2.html">Milestone 2: End to end proof of concept</a></li>
<li><a href="catalyst09-reports/milestone-3.html">Milestone 3: Testing and documentation</a></li>
<li><a href="catalyst09-reports/milestone-3.html">Milestone 4: Project adoption</a></li>
</ul>
</li>
<li><a href="catalyst10-reports">Catalyst 10 reports</a>
<ul>
<li><a href="catalyst10-reports/milestone-1.html">Milestone 1: Rust support</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-9-reports"><a class="header" href="#catalyst-9-reports">Catalyst 9 reports</a></h1>
<ul>
<li><a href="catalyst09-reports/catalyst09-reports/milestone-1.html">Milestone 1: Research</a></li>
<li><a href="catalyst09-reports/catalyst09-reports/milestone-2.html">Milestone 2: End to end proof of concept</a></li>
<li><a href="catalyst09-reports/catalyst09-reports/milestone-3.html">Milestone 3: Testing and documentation</a></li>
<li><a href="catalyst09-reports/catalyst09-reports/milestone-3.html">Milestone 4: Project adoption</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-1-research"><a class="header" href="#catalyst-milestone-1-research">Catalyst milestone 1: Research</a></h1>
<h2 id="outputs"><a class="header" href="#outputs">Outputs</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
A report summarizing user interviews and containing a qualitative analysis of the discovered use cases.
<ul>
<li><strong>STATUS</strong>: Done (#17)</li>
<li>An interview with 3 MLabs engineers was performed (1.5h) who's work span multiple Cardano dApp projects. Their <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/feedback/interview-notes.md">feedback</a> is made available in the repo.</li>
<li>Additionally, a survey was sent out to MLabs engineers and their <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/feedback/questionnaire-results.pdf">feedback</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
An architecture design document.
<ul>
<li><strong>STATUS</strong>: Done (#17)</li>
<li>Extensive documentation on <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/design.md">design</a>, <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/compiler.md">compiler</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/codegen.md">codegen</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A language specification document elaborating on the data type model features.
<ul>
<li><strong>STATUS</strong>: Done (#17)</li>
<li>Extensive documentation on <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/design.md">design</a>, <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/compiler.md">compiler</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/codegen.md">codegen</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A related work document comparing the proposed technology via a feature matrix with others in the same space.
<ul>
<li><strong>STATUS</strong>: Done (#17, #18)</li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/comparison-matrix.md">Document</a> comparing different schema techologies to LambdaBuffers is made available in the repo</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
An initial compiler implementation that performs some basic checks in accordance with the language specification.
<ul>
<li><strong>STATUS</strong>: Done (#10)</li>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-compiler">initial compiler implementation perform</a> <code>kind checking</code> is made available in the repo.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria"><a class="header" href="#acceptance-criteria">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
At least 3 users/projects have been interviewed about their desired use case for this technology.
<ul>
<li>An interview with 3 MLabs engineers was performed (1.5h) who's work span multiple Cardano dApp projects. Their <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/feedback/interview-notes.md">feedback</a> is made available in the repo.</li>
<li>Additionally, a survey was sent out to MLabs engineers and their <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/feedback/questionnaire-results.pdf">feedback</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The architecture design document is completed and available in the project repository.
<ul>
<li>Extensive documentation on <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/design.md">design</a>, <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/compiler.md">compiler</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/codegen.md">codegen</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The initial compiler implementation is completed, capturing SOME of the intended language semantics as described in the Language Specification
<ul>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-compiler">initial compiler implementation perform</a> <code>kind checking</code> is made available in the repo.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion"><a class="header" href="#evidence-of-milestone-completion">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Completed and reviewed design document is available in the project repository.
<ul>
<li>Extensive documentation on <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/design.md">design</a>, <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/compiler.md">compiler</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/docs/codegen.md">codegen</a> is made available in the repo.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Completed and reviewed initial version of the compiler command line tool made available in the project repository.
<ul>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-frontend">Frontend CLI</a> called <code>lambda-buffers-frontend-cli</code> is made available in the repo and is currently able to parse, validate and format <code>.lbf</code> documents that contain the LambdaBuffers type modules:</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">lambda-buffers/lambda-buffers-frontend$ cabal run 
Usage: lambda-buffers-frontend-cli COMMAND

  LambdaBuffers Frontend command-line interface tool

Available options:
  -h,--help                Show this help text

Available commands:
  compile                  Compile a LambdaBuffers Module (.lbf)
  format                   Format a LambdaBuffers Module (.lbf)
</code></pre>
<p>There's ongoing work to integrate the <a href="catalyst09-reports/lambda-buffers-compiler">Compiler CLI</a> in the Frontend CLI.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Compiler is able to validate a schema that uses a subset of types and capabilities from the spec.
<ul>
<li>Both the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-frontend">Frontend</a> and the <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-compiler">Compiler</a> components are accompanied by a test suite that is routinely run by the projects' CI system.</li>
<li>A <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-frontend/resources">corpus of <code>lbf</code></a> files is made available in the repo and used in the test suite to ensure correct document handling.</li>
<li>The <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-compiler/test/Test/KindCheck.hs">compiler tests on the kind checking machinery</a> is also made available in the repo.</li>
</ul>
</li>
</ul>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/16dTxgGsxHvcMe5aCgFPDYEJKgX_VQiNAcwhp2RyA48o/edit#gid=1672366179">Catalyst project sheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-2-end-to-end-proof-of-concept"><a class="header" href="#catalyst-milestone-2-end-to-end-proof-of-concept">Catalyst milestone 2: End to end proof of concept</a></h1>
<h2 id="outputs-1"><a class="header" href="#outputs-1">Outputs</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
A configuration DSL for specifying domain data types.
<ul>
<li>LambdaBuffers <strong>Frontend</strong> supports specifying modules with <strong>type definitions</strong> with <strong>opaque</strong>, <strong>product/record</strong> and <strong>sum</strong> types. Additionally, type <strong>class definitions</strong> are supported as well as type <strong>class rule definitions</strong> using the 'instance clause' and 'derive' syntax.</li>
<li>Refer to the standard LambdaBuffers library <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/lbf-base">lbf-base</a> to get a sense of what the language looks like.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A compiler tool that outputs the interpreted configuration.
<ul>
<li>The Compiler is exposed via an <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/main/lambda-buffers-proto/compiler.proto">Google Protobuffers based API</a>. The Codegen shares the same API types and is exposed in a similar fashion. The Frontend communicates with these components via the API.</li>
<li>The API documentation is made available via <a href="https://mlabs-haskell.github.io/lambda-buffers/compiler-api.html">LambdaBuffers Github Pages</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Codegen module that takes in the interpreted configuration and outputs a Haskell+PlutusTx (was Plutarch) Cabal project containing all the types and necessary type class wiring.
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Haskell</a>.</li>
<li>The auto-generated Haskell files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers</a>.</li>
<li>Codegen module outputs Haskell type definitions, and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Eq.html#t:Eq">Prelude.Eq</a> and <a href="https://github.com/input-output-hk/plutus/blob/848ec58de981a144226ee203c46144c0f3213f26/plutus-tx/src/PlutusTx/IsData/Class.hs#L34">PlutusTx.ToData</a> type class implementations automatically.</li>
<li>Plutarch Codegen module is suspended for the current milestone (as communicated with the Catalyst team). Plutarch is a Haskell EDSL for writing Plutus (UPLC) programs, and can be considered a completely separate backend/target language.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Codegen module that takes in the interpreted configuration and outputs a Purescript+CTL Spago project containing all the types and necessary wiring.
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Purescript">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Purescript</a>.</li>
<li>The auto-generated Purescript files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers</a>.</li>
<li>Codegen module outputs Purescript type definitions and <a href="https://pursuit.purescript.org/packages/purescript-prelude/3.1.0/docs/Data.Eq#t:Eq">Prelude.Eq</a> and <a href="https://github.com/Plutonomicon/cardano-transaction-lib/blob/b565f4b1ec877c671ec4ffc13b1b89dbe498bceb/src/Internal/ToData.purs#L73">Ctl.Internal.ToData
</a> type class implementations.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-1"><a class="header" href="#acceptance-criteria-1">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The generated Haskell+Plutarch Cabal project can successfully be built.</li>
<li><input disabled="" type="checkbox" checked=""/>
The generated Purescript+CTL Spago project can successfully be built.</li>
<li><input disabled="" type="checkbox" checked=""/>
All the above codegen modules are reviewed and made available in the project repository.</li>
</ul>
<h2 id="evidence-of-milestone-completion-1"><a class="header" href="#evidence-of-milestone-completion-1">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Project repository is equipped with continuous integration tooling.
<ul>
<li>The repository has been consistently built with <a href="https://hercules-ci.com/">HerculesCI</a> since the beginning.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Completed and reviewed Haskell+Plutarch codegen module is made available in the project repository and the CI builds it successfully.
<ul>
<li>The auto-generated Haskell files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers</a>.</li>
<li>Additionally, the auto generated Haskell files used during the demo can be found in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/plutustx-env/autogen/LambdaBuffers">experimental/plutustx-env/autogen/LambdaBuffers</a>.</li>
<li>Codegen module outputs Haskell type definitions, and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Eq.html#t:Eq">Prelude.Eq</a> and <a href="https://github.com/input-output-hk/plutus/blob/848ec58de981a144226ee203c46144c0f3213f26/plutus-tx/src/PlutusTx/IsData/Class.hs#L34">PlutusTx.ToData</a> type class implementations automatically.</li>
<li>Plutarch Codegen module is suspended for the current milestone (as communicated with the Catalyst team). Plutarch is a Haskell EDSL for writing Plutus (UPLC) programs, and can be considered a completely separate backend/target language.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Completed and reviewed Purescript+CTL codegen module is made available in the project repository and the CI builds it successfully.
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Purescript">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Purescript</a>.</li>
<li>The auto-generated Purescript files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers</a>.</li>
<li>Additionally, the auto generated Purescript files used during the demo can be found in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/ctl-env/autogen/LambdaBuffers">experimental/ctl-env/autogen/LambdaBuffers</a>.</li>
<li>Codegen module outputs Purescript type definitions and <a href="https://pursuit.purescript.org/packages/purescript-prelude/3.1.0/docs/Data.Eq#t:Eq">Prelude.Eq</a> and <a href="https://github.com/Plutonomicon/cardano-transaction-lib/blob/b565f4b1ec877c671ec4ffc13b1b89dbe498bceb/src/Internal/ToData.purs#L73">Ctl.Internal.ToData
</a> type class implementations.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Compiler is able to output a valid module with types from a schema in Haskell+Plutarch.
<ul>
<li>The auto-generated Haskell files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/haskell-autogen/LambdaBuffers</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Compiler is able to output a valid module with types from a schema in PureScript.
<ul>
<li>The auto-generated Purescript files can be viewed in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/43d53222756e7b9bff836ec56e1a9b838678632e/lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers">lambda-buffers-codegen/data/goldens/purescript-autogen/LambdaBuffers</a>.</li>
</ul>
</li>
</ul>
<h2 id="demo-recordings"><a class="header" href="#demo-recordings">Demo recordings</a></h2>
<ul>
<li>Introduction, working with the LambdaBuffers CLI tools and Frontend overview.
<ul>
<li><a href="https://www.youtube.com/watch?v=KnznwIdkFLM">https://www.youtube.com/watch?v=KnznwIdkFLM</a></li>
</ul>
</li>
<li>Codegen into Haskell
<ul>
<li><a href="https://www.youtube.com/watch?v=WhZU66fcnig">https://www.youtube.com/watch?v=WhZU66fcnig</a></li>
</ul>
</li>
<li>Codegen into Purescript
<ul>
<li><a href="https://www.youtube.com/watch?v=tXnjt5h7D9w">https://www.youtube.com/watch?v=tXnjt5h7D9w</a></li>
</ul>
</li>
</ul>
<p>Demo files:</p>
<ul>
<li>LambdaBuffers <a href="https://github.com/mlabs-haskell/lambda-buffers/blob/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/plutustx-env/api/Citizen.lbf">Citizen.lbf</a> module.</li>
<li>Purescript demo files <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/ctl-env/autogen/LambdaBuffers">ctl-env</a>.</li>
<li>Haskell demo files <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/8b0900ebdd526ed042040d5bc9cef5a5b0281e98/experimental/plutustx-env">plutustx-env</a>.</li>
</ul>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/16dTxgGsxHvcMe5aCgFPDYEJKgX_VQiNAcwhp2RyA48o/edit#gid=1672366179">Catalyst project sheet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-3-testing-and-documentation"><a class="header" href="#catalyst-milestone-3-testing-and-documentation">Catalyst milestone 3: Testing and documentation</a></h1>
<h2 id="outputs-2"><a class="header" href="#outputs-2">Outputs</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A test suite checking for correct mapping from schema data types to PlutusData encodings against a known-good corpus of such mappings (golden tests).</p>
<ul>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus">lbt-plutus</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">Purescript</a> backends. They leverage both golden unit testing approach and randomized property based testing to assert the essential properties of the LambdaBuffers Plutus package:
<ul>
<li><code>Plutus.V1.PlutusData</code> derivation tests
<ul>
<li>Golden unit tests: <code>forall (golden : Days.Day.*.pd.json): (toJson . toPlutusData . fromPlutusData . fromJson) golden == golden</code></li>
<li>Property tests: <code>forall (x : Foo.*): (fromPlutusData . toPlutusData) x == x</code></li>
</ul>
</li>
<li><code>Plutus.V1.PlutusData</code> instance tests
<ul>
<li>Golden unit tests: <code>forall (golden : *.pd.json): (toJson . toPlutusData . fromPlutusData . fromJson) golden == golden</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A test suite checking for roundtrip compatibility between codegened target environments.</p>
<ul>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus">lbt-plutus</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">Purescript</a> backends.</li>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude">lbt-prelude</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">Purescript</a> backends.</li>
<li>Both include golden unit tests that provide assurances that these backends implement the LambdaBuffers packages in a mutually compatible manner.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A modular and contract-based test suite architecture streamlining codegen testing compliance for any of the supported typeclasses.</p>
<ul>
<li>A testing strategy was devised and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites">implemented</a> where each supported backend must implement the <code>lbt</code> (ie. a LambdaBuffers test suite) for the corresponding LambdaBuffers package. A package is a collection of LambdaBuffers schemas and their associated runtime libraries.</li>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-prelude">runtimes/haskell/lbr-prelude</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-prelude">runtimes/purescript/lbr-prelude</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">testsuites/lbt-prelude/lbt-prelude-haskell
</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">testsuites/lbt-prelude/lbt-prelude-purescript
</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-plutus">runtimes/haskell/lbr-plutus
</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-plutus">runtimes/purescript/lbr-plutus</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">testsuites/lbt-plutus/lbt-plutus-haskell</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">testsuites/lbt-plutus/lbt-plutus-purescript</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A document mapping the schema data types and typeclasses to their corresponding code-generated variants in the target environments.</p>
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-2"><a class="header" href="#acceptance-criteria-2">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The test suites are passing for the Haskell+PlutusTx codegen module.
<ul>
<li>CI targets:
<ul>
<li>checks.x86_64-linux."check-lbt-prelude-haskell:test:tests"</li>
<li>checks.x86_64-linux."check-lbt-plutus-haskell:test:tests"</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The test suites are passing for the Purescript+CTL codegen module.
<ul>
<li>CI targets:
<ul>
<li>checks.x86_64-linux."purescript:lbt-plutus:check"</li>
<li>checks.x86_64-linux."purescript:lbt-prelude:check"</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The “Mappings” document is made available in the project repository.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-2"><a class="header" href="#evidence-of-milestone-completion-2">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed test suite implementation for Haskell+PlutusTx codegen module is made available in the project repository.
<ul>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-prelude">runtimes/haskell/lbr-prelude</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">testsuites/lbt-prelude/lbt-prelude-haskell
</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-plutus">runtimes/haskell/lbr-plutus
</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">testsuites/lbt-plutus/lbt-plutus-haskell</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed test suite implementation for Purescript+CTL codegen module is made available in the project repository.
<ul>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-prelude">runtimes/purescript/lbr-prelude</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">testsuites/lbt-prelude/lbt-prelude-purescript
</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-plutus">runtimes/purescript/lbr-plutus</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">testsuites/lbt-plutus/lbt-plutus-purescript</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The “Mappings” document is made available in the project repository.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Robust Test cases to catch edge conditions are added against a wide variety of schemas, and output in all codegen backends.
<ul>
<li>Implemented as part of <code>lbf</code> (LambdaBuffers Frontend) test suite.</li>
</ul>
</li>
</ul>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/16dTxgGsxHvcMe5aCgFPDYEJKgX_VQiNAcwhp2RyA48o/edit#gid=1672366179">Catalyst project sheet</a></li>
</ul>
<h2 id="documentation-strategy"><a class="header" href="#documentation-strategy">Documentation strategy</a></h2>
<p>Each typeclass receives a Specification document that closely explains the required semantics for LB types (sum/products/records).</p>
<p>Each backend receives a User documentation that elaborates on how the generated code is used.</p>
<h2 id="testing-strategy"><a class="header" href="#testing-strategy">Testing strategy</a></h2>
<p>LambdaBuffers works with typeclasses, such as Eq, PlutusData and JSON. When a LB type has been declared with support for any of such typeclass, values of said types need to be handled in exactly the same manner as elaborated in the Specification for a given Typeclass in ALL support target language environments.</p>
<p>Concretely, if a type <code>Foo</code> has been declared with support for <code>JSON</code>, and <code>toJson</code> and <code>fromJson</code> methods have been generated for target languages, they have to be in correspondence.</p>
<pre><code class="language-lbf">module Foo

import Prelude (Json)

sum Foo = Bar Integer | Baz Text

deriving Json Foo
</code></pre>
<p>In Haskell and Purescript values of <code>Foo</code> would be <code>Bar 1</code> and <code>Baz "baz"</code>, and their respective JSON mappings would be <code>{"constructor" : "Bar", "product" : [1]}</code> and <code>{"constructor" : "Baz", "product" : ["baz"]}</code>.</p>
<h3 id="testing-encoding-typeclasses-from--to-goldens"><a class="header" href="#testing-encoding-typeclasses-from--to-goldens">Testing encoding typeclasses: <code>from . to</code> goldens</a></h3>
<p>For each typeclass, we maintain a set of <code>golden' files of known good/bad that lift into the target language with</code>from<code>and write it back with</code>to` into a separate file. Then we provide an assertion that these files are semantically 'equal' (for example JSON spaces don't matter and such).</p>
<p>Example test:</p>
<ul>
<li>test/foo/Foo.lbf</li>
<li>test/foo/json/bar.1.json</li>
<li>test/foo/json/bar.2.json</li>
<li>test/foo/json/baz.1.json</li>
<li>test/foo/json/baz.2.json</li>
<li>test/foo/json/haskell/bar.1.json</li>
<li>test/foo/json/haskell/bar.2.json</li>
<li>test/foo/json/haskell/baz.1.json</li>
<li>test/foo/json/haskell/baz.2.json</li>
<li>test/foo/json/purescript/bar.1.json</li>
<li>test/foo/json/purescript/bar.2.json</li>
<li>test/foo/json/purescript/baz.1.json</li>
<li>test/foo/json/purescript/baz.2.json</li>
<li>test/foo/plutusdata/bar.1.json</li>
<li>test/foo/plutusdata/bar.2.json</li>
<li>test/foo/plutusdata/baz.1.json</li>
<li>test/foo/plutusdata/baz.2.json</li>
<li>test/foo/plutusdata/haskell/bar.1.json</li>
<li>test/foo/plutusdata/haskell/bar.2.json</li>
<li>test/foo/plutusdata/haskell/baz.1.json</li>
<li>test/foo/plutusdata/haskell/baz.2.json</li>
<li>test/foo/plutusdata/purescript/bar.1.json</li>
<li>test/foo/plutusdata/purescript/bar.2.json</li>
<li>test/foo/plutusdata/purescript/baz.1.json</li>
<li>test/foo/plutusdata/purescript/baz.2.json</li>
</ul>
<h3 id="testing-equality-typeclasses-symmetry-and-transitivity"><a class="header" href="#testing-equality-typeclasses-symmetry-and-transitivity">Testing equality typeclasses: symmetry and transitivity</a></h3>
<ul>
<li><code>sym :: (a :~: b) -&gt; b :~: a</code></li>
<li><code>trans :: (a :~: b) -&gt; (b :~: c) -&gt; a :~: c</code></li>
</ul>
<p>This could be done with goldens and randomized testing. However, <code>goldens</code> approach assumes a correct marshaling procedure while the <code>randomized</code> assumes generators. Perhaps having both makes sense.</p>
<h2 id="todo-provide-time-estimates"><a class="header" href="#todo-provide-time-estimates">TODO (provide time estimates)</a></h2>
<ol start="0">
<li>Define the version 1 of <code>Prelude</code> and <code>Plutus</code> LBF libraries which MUST be supported</li>
<li>Support the Json typeclass
<ol>
<li>Codegen</li>
<li>Runtime support</li>
</ol>
</li>
<li>Support the Plutarch backend</li>
<li>Document typeclasses
<ol>
<li>Eq</li>
<li>PlutusData</li>
<li>Json</li>
</ol>
</li>
<li>Document backends
<ol>
<li>Sum/Product/Record type construction and deconstruction (Haskell, Purescript, Plutarch)</li>
<li>Eq/Json/PlutusData typeclass use (Haskell, Purescript, Plutarch minus Json)</li>
</ol>
</li>
<li>Devise <code>goldens</code>
<ol>
<li>Eq</li>
<li>PlutusData</li>
<li>Json</li>
</ol>
</li>
<li>Implement the test suite
<ol>
<li>Provide assertions</li>
<li>Hook to the CI</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-3-testing-and-documentation-1"><a class="header" href="#catalyst-milestone-3-testing-and-documentation-1">Catalyst milestone 3: Testing and documentation</a></h1>
<h2 id="outputs-3"><a class="header" href="#outputs-3">Outputs</a></h2>
<ul>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A test suite checking for correct mapping from schema data types to PlutusData encodings against a known-good corpus of such mappings (golden tests).</p>
<ul>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus">lbt-plutus</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">Purescript</a> backends. They leverage both golden unit testing approach and randomized property based testing to assert the essential properties of the LambdaBuffers Plutus package:
<ul>
<li><code>Plutus.V1.PlutusData</code> derivation tests
<ul>
<li>Golden unit tests: <code>forall (golden : Days.Day.*.pd.json): (toJson . toPlutusData . fromPlutusData . fromJson) golden == golden</code></li>
<li>Property tests: <code>forall (x : Foo.*): (fromPlutusData . toPlutusData) x == x</code></li>
</ul>
</li>
<li><code>Plutus.V1.PlutusData</code> instance tests
<ul>
<li>Golden unit tests: <code>forall (golden : *.pd.json): (toJson . toPlutusData . fromPlutusData . fromJson) golden == golden</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A test suite checking for roundtrip compatibility between codegened target environments.</p>
<ul>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus">lbt-plutus</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">Purescript</a> backends.</li>
<li>A dedicated <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude">lbt-prelude</a> test suite was implemented for both <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">Haskell</a> and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">Purescript</a> backends.</li>
<li>Both include golden unit tests that provide assurances that these backends implement the LambdaBuffers packages in a mutually compatible manner.</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A modular and contract-based test suite architecture streamlining codegen testing compliance for any of the supported typeclasses.</p>
<ul>
<li>A testing strategy was devised and <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites">implemented</a> where each supported backend must implement the <code>lbt</code> (ie. a LambdaBuffers test suite) for the corresponding LambdaBuffers package. A package is a collection of LambdaBuffers schemas and their associated runtime libraries.</li>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-prelude">runtimes/haskell/lbr-prelude</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-prelude">runtimes/purescript/lbr-prelude</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">testsuites/lbt-prelude/lbt-prelude-haskell
</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">testsuites/lbt-prelude/lbt-prelude-purescript
</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-plutus">runtimes/haskell/lbr-plutus
</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-plutus">runtimes/purescript/lbr-plutus</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">testsuites/lbt-plutus/lbt-plutus-haskell</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">testsuites/lbt-plutus/lbt-plutus-purescript</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><input disabled="" type="checkbox" checked=""/>
A document mapping the schema data types and typeclasses to their corresponding code-generated variants in the target environments.</p>
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-3"><a class="header" href="#acceptance-criteria-3">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The test suites are passing for the Haskell+PlutusTx codegen module.
<ul>
<li>CI targets:
<ul>
<li>checks.x86_64-linux."check-lbt-prelude-haskell:test:tests"</li>
<li>checks.x86_64-linux."check-lbt-plutus-haskell:test:tests"</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The test suites are passing for the Purescript+CTL codegen module.
<ul>
<li>CI targets:
<ul>
<li>checks.x86_64-linux."purescript:lbt-plutus:check"</li>
<li>checks.x86_64-linux."purescript:lbt-prelude:check"</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The “Mappings” document is made available in the project repository.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-3"><a class="header" href="#evidence-of-milestone-completion-3">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed test suite implementation for Haskell+PlutusTx codegen module is made available in the project repository.
<ul>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-prelude">runtimes/haskell/lbr-prelude</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-haskell">testsuites/lbt-prelude/lbt-prelude-haskell
</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Haskell runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/haskell/lbr-plutus">runtimes/haskell/lbr-plutus
</a></li>
<li>Haskell test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-haskell">testsuites/lbt-plutus/lbt-plutus-haskell</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed test suite implementation for Purescript+CTL codegen module is made available in the project repository.
<ul>
<li>LambdaBuffers Prelude
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-prelude">libs/lbf-prelude</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-prelude">runtimes/purescript/lbr-prelude</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-prelude/lbt-prelude-purescript">testsuites/lbt-prelude/lbt-prelude-purescript
</a></li>
</ul>
</li>
<li>LambdaBuffers Plutus
<ul>
<li>Schemas are available at <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/libs/lbf-plutus">libs/lbf-plutus</a></li>
<li>Purescript runtime library is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/runtimes/purescript/lbr-plutus">runtimes/purescript/lbr-plutus</a></li>
<li>Purescript test suite is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/e7813017bd1575fa9346ac4264deb68b50128b7c/testsuites/lbt-plutus/lbt-plutus-purescript">testsuites/lbt-plutus/lbt-plutus-purescript</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The “Mappings” document is made available in the project repository.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/haskell.html">LambdaBuffers to Haskell</a> documentation.</li>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/purescript.html">LambdaBuffers to Purescript</a> documentation.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Test case: Robust Test cases to catch edge conditions are added against a wide variety of schemas, and output in all codegen backends.
<ul>
<li>Implemented as part of <code>lbf</code> (LambdaBuffers Frontend) test suite.</li>
</ul>
</li>
</ul>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<ul>
<li><a href="https://docs.google.com/spreadsheets/d/16dTxgGsxHvcMe5aCgFPDYEJKgX_VQiNAcwhp2RyA48o/edit#gid=1672366179">Catalyst project sheet</a></li>
</ul>
<h2 id="documentation-strategy-1"><a class="header" href="#documentation-strategy-1">Documentation strategy</a></h2>
<p>Each typeclass receives a Specification document that closely explains the required semantics for LB types (sum/products/records).</p>
<p>Each backend receives a User documentation that elaborates on how the generated code is used.</p>
<h2 id="testing-strategy-1"><a class="header" href="#testing-strategy-1">Testing strategy</a></h2>
<p>LambdaBuffers works with typeclasses, such as Eq, PlutusData and JSON. When a LB type has been declared with support for any of such typeclass, values of said types need to be handled in exactly the same manner as elaborated in the Specification for a given Typeclass in ALL support target language environments.</p>
<p>Concretely, if a type <code>Foo</code> has been declared with support for <code>JSON</code>, and <code>toJson</code> and <code>fromJson</code> methods have been generated for target languages, they have to be in correspondence.</p>
<pre><code class="language-lbf">module Foo

import Prelude (Json)

sum Foo = Bar Integer | Baz Text

deriving Json Foo
</code></pre>
<p>In Haskell and Purescript values of <code>Foo</code> would be <code>Bar 1</code> and <code>Baz "baz"</code>, and their respective JSON mappings would be <code>{"constructor" : "Bar", "product" : [1]}</code> and <code>{"constructor" : "Baz", "product" : ["baz"]}</code>.</p>
<h3 id="testing-encoding-typeclasses-from--to-goldens-1"><a class="header" href="#testing-encoding-typeclasses-from--to-goldens-1">Testing encoding typeclasses: <code>from . to</code> goldens</a></h3>
<p>For each typeclass, we maintain a set of <code>golden' files of known good/bad that lift into the target language with</code>from<code>and write it back with</code>to` into a separate file. Then we provide an assertion that these files are semantically 'equal' (for example JSON spaces don't matter and such).</p>
<p>Example test:</p>
<ul>
<li>test/foo/Foo.lbf</li>
<li>test/foo/json/bar.1.json</li>
<li>test/foo/json/bar.2.json</li>
<li>test/foo/json/baz.1.json</li>
<li>test/foo/json/baz.2.json</li>
<li>test/foo/json/haskell/bar.1.json</li>
<li>test/foo/json/haskell/bar.2.json</li>
<li>test/foo/json/haskell/baz.1.json</li>
<li>test/foo/json/haskell/baz.2.json</li>
<li>test/foo/json/purescript/bar.1.json</li>
<li>test/foo/json/purescript/bar.2.json</li>
<li>test/foo/json/purescript/baz.1.json</li>
<li>test/foo/json/purescript/baz.2.json</li>
<li>test/foo/plutusdata/bar.1.json</li>
<li>test/foo/plutusdata/bar.2.json</li>
<li>test/foo/plutusdata/baz.1.json</li>
<li>test/foo/plutusdata/baz.2.json</li>
<li>test/foo/plutusdata/haskell/bar.1.json</li>
<li>test/foo/plutusdata/haskell/bar.2.json</li>
<li>test/foo/plutusdata/haskell/baz.1.json</li>
<li>test/foo/plutusdata/haskell/baz.2.json</li>
<li>test/foo/plutusdata/purescript/bar.1.json</li>
<li>test/foo/plutusdata/purescript/bar.2.json</li>
<li>test/foo/plutusdata/purescript/baz.1.json</li>
<li>test/foo/plutusdata/purescript/baz.2.json</li>
</ul>
<h3 id="testing-equality-typeclasses-symmetry-and-transitivity-1"><a class="header" href="#testing-equality-typeclasses-symmetry-and-transitivity-1">Testing equality typeclasses: symmetry and transitivity</a></h3>
<ul>
<li><code>sym :: (a :~: b) -&gt; b :~: a</code></li>
<li><code>trans :: (a :~: b) -&gt; (b :~: c) -&gt; a :~: c</code></li>
</ul>
<p>This could be done with goldens and randomized testing. However, <code>goldens</code> approach assumes a correct marshaling procedure while the <code>randomized</code> assumes generators. Perhaps having both makes sense.</p>
<h2 id="todo-provide-time-estimates-1"><a class="header" href="#todo-provide-time-estimates-1">TODO (provide time estimates)</a></h2>
<ol start="0">
<li>Define the version 1 of <code>Prelude</code> and <code>Plutus</code> LBF libraries which MUST be supported</li>
<li>Support the Json typeclass
<ol>
<li>Codegen</li>
<li>Runtime support</li>
</ol>
</li>
<li>Support the Plutarch backend</li>
<li>Document typeclasses
<ol>
<li>Eq</li>
<li>PlutusData</li>
<li>Json</li>
</ol>
</li>
<li>Document backends
<ol>
<li>Sum/Product/Record type construction and deconstruction (Haskell, Purescript, Plutarch)</li>
<li>Eq/Json/PlutusData typeclass use (Haskell, Purescript, Plutarch minus Json)</li>
</ol>
</li>
<li>Devise <code>goldens</code>
<ol>
<li>Eq</li>
<li>PlutusData</li>
<li>Json</li>
</ol>
</li>
<li>Implement the test suite
<ol>
<li>Provide assertions</li>
<li>Hook to the CI</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-10-reports"><a class="header" href="#catalyst-10-reports">Catalyst 10 reports</a></h1>
<ul>
<li><a href="catalyst10-reports/catalyst10-reports/milestone-1.html">Milestone 1: Rust support</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalyst-milestone-1-rust-support"><a class="header" href="#catalyst-milestone-1-rust-support">Catalyst milestone 1: Rust support</a></h1>
<h2 id="outputs-4"><a class="header" href="#outputs-4">Outputs</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
A LambdaBuffers code generation module that outputs type definitions and derived implementations in the Rust programming language given a LambdaBuffers schema.
<ul>
<li>The module implementation is in <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/lambda-buffers-codegen/src/LambdaBuffers/Codegen/Rust">lambda-buffers-codegen/src/LambdaBuffers/Codegen/Rust</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Rust library that implements the LambdaBuffers Prelude runtime. This module would include standardised JSON encoding and equality implementations for all declared type class instances in the schema.
<ul>
<li>A Prelude library for Rust was implemented together with a separate library for Json trait instance derive macros. These can be found here:
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/runtimes/rust/lbr-prelude">runtimes/rust/lbr-prelude</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/runtimes/rust/lbr-prelude-derive">runtimes/rust/lbr-prelude-derive</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Rust test suite that assures the manually implemented and automatically generated implementations are consistent with the predefined LambdaBuffers Prelude golden data set of JSON files and perform correct implementation derivation.
<ul>
<li>A test suite was implemented with automatically generated Rust types and trait implementations for Prelude types, it can be found here: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-prelude/lbt-prelude-rust">testsuites/lbt-prelude/lbt-prelude-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Rust library that implements the LambdaBuffers Plutus runtime. This module would include standardised PlutusData encoding implementations for all declared type class instances in the Plutus schema.
<ul>
<li>A standalone library was implemented (still in active development) with Plutus ledger types. LambdaBuffers runtime functionality is included in this library: <a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust/tree/23eb5df1be03e5983865867f74a2933b7063414d">plutus-ledger-api-rust</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
A Rust test suite that assures the manually implemented and automatically generated implementations are consistent with the predefined LambdaBuffers Plutus golden data set of PlutusData encoded files and perform correct implementation derivation.
<ul>
<li>A test suite was implemented with automatically generated Rust types and trait implementations for Plutus types, it can be found here: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-plutus/lbt-plutus-rust">testsuites/lbt-plutus/lbt-plutus-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Nix devops modules (Nix API) for streamlining the LambdaBuffers code generation pipeline to Rust.
<ul>
<li>New flake modules were implemented to easily generate Rust crates from LambdaBuffers:
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-rust.nix">lbf-rust</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-prelude-rust.nix">lbf-prelude-rust</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-plutus-rust.nix">lbf-plutus-rust</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Documentation on LambdaBuffers usage patterns for Rust.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/rust.html">A new page was created for the Rust use case</a></li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-4"><a class="header" href="#acceptance-criteria-4">Acceptance Criteria</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
LambdaBuffers schemas that are based on the LambdaBuffers Prelude module can be used in Rust projects to specify application types.
<ul>
<li>Test libraries for Prelude demonstrate how Rust code for LambdaBuffers Prelude is generated to Rust and used in a library: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-prelude/lbt-prelude-rust">testsuites/lbt-prelude/lbt-prelude-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
LambdaBuffers schemas that are based on the LambdaBuffers Plutus module can be used in Rust projects to specify application types.
<ul>
<li>Test libraries for Prelude demonstrate how Rust code for LambdaBuffers Plutus is generated to Rust and used in a library: <a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-plutus/lbt-plutus-rust">testsuites/lbt-plutus/lbt-plutus-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The documentation and devops tooling is available to facilitate easy adoption.
<ul>
<li>Similarly to other languages supported by LambdaBuffers, a Rust flake is implemented. The testing libraries also serve as an example, to understand how to use these Nix utilities:
<a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-plutus/lbt-plutus-rust/build.nix">testsuites/lbt-plutus/lbt-plutus-rust/build.nix</a></li>
</ul>
</li>
</ul>
<h2 id="evidence-of-milestone-completion-4"><a class="header" href="#evidence-of-milestone-completion-4">Evidence of Milestone Completion</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Prelude runtime library is available for the Rust programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/runtimes/rust/lbr-prelude">runtimes/rust/lbr-prelude</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/runtimes/rust/lbr-prelude-derive">runtimes/rust/lbr-prelude-derive</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Plutus runtime library is available for the Rust programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/plutus-ledger-api-rust/tree/23eb5df1be03e5983865867f74a2933b7063414d">plutus-ledger-api-rust</a>.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Prelude test suite is available and is passing in CI for the Rust programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-prelude/lbt-prelude-rust">testsuites/lbt-prelude/lbt-prelude-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers Plutus test suite is available and is passing in CI for the Rust programming language.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/tree/c83cdf9b881a95b8607821027c3551ecd56c9447/testsuites/lbt-plutus/lbt-plutus-rust">testsuites/lbt-plutus/lbt-plutus-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed Nix API for LambdaBuffers Rust support is available.
<ul>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-rust.nix">lbf-rust</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-prelude-rust.nix">lbf-prelude-rust</a></li>
<li><a href="https://github.com/mlabs-haskell/lambda-buffers/blob/c83cdf9b881a95b8607821027c3551ecd56c9447/extras/lbf-nix/lbf-plutus-rust.nix">lbf-plutus-rust</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
The completed and reviewed LambdaBuffers for Rust documentation is available.
<ul>
<li><a href="https://mlabs-haskell.github.io/lambda-buffers/rust.html">Rust documentation</a></li>
</ul>
</li>
</ul>
<h2 id="demo-files"><a class="header" href="#demo-files">Demo files</a></h2>
<ul>
<li>Demo project: <a href="https://github.com/mlabs-haskell/lambda-buffers-for-cardano/tree/main/transactions/demo-rust">lambda-buffers-for-cardano</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
