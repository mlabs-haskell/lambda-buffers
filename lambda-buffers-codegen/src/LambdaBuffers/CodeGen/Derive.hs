
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DataKinds, TypeFamilies #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# OPTIONS_GHC -Wno-redundant-constraints #-}

module LambdaBuffers.CodeGen.Derive where

import Control.Monad.Trans.Except (ExceptT, throwE, runExceptT)
import Data.Foldable (traverse_)
import Data.Map.Strict (Map)
import Control.Monad.State.Class
import Control.Monad.State
import Prettyprinter
import Debug.Trace (trace)

import LambdaBuffers.Common.TypeClass.Pat
import LambdaBuffers.Common.TypeClass.Solve
import LambdaBuffers.Common.TypeClass.Rules
import LambdaBuffers.CodeGen.Generator

import qualified Data.Map.Strict as M


{- The typeclass machinery should perform two tasks when it encounters an instance declaration for a given type:

  - 1) It should check whether the instance is already covered by existing rules. If so, it should emit nothing, and note
       (somewhere/somehow) that the instance is satisfied by rules that already exist.

  - 2) If the instance is *not* covered by existing rules, then it needs to determine whether the instance can be derived.

Notes:

  - In step 1, the machinery only needs to be aware of the set of concrete instances that are in scope by default in any
    LB module for that language.

  - In step 2, the machinery needs access to a set of generators associated with rules.
    - In the simple case, where the matching rule is of the form (Rule c pat),
      we simply lookup the associated generator and run it on the type

    - In the complex case, where the matching rules is of the form (Rule c pat :<= cs)), we interpret the rule as asserting that the
      generator succeed only if the constraints are satisfied, so the constraints must be checked as in Step 1, making sure to
      keep track of instances generated by previous iterations of step 2) so they can be included in the set of "existing instances"
      utilized by step 1

    - The previous remark implies that a generator should be written under the assumption that all of its constraints hold.

    - More expressive/powerful languages can have a larger number of "already exists" instances. We can leverage existing generics
      machinery in Haskell/PureScript (and possibly rust albeit to a lesser extent) to minimize the number of generators necessary

    - Generator rules will tend to be *structural*, i.e. to operate on Rec/Prod/Sum patterns.

Deriving algorithm:
  - 1) Check whether the instance already exists (utilizing `solve` and a set of in-scope instances).
       - If yes: Do nothing, report success
       - If no: Check the generator rules for a matching instance head.
             - If there is no matching head, fail
             - If there is a matching head:
                  - If the head has no constraints, run the generator on the type
                  - If the head has constraints, attempt to resolve them. If resolution fails for
                    one or more constraints, attempt to derive them.
                      - If a constraint cannot be derived, fail and report the failure.
                      - If a constraint has been derived, add it to the set of existing instances and attempt derivation again.

-}

data DeriveError
 = NoGenerator Constraint
 | GenError Constraint  -- should wrap an error from a generator (once i figure out what those will be)
 | ConstraintFail [Constraint]
 | MultipleMatchingGenerators Constraint [Instance]
 deriving stock (Show, Eq)

type GenTable l = Map Instance (InstanceGen l)

newtype Assumptions = Assumptions  [Constraint]

noAssumptions :: Assumptions
noAssumptions = Assumptions []

assume :: [Constraint] -> [Instance]
assume cs = for cs $ \(C c t) -> C c t :<= []

data DeriveState (l :: Lang) = DeriveState {
  scope      :: [Instance],
  generators :: GenTable l,
  output     :: [DSL l]
}

splitInstance :: Instance -> (Constraint, [Constraint])
splitInstance (C c t :<= is) = (C c t, is)

type DeriveM l a = ExceptT DeriveError (State (DeriveState l)) a

simplify :: Rule -> Rule
simplify (C c t :<= _)= C c t :<= []

{- NOTE: Right now this recursively derives and generates code for all of the necessary constraints.
         If you want to change that so that it only derives the present constraint, comment out ***1*** and
         replace the body of the do-block before ***2*** with the commented code in ***2***

         ***2*** tries to derive all of the (substituted) constraints on the matching rule instance (which is the key)
         in the GenTable. That might not be very useful because the substituted constraints on the rule instance will
         usually refer to a structural subcomponent of a type decl which cannot be meaningfully generated
         (though I'm not sure if this will always be the case).

         ***1*** tries to derive all of the subgoal constraints needed for `cst`, which is in fact very useful.
-}
derive :: forall (l :: Lang)
        . TargetLang l
       => Assumptions {- Constraints which are assumed to hold locally for the purposes of code generation. Needed to handle type variables in user defined constrained instances, e.g. instance (C a, C b) => C (Foo a b) -}
       -> Constraint
       -> DeriveM l  ()  -- switch from String to something better
derive axs@(Assumptions as) cst@(C _ cp) = do
  let given = assume as
  DeriveState{..} <- get
  case solve (given <> scope) cst of
   [] -> pure ()
   xs -> do
     -- have to filter or it will loop forever b/c if `solve` can't solve cst then cst will always be an elem of the result
     traverse_ (derive axs) $ filter (/= cst) xs -- ***1***
     (genRule, generator) <- findMatchingGen
     case genRule of
       C _ _ :<= [] -> processGen genRule generator

       _ :<= iConstraints -> do
         traverse_ (derive axs) iConstraints
         processGen genRule generator

         {- ***2***
         (DeriveState sc _ _) <- get
         case concat $ traverse (solve sc) iConstraints of
           [] -> processGen genRule generator
           others -> throwE $ ConstraintFail others
         -}
 where
   processGen :: Instance -> InstanceGen l -> DeriveM l ()
   processGen genRule generator = case gen generator cp of
     Left _    -> throwE $ GenError cst
     Right dsl -> modify' $ \(DeriveState sc ge out) ->
       -- we simplify a (r :<= cs) constraint b/c at this point we know that `cs` has been derived or solved
       DeriveState (simplify genRule:sc) ge (dsl:out)

   findMatchingGen :: DeriveM l (Instance, InstanceGen l)
   findMatchingGen = do
     gs  <- gets (M.toList . generators)
     case filter (matchInstance cst . fst) gs of
       []           -> throwE $ NoGenerator cst
       [(gPat,g)] -> pure (subst gPat cp,g)
       others       -> throwE $ MultipleMatchingGenerators cst (map fst others)

runDerive :: forall (l :: Lang)
           . (TargetLang l, DSL l ~ Doc ())
          => GenTable l
          -> [Instance]
          -> Instance -- Constraint l
          -> Either DeriveError [Doc ()]
runDerive gens scope inst  = case runState (runExceptT $ derive (Assumptions cs) c) st of
   (Left e,_) -> Left e
   (Right (), res) -> Right $ output res
  where
    (c,cs) = splitInstance inst
    st = DeriveState scope gens []

runDerive' :: forall (l :: Lang)
              . (TargetLang l, DSL l ~ Doc ())
             => Map Instance (InstanceGen l)
             -> [Instance]
             -> Instance
             -> IO ()
runDerive' g sc inst = either print (print . vcat) $ runDerive g sc inst

{- for debugging -}
pTrace :: forall a b. Show a => String -> a -> b -> b
pTrace msg a = trace (msg <> " " <> show a <> "\n")

prettyList :: forall a. Show a => [a] -> String
prettyList = concatMap (\a -> show a <> "\n\n")
